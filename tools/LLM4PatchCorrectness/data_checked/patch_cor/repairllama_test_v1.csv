1,public abstract class ListPopulation implements Population {       * @return chromosome iterator       */      public Iterator<Chromosome> iterator() { -        return chromosomes.iterator(); +// buggy code +//         return chromosomes.iterator(); +       return new Iterator<Chromosome>() { +            int i = 0; +            @Override +            public boolean hasNext() { +                return i < chromosomes.size(); +            } + +            @Override +            public Chromosome next() { +                return chromosomes.get(i++); +            } +        };      }  }
1,"public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {      /** {@inheritDoc} */      @Override      protected void computeGeometricalProperties() { -          final Vector2D[][] v = getVertices(); -          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { -                // the instance covers the whole space +// buggy code +//             if ((Boolean) tree.getAttribute()) { +           if (tree.getAttribute() == null) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN);              } else { @@ -142,16 +141,12 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {                  setBarycenter(new Vector2D(0, 0));              }          } else if (v[0][0] == null) { -            // there is at least one open-loop: the polygon is infinite              setSize(Double.POSITIVE_INFINITY);              setBarycenter(Vector2D.NaN);          } else { -            // all loops are closed, we compute some integrals around the shape -              double sum  = 0;              double sumX = 0;              double sumY = 0; -              for (Vector2D[] loop : v) {                  double x1 = loop[loop.length - 1].getX();                  double y1 = loop[loop.length - 1].getY(); @@ -166,18 +161,14 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {                      sumY += factor * (y0 + y1);                  }              } -              if (sum < 0) { -                // the polygon as a finite outside surrounded by an infinite inside                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN);              } else {                  setSize(sum / 2);                  setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));              } -          } -      }        /** Get the vertices of the polygon."
1,public abstract class ListPopulation implements Population {       * @return chromosome iterator       */      public Iterator<Chromosome> iterator() { -        return chromosomes.iterator(); +// buggy code +//         return chromosomes.iterator(); +       return Collections.unmodifiableList(chromosomes).iterator();      }  }
1,"public final class MathUtils {       * @return the L<sub>2</sub> distance between the two points       */      public static double distance(int[] p1, int[] p2) { -      int sum = 0; +// buggy code +//       int sum = 0; +//       for (int i = 0; i < p1.length; i++) { +//           final int dp = p1[i] - p2[i]; +     double sum = 0.0;        for (int i = 0; i < p1.length; i++) { -          final int dp = p1[i] - p2[i]; +          final double dp = p1[i] - p2[i];            sum += dp * dp;        }        return Math.sqrt(sum);"
1,"public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {      /** {@inheritDoc} */      @Override      protected void computeGeometricalProperties() { -          final Vector2D[][] v = getVertices(); -          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { -                // the instance covers the whole space +// buggy code +//             if ((Boolean) tree.getAttribute()) { +           if (Boolean.TRUE.equals(tree.getAttribute())) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN);              } else { @@ -142,16 +141,12 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {                  setBarycenter(new Vector2D(0, 0));              }          } else if (v[0][0] == null) { -            // there is at least one open-loop: the polygon is infinite              setSize(Double.POSITIVE_INFINITY);              setBarycenter(Vector2D.NaN);          } else { -            // all loops are closed, we compute some integrals around the shape -              double sum  = 0;              double sumX = 0;              double sumY = 0; -              for (Vector2D[] loop : v) {                  double x1 = loop[loop.length - 1].getX();                  double y1 = loop[loop.length - 1].getY(); @@ -166,18 +161,14 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {                      sumY += factor * (y0 + y1);                  }              } -              if (sum < 0) { -                // the polygon as a finite outside surrounded by an infinite inside                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN);              } else {                  setSize(sum / 2);                  setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));              } -          } -      }        /** Get the vertices of the polygon."
1,"public abstract class BaseSecantSolver        /** {@inheritDoc} */      protected final double doSolve() { -        // Get initial solution          double x0 = getMin();          double x1 = getMax();          double f0 = computeObjectiveValue(x0);          double f1 = computeObjectiveValue(x1); - -        // If one of the bounds is the exact root, return it. Since these are -        // not under-approximations or over-approximations, we can return them -        // regardless of the allowed solutions.          if (f0 == 0.0) {              return x0;          }          if (f1 == 0.0) {              return x1;          } - -        // Verify bracketing of initial solution.          verifyBracketing(x0, x1); - -        // Get accuracies.          final double ftol = getFunctionValueAccuracy();          final double atol = getAbsoluteAccuracy();          final double rtol = getRelativeAccuracy(); - -        // Keep track of inverted intervals, meaning that the left bound is -        // larger than the right bound.          boolean inverted = false; - -        // Keep finding better approximations.          while (true) { -            // Calculate the next approximation.              final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));              final double fx = computeObjectiveValue(x); - -            // If the new approximation is the exact root, return it. Since -            // this is not an under-approximation or an over-approximation, -            // we can return it regardless of the allowed solutions.              if (fx == 0.0) {                  return x;              } - -            // Update the bounds with the new approximation.              if (f1 * fx < 0) { -                // The value of x1 has switched to the other bound, thus inverting -                // the interval.                  x0 = x1;                  f0 = f1;                  inverted = !inverted; @@ -183,24 +160,22 @@ public abstract class BaseSecantSolver                      f0 *= f1 / (f1 + fx);                      break;                  case REGULA_FALSI: -                    // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +// buggy code +//                     if (x == x1) { +//                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +//                         f0 = computeObjectiveValue(x0); +//                     } +                   if (x == x0) { +                        x1 = 0.5 * (x0 + x1 + FastMath.max(rtol * FastMath.abs(x0), atol)); +                        f1 = computeObjectiveValue(x1);                      }                      break;                  default: -                    // Should never happen.                      throw new MathInternalError();                  }              } -            // Update from [x0, x1] to [x0, x].              x1 = x;              f1 = fx; - -            // If the function value of the last approximation is too small, -            // given the function value accuracy, then we can't get closer to -            // the root than we already are.              if (FastMath.abs(f1) <= ftol) {                  switch (allowed) {                  case ANY_SIDE: @@ -229,9 +204,6 @@ public abstract class BaseSecantSolver                      throw new MathInternalError();                  }              } - -            // If the current interval is within the given accuracies, we -            // are satisfied with the current approximation.              if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),                                                       atol)) {                  switch (allowed) {"
1,"public class MultiDirectional extends DirectSearchOptimizer {      @Override      protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)          throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { - +// buggy code +//         while (true) { +//             incrementIterationsCounter(); +//             final RealPointValuePair[] original = simplex; +//             final RealPointValuePair best = original[0]; +//             final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator); +//             if (comparator.compare(reflected, best) < 0) { +//                 final RealPointValuePair[] reflectedSimplex = simplex; +//                 final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator); +//                 if (comparator.compare(reflected, expanded) <= 0) { +//                     simplex = reflectedSimplex; +//                 } +//                 return; +//             } +//             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); +//             if (comparator.compare(contracted, best) < 0) { +//                 return; +//             }         while (true) { -              incrementIterationsCounter(); - -            // save the original vertex              final RealPointValuePair[] original = simplex;              final RealPointValuePair best = original[0]; - -            // perform a reflection step              final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);              if (comparator.compare(reflected, best) < 0) { - -                // compute the expanded simplex                  final RealPointValuePair[] reflectedSimplex = simplex;                  final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);                  if (comparator.compare(reflected, expanded) <= 0) { -                    // accept the reflected simplex                      simplex = reflectedSimplex;                  } -                  return; -              } - -            // compute the contracted simplex              final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); -            if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence +            if (comparator.compare(contracted, best) <= 0) {                  return;              } -          } -      }        /** Compute and evaluate a new simplex."
1,"public class BooleanUtils {       * @return the boolean value of the string, <code>false</code> if no match       */      public static boolean toBoolean(String str) { -        // Previously used equalsIgnoreCase, which was fast for interned 'true'. -        // Non interned 'true' matched 15 times slower. -        //  -        // Optimisation provides same performance as before for interned 'true'. -        // Similar performance for null, 'false', and other strings not length 2/3/4. -        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.          if (str == ""true"") {              return true;          } @@ -679,6 +673,9 @@ public class BooleanUtils {                          (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&                          (str.charAt(2) == 'S' || str.charAt(2) == 's');                  } +// buggy code +//  +               break;              }              case 4: {                  char ch = str.charAt(0);"
1,"public class UnivariateRealSolverUtils {              double initial, double lowerBound, double upperBound,               int maximumIterations) throws ConvergenceException,               FunctionEvaluationException { -                  if (function == null) {              throw MathRuntimeException.createIllegalArgumentException(""function is null"");          } @@ -184,18 +183,17 @@ public class UnivariateRealSolverUtils {          double fa;          double fb;          int numIterations = 0 ; -              do {              a = Math.max(a - 1.0, lowerBound);              b = Math.min(b + 1.0, upperBound);              fa = function.value(a); -                          fb = function.value(b);              numIterations++ ;          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound))); -    -        if (fa * fb >= 0.0 ) { +// buggy code +//         if (fa * fb >= 0.0 ) { +       if ((fa * fb >= 0.0 ) && (numIterations >= maximumIterations)) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + @@ -203,7 +201,6 @@ public class UnivariateRealSolverUtils {                        numIterations, maximumIterations, initial,                        lowerBound, upperBound, a, b, fa, fb);          } -                  return new double[]{a, b};      }"
1,"public class DateTimeFormatter {          if (instant == null) {              throw new IllegalArgumentException(""Instant must not be null"");          } -                  long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology(); -        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); +// buggy code +//         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); +//         chrono = selectChronology(chrono); +//         int defaultYear = chrono.year().get(instantLocal); +       long instantLocal = instantMillis; +        if (chrono.getZone() != null) { +            instantLocal += chrono.getZone().getOffset(instantMillis); +        }          chrono = selectChronology(chrono); -        int defaultYear = chrono.year().get(instantLocal); -         +        int defaultYear = chrono.year().get(instantMillis);          DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);          int newPos = parser.parseInto(bucket, text, position);"
1,public class ExtendedMessageFormat extends MessageFormat {          int start = pos.getIndex();          char[] c = pattern.toCharArray();          if (escapingOn && c[start] == QUOTE) { +// buggy code +//  +           pos.setIndex(start + 1);               return appendTo == null ? null : appendTo.append(QUOTE);          }          int lastHold = start;
1,"public class WordUtils {       * @since 2.4       */      public static String abbreviate(String str, int lower, int upper, String appendToEnd) { -        // initial parameter checks          if (str == null) {              return null;          }          if (str.length() == 0) {              return StringUtils.EMPTY; +// buggy code +//  +       } +        if (lower > str.length()) { +            return str;          } - -        // if the lower value is greater than the length of the string, -        // set to the length of the string -        // if the upper value is -1 (i.e. no limit) or is greater -        // than the length of the string, set to the length of the string          if (upper == -1 || upper > str.length()) {              upper = str.length();          } -        // if upper is less than lower, raise it to lower          if (upper < lower) {              upper = lower;          } -          StringBuffer result = new StringBuffer();          int index = StringUtils.indexOf(str, "" "", lower);          if (index == -1) {              result.append(str.substring(0, upper)); -            // only if abbreviation has occured do we append the appendToEnd value              if (upper != str.length()) {                  result.append(StringUtils.defaultString(appendToEnd));              }"
1,"public class BorderArrangement implements Arrangement, Serializable {          h[3] = h[2];          if (this.rightBlock != null) {              RectangleConstraint c4 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth() - w[2]), +// buggy code +//                     new Range(0.0, constraint.getWidth() - w[2]), +                   new Range(0.0, constraint.getWidth() - w[0]),                      LengthConstraintType.RANGE, h[2], null,                      LengthConstraintType.FIXED);              Size2D size = this.rightBlock.arrange(g2, c4); @@ -464,7 +466,6 @@ public class BorderArrangement implements Arrangement, Serializable {          if (this.centerBlock != null) {              this.centerBlock.arrange(g2, c5);          } -          if (this.topBlock != null) {              this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],                      h[0]));"
1,"public class SimplexSolver extends AbstractLinearOptimizer {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +// buggy code +//             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +           if (entry > 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;"
1,"public class MultivariateNormalDistribution          if (vals.length != dim) {              throw new DimensionMismatchException(vals.length, dim);          } - -        return FastMath.pow(2 * FastMath.PI, -dim / 2) * +// buggy code +//         return FastMath.pow(2 * FastMath.PI, -dim / 2) * +       return FastMath.pow(2 * FastMath.PI, -dim / 2D) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      }"
1,"public abstract class BaseSecantSolver        /** {@inheritDoc} */      protected final double doSolve() { -        // Get initial solution          double x0 = getMin();          double x1 = getMax();          double f0 = computeObjectiveValue(x0);          double f1 = computeObjectiveValue(x1); - -        // If one of the bounds is the exact root, return it. Since these are -        // not under-approximations or over-approximations, we can return them -        // regardless of the allowed solutions.          if (f0 == 0.0) {              return x0;          }          if (f1 == 0.0) {              return x1;          } - -        // Verify bracketing of initial solution.          verifyBracketing(x0, x1); - -        // Get accuracies.          final double ftol = getFunctionValueAccuracy();          final double atol = getAbsoluteAccuracy();          final double rtol = getRelativeAccuracy(); - -        // Keep track of inverted intervals, meaning that the left bound is -        // larger than the right bound.          boolean inverted = false; - -        // Keep finding better approximations.          while (true) { -            // Calculate the next approximation.              final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));              final double fx = computeObjectiveValue(x); - -            // If the new approximation is the exact root, return it. Since -            // this is not an under-approximation or an over-approximation, -            // we can return it regardless of the allowed solutions.              if (fx == 0.0) {                  return x;              } - -            // Update the bounds with the new approximation.              if (f1 * fx < 0) { -                // The value of x1 has switched to the other bound, thus inverting -                // the interval.                  x0 = x1;                  f0 = f1;                  inverted = !inverted; @@ -183,24 +160,22 @@ public abstract class BaseSecantSolver                      f0 *= f1 / (f1 + fx);                      break;                  case REGULA_FALSI: -                    // Nothing. +// buggy code +//                     if (x == x1) { +//                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +//                         f0 = computeObjectiveValue(x0); +//                     }                     if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +                        x0 = x1 - FastMath.max(rtol * FastMath.abs(x1), atol);                          f0 = computeObjectiveValue(x0);                      }                      break;                  default: -                    // Should never happen.                      throw new MathInternalError();                  }              } -            // Update from [x0, x1] to [x0, x].              x1 = x;              f1 = fx; - -            // If the function value of the last approximation is too small, -            // given the function value accuracy, then we can't get closer to -            // the root than we already are.              if (FastMath.abs(f1) <= ftol) {                  switch (allowed) {                  case ANY_SIDE: @@ -229,9 +204,6 @@ public abstract class BaseSecantSolver                      throw new MathInternalError();                  }              } - -            // If the current interval is within the given accuracies, we -            // are satisfied with the current approximation.              if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),                                                       atol)) {                  switch (allowed) {"
1,public class FDistributionImpl       * @return initial domain value       */      protected double getInitialDomain(double p) { -        double ret; -        double d = getDenominatorDegreesOfFreedom(); -            // use mean -            ret = d / (d - 2.0); +// buggy code +//         double ret; +//         double d = getDenominatorDegreesOfFreedom(); +//             ret = d / (d - 2.0); +       double ret = getDenominatorDegreesOfFreedom();          return ret;      }
1,public class ExtendedMessageFormat extends MessageFormat {          int start = pos.getIndex();          char[] c = pattern.toCharArray();          if (escapingOn && c[start] == QUOTE) { +// buggy code +//  +           pos.setIndex(start + 1);              return appendTo == null ? null : appendTo.append(QUOTE);          }          int lastHold = start;
1,"public class MannWhitneyUTest {                                               final int n1,                                               final int n2)          throws ConvergenceException, MaxCountExceededException { - -        final int n1n2prod = n1 * n2; - -        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation +// buggy code +//         final int n1n2prod = n1 * n2; +       final long n1n2prod = (long) n1 * (long) n2;          final double EU = n1n2prod / 2.0;          final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; -          final double z = (Umin - EU) / FastMath.sqrt(VarU); -          final NormalDistribution standardNormal = new NormalDistribution(0, 1); -          return 2 * standardNormal.cumulativeProbability(z);      }"
1,public class ExtendedMessageFormat extends MessageFormat {          int start = pos.getIndex();          char[] c = pattern.toCharArray();          if (escapingOn && c[start] == QUOTE) { +// buggy code +//  +           pos.setIndex(pos.getIndex()+1);              return appendTo == null ? null : appendTo.append(QUOTE);          }          int lastHold = start;
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +// buggy code +//         if (dataset != null) { +       if (dataset == null || !isSeriesVisibleInLegend(0)) {              return result;          }          int seriesCount = dataset.getRowCount();
1,"public class MultiDirectional extends DirectSearchOptimizer {      @Override      protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)          throws FunctionEvaluationException, OptimizationException, IllegalArgumentException { - -        while (true) { - +// buggy code +//         while (true) { +//             incrementIterationsCounter(); +//             final RealPointValuePair[] original = simplex; +//             final RealPointValuePair best = original[0]; +//             final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator); +//             if (comparator.compare(reflected, best) < 0) { +//                 final RealPointValuePair[] reflectedSimplex = simplex; +//                 final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator); +//                 if (comparator.compare(reflected, expanded) <= 0) { +//                     simplex = reflectedSimplex; +//                 } +//                 return; +//             } +//             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator); +//             if (comparator.compare(contracted, best) < 0) { +//                 return; +//             }         incrementIterationsCounter(); - -            // save the original vertex          final RealPointValuePair[] original = simplex;          final RealPointValuePair best = original[0]; - -            // perform a reflection step          final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);          if (comparator.compare(reflected, best) < 0) { - -                // compute the expanded simplex              final RealPointValuePair[] reflectedSimplex = simplex;              final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);              if (comparator.compare(reflected, expanded) <= 0) { -                    // accept the reflected simplex                  simplex = reflectedSimplex;              } -              return; -          } - -            // compute the contracted simplex          final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);          if (comparator.compare(contracted, best) < 0) { -                // accept the contracted simplex - -            // check convergence              return;          } - -        } -      }        /** Compute and evaluate a new simplex."
1,"public class NumberUtils {              throw new NumberFormatException(""A blank string is not a valid number"");          }            if (str.startsWith(""--"")) { -            // this is protection for poorness in java.lang.BigDecimal. -            // it accepts this as a legal value, but it does not appear  -            // to be in specification of class. OS X Java parses it to  -            // a wrong value.              return null;          }          if (str.startsWith(""0x"") || str.startsWith(""-0x"")) { @@ -417,9 +413,7 @@ public class NumberUtils {          String exp;          int decPos = str.indexOf('.');          int expPos = str.indexOf('e') + str.indexOf('E') + 1; -          if (decPos > -1) { -              if (expPos > -1) {                  if (expPos < decPos) {                      throw new NumberFormatException(str + "" is not a valid number.""); @@ -443,7 +437,6 @@ public class NumberUtils {              } else {                  exp = null;              } -            //Requesting a specific type..              String numeric = str.substring(0, str.length() - 1);              boolean allZeros = isAllZeros(mant) && isAllZeros(exp);              switch (lastChar) { @@ -451,15 +444,15 @@ public class NumberUtils {                  case 'L' :                      if (dec == null                          && exp == null -                        && isDigits(numeric.substring(1)) +// buggy code +//                         && isDigits(numeric.substring(1)) +//                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {                          try {                              return createLong(numeric);                          } catch (NumberFormatException nfe) { -                            //Too big for a long                          }                          return createBigInteger(numeric); -                      }                      throw new NumberFormatException(str + "" is not a valid number."");                  case 'f' : @@ -467,15 +460,10 @@ public class NumberUtils {                      try {                          Float f = NumberUtils.createFloat(numeric);                          if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { -                            //If it's too big for a float or the float value = 0 and the string -                            //has non-zeros in it, then float does not have the precision we want                              return f;                          } -                      } catch (NumberFormatException nfe) { -                        // ignore the bad number                      } -                    //Fall through                  case 'd' :                  case 'D' :                      try { @@ -484,42 +472,31 @@ public class NumberUtils {                              return d;                          }                      } catch (NumberFormatException nfe) { -                        // ignore the bad number                      }                      try {                          return createBigDecimal(numeric);                      } catch (NumberFormatException e) { -                        // ignore the bad number                      } -                    //Fall through                  default :                      throw new NumberFormatException(str + "" is not a valid number.""); -              }          } else { -            //User doesn't have a preference on the return type, so let's start -            //small and go from there...              if (expPos > -1 && expPos < str.length() - 1) {                  exp = str.substring(expPos + 1, str.length());              } else {                  exp = null;              }              if (dec == null && exp == null) { -                //Must be an int,long,bigint                  try {                      return createInteger(str);                  } catch (NumberFormatException nfe) { -                    // ignore the bad number                  }                  try {                      return createLong(str);                  } catch (NumberFormatException nfe) { -                    // ignore the bad number                  }                  return createBigInteger(str); -              } else { -                //Must be a float,double,BigDec                  boolean allZeros = isAllZeros(mant) && isAllZeros(exp);                  try {                      Float f = createFloat(str); @@ -527,7 +504,6 @@ public class NumberUtils {                          return f;                      }                  } catch (NumberFormatException nfe) { -                    // ignore the bad number                  }                  try {                      Double d = createDouble(str); @@ -535,11 +511,8 @@ public class NumberUtils {                          return d;                      }                  } catch (NumberFormatException nfe) { -                    // ignore the bad number                  } -                  return createBigDecimal(str); -              }          }      }"
1,"public final class NodeUtil {    static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {      switch (value.getType()) {        case Token.ASSIGN: -        // A result that is aliased by a non-local name, is the effectively the -        // same as returning a non-local name, but this doesn't matter if the -        // value is immutable.          return NodeUtil.isImmutableValue(value.getLastChild())              || (locals.apply(value)                  && evaluatesToLocalValue(value.getLastChild(), locals)); @@ -2452,36 +2449,28 @@ public final class NodeUtil {          return isImmutableValue(value) || locals.apply(value);        case Token.GETELEM:        case Token.GETPROP: -        // There is no information about the locality of object properties.          return locals.apply(value);        case Token.CALL:          return callHasLocalResult(value)              || isToStringMethodCall(value)              || locals.apply(value);        case Token.NEW: -        // TODO(nicksantos): This needs to be changed so that it -        // returns true iff we're sure the value was never aliased from inside -        // the constructor (similar to callHasLocalResult) -        return true; +// buggy code +//         return true; +       return evaluatesToLocalValue(value.getLastChild(), locals);        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT:        case Token.OBJECTLIT: -        // Literals objects with non-literal children are allowed.          return true;        case Token.IN: -        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?          return true;        default: -        // Other op force a local value: -        //  x = '' + g (x is now an local string) -        //  x -= g (x is now an local number)          if (isAssignmentOp(value)              || isSimpleOperator(value)              || isImmutableValue(value)) {            return true;          } -          throw new IllegalStateException(              ""Unexpected expression node"" + value +              ""\n parent:"" + value.getParent());"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +// buggy code +//         if (dataset != null) { +       if ((dataset == null) || (dataset.getRowCount() == 0)) {              return result;          }          int seriesCount = dataset.getRowCount();
1,"public class Week extends RegularTimePeriod implements Serializable {       * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.       */      public Week(Date time, TimeZone zone) { -        // defer argument checking... -        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); +// buggy code +//         this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); +       this(time, TimeZone.getDefault(), Locale.getDefault());      }        /**"
1,"public class Same extends ArgumentMatcher<Object> implements Serializable {      public void describeTo(Description description) {          description.appendText(""same("");          appendQuoting(description); -        description.appendText(wanted.toString()); +// buggy code +//         description.appendText(wanted.toString()); +       description.appendText(String.valueOf(wanted));          appendQuoting(description);          description.appendText("")"");      }"
1,"public class MultivariateNormalDistribution          if (vals.length != dim) {              throw new DimensionMismatchException(vals.length, dim);          } - -        return FastMath.pow(2 * FastMath.PI, -dim / 2) * +// buggy code +//         return FastMath.pow(2 * FastMath.PI, -dim / 2) * +       return FastMath.pow(2 * FastMath.PI, -dim / 2d) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      }"
1,"public class XYPlot extends Plot implements ValueAxisPlot, Pannable,       * @return The range.       */      public Range getDataRange(ValueAxis axis) { -          Range result = null;          List mappedDatasets = new ArrayList();          List includedAnnotations = new ArrayList();          boolean isDomainAxis = true; - -        // is it a domain axis?          int domainIndex = getDomainAxisIndex(axis);          if (domainIndex >= 0) {              isDomainAxis = true;              mappedDatasets.addAll(getDatasetsMappedToDomainAxis(                      new Integer(domainIndex)));              if (domainIndex == 0) { -                // grab the plot's annotations                  Iterator iterator = this.annotations.iterator();                  while (iterator.hasNext()) {                      XYAnnotation annotation = (XYAnnotation) iterator.next(); @@ -4446,8 +4442,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } - -        // or is it a range axis?          int rangeIndex = getRangeAxisIndex(axis);          if (rangeIndex >= 0) {              isDomainAxis = false; @@ -4463,9 +4457,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } - -        // iterate through the datasets that map to the axis and get the union -        // of the ranges.          Iterator iterator = mappedDatasets.iterator();          while (iterator.hasNext()) {              XYDataset d = (XYDataset) iterator.next(); @@ -4489,18 +4480,17 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                                  DatasetUtilities.findRangeBounds(d));                      }                  } -                 -                    Collection c = r.getAnnotations(); -                    Iterator i = c.iterator(); -                    while (i.hasNext()) { -                        XYAnnotation a = (XYAnnotation) i.next(); -                        if (a instanceof XYAnnotationBoundsInfo) { -                            includedAnnotations.add(a); +// buggy code +//                     Collection c = r.getAnnotations(); +//                     Iterator i = c.iterator(); +//                     while (i.hasNext()) { +//                         XYAnnotation a = (XYAnnotation) i.next(); +//                         if (a instanceof XYAnnotationBoundsInfo) { +//                             includedAnnotations.add(a); +//                         } +//                     }              }          } -            } -        } -          Iterator it = includedAnnotations.iterator();          while (it.hasNext()) {              XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); @@ -4513,9 +4503,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } -          return result; -      }        /**"
1,"public class TimeSeries extends Series implements Cloneable, Serializable {       */      public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)          throws CloneNotSupportedException { -          if (start == null) {              throw new IllegalArgumentException(""Null 'start' argument."");          } @@ -933,15 +932,17 @@ public class TimeSeries extends Series implements Cloneable, Serializable {          if (startIndex < 0) {              startIndex = -(startIndex + 1);              if (startIndex == this.data.size()) { -                emptyRange = true;  // start is after last data item +                emptyRange = true;                }          }          int endIndex = getIndex(end); -        if (endIndex < 0) {             // end period is not in original series -            endIndex = -(endIndex + 1); // this is first item AFTER end period -            endIndex = endIndex - 1;    // so this is last item BEFORE end -        }          if (endIndex < 0) {              +            endIndex = -(endIndex + 1);  +            endIndex = endIndex - 1;     +        } +// buggy code +//         if (endIndex < 0) { +       if (startIndex > endIndex) {              emptyRange = true;          }          if (emptyRange) { @@ -952,7 +953,6 @@ public class TimeSeries extends Series implements Cloneable, Serializable {          else {              return createCopy(startIndex, endIndex);          } -      }        /**"
1,"public class BorderArrangement implements Arrangement, Serializable {          h[3] = h[2];          if (this.rightBlock != null) {              RectangleConstraint c4 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth() - w[2]), +// buggy code +//                     new Range(0.0, constraint.getWidth() - w[2]), +                   new Range(0.0, constraint.getWidth() - w[1]),                      LengthConstraintType.RANGE, h[2], null,                      LengthConstraintType.FIXED);              Size2D size = this.rightBlock.arrange(g2, c4); @@ -464,7 +466,6 @@ public class BorderArrangement implements Arrangement, Serializable {          if (this.centerBlock != null) {              this.centerBlock.arrange(g2, c5);          } -          if (this.topBlock != null) {              this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],                      h[0]));"
1,"public class LightweightMessageFormatter extends AbstractMessageFormatter {    }      private String format(JSError error, boolean warning) { -    // extract source excerpt      SourceExcerptProvider source = getSource();      String sourceExcerpt = source == null ? null :          excerpt.get(              source, error.sourceName, error.lineNumber, excerptFormatter); - -    // formatting the message      StringBuilder b = new StringBuilder();      if (error.sourceName != null) {        b.append(error.sourceName); @@ -80,22 +77,18 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {        }        b.append("": "");      } -      b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));      b.append("" - ""); -      b.append(error.description);      b.append('\n');      if (sourceExcerpt != null) {        b.append(sourceExcerpt);        b.append('\n');        int charno = error.getCharno(); - -      // padding equal to the excerpt and arrow at the end -      // charno == sourceExpert.length() means something is missing -      // at the end of the line        if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +// buggy code +//           && 0 <= charno && charno < sourceExcerpt.length()) { +         && 0 <= charno && charno < sourceExcerpt.length() + 1) {          for (int i = 0; i < charno; i++) {            char c = sourceExcerpt.charAt(i);            if (Character.isWhitespace(c)) {"
1,"public class SimplexSolver extends AbstractLinearOptimizer {       * @return row with the minimum ratio       */      private Integer getPivotRow(SimplexTableau tableau, final int col) { -        // create a list of all the rows that tie for the lowest score in the minimum ratio test          List<Integer> minRatioPositions = new ArrayList<Integer>();          double minRatio = Double.MAX_VALUE;          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col); -              if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  final double ratio = rhs / entry; -                // check if the entry is strictly equal to the current min ratio -                // do not use a ulp/epsilon check                  final int cmp = Double.compare(ratio, minRatio);                  if (cmp == 0) {                      minRatioPositions.add(i); @@ -109,32 +105,33 @@ public class SimplexSolver extends AbstractLinearOptimizer {                  }              }          } -          if (minRatioPositions.size() == 0) {              return null;          } else if (minRatioPositions.size() > 1) { -            // there's a degeneracy as indicated by a tie in the minimum ratio test - -            // 1. check if there's an artificial variable that can be forced out of the basis -                for (Integer row : minRatioPositions) { -                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { -                        int column = i + tableau.getArtificialVariableOffset(); -                        final double entry = tableau.getEntry(row, column); -                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { -                            return row; -                        } -                    } -                } - -            // 2. apply Bland's rule to prevent cycling: -            //    take the row for which the corresponding basic variable has the smallest index -            // -            // see http://www.stanford.edu/class/msande310/blandrule.pdf -            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) -            // -            // Additional heuristic: if we did not get a solution after half of maxIterations -            //                       revert to the simple case of just returning the top-most row -            // This heuristic is based on empirical data gathered while investigating MATH-828. +// buggy code +//                 for (Integer row : minRatioPositions) { +//                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { +//                         int column = i + tableau.getArtificialVariableOffset(); +//                         final double entry = tableau.getEntry(row, column); +//                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { +//                             return row; +//                         } +//                     } +//                 } +//                 Integer minRow = null; +//                 int minIndex = tableau.getWidth(); +//                 for (Integer row : minRatioPositions) { +//                     int i = tableau.getNumObjectiveFunctions(); +//                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) { +//                         if (row == tableau.getBasicRow(i)) { +//                             if (i < minIndex) { +//                                 minIndex = i; +//                                 minRow = row; +//                             } +//                         } +//                     } +//                 } +//                 return minRow;             Integer minRow = null;              int minIndex = tableau.getWidth();              for (Integer row : minRatioPositions) { @@ -149,6 +146,7 @@ public class SimplexSolver extends AbstractLinearOptimizer {                  }              }              return minRow; +        } else {          }          return minRatioPositions.get(0);      }"
1,"public class TimeSeries extends Series implements Cloneable, Serializable {       */      public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)          throws CloneNotSupportedException { -          if (start == null) {              throw new IllegalArgumentException(""Null 'start' argument."");          } @@ -933,15 +932,17 @@ public class TimeSeries extends Series implements Cloneable, Serializable {          if (startIndex < 0) {              startIndex = -(startIndex + 1);              if (startIndex == this.data.size()) { -                emptyRange = true;  // start is after last data item +                emptyRange = true;                }          }          int endIndex = getIndex(end); -        if (endIndex < 0) {             // end period is not in original series -            endIndex = -(endIndex + 1); // this is first item AFTER end period -            endIndex = endIndex - 1;    // so this is last item BEFORE end -        }          if (endIndex < 0) {              +            endIndex = -(endIndex + 1);  +            endIndex = endIndex - 1;     +        } +// buggy code +//         if (endIndex < 0) { +       if (endIndex < startIndex) {              emptyRange = true;          }          if (emptyRange) { @@ -952,7 +953,6 @@ public class TimeSeries extends Series implements Cloneable, Serializable {          else {              return createCopy(startIndex, endIndex);          } -      }        /**"
1,public class ClassUtils {          }          Class<?>[] classes = new Class[array.length];          for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +// buggy code +//             classes[i] = array[i].getClass(); +           Object object = array[i]; +            if (object != null) { +                classes[i] = object.getClass(); +            }          }          return classes;      }
1,"public class XYPlot extends Plot implements ValueAxisPlot, Pannable,       * @return The range.       */      public Range getDataRange(ValueAxis axis) { -          Range result = null;          List mappedDatasets = new ArrayList();          List includedAnnotations = new ArrayList();          boolean isDomainAxis = true; - -        // is it a domain axis?          int domainIndex = getDomainAxisIndex(axis);          if (domainIndex >= 0) {              isDomainAxis = true;              mappedDatasets.addAll(getDatasetsMappedToDomainAxis(                      new Integer(domainIndex)));              if (domainIndex == 0) { -                // grab the plot's annotations                  Iterator iterator = this.annotations.iterator();                  while (iterator.hasNext()) {                      XYAnnotation annotation = (XYAnnotation) iterator.next(); @@ -4446,8 +4442,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } - -        // or is it a range axis?          int rangeIndex = getRangeAxisIndex(axis);          if (rangeIndex >= 0) {              isDomainAxis = false; @@ -4463,9 +4457,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } - -        // iterate through the datasets that map to the axis and get the union -        // of the ranges.          Iterator iterator = mappedDatasets.iterator();          while (iterator.hasNext()) {              XYDataset d = (XYDataset) iterator.next(); @@ -4489,8 +4480,17 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                                  DatasetUtilities.findRangeBounds(d));                      }                  } -                 -                    Collection c = r.getAnnotations(); +// buggy code +//                     Collection c = r.getAnnotations(); +//                     Iterator i = c.iterator(); +//                     while (i.hasNext()) { +//                         XYAnnotation a = (XYAnnotation) i.next(); +//                         if (a instanceof XYAnnotationBoundsInfo) { +//                             includedAnnotations.add(a); +//                         } +//                     } +               Collection c = r != null ? r.getAnnotations() : null; +                if (c != null) {                      Iterator i = c.iterator();                      while (i.hasNext()) {                          XYAnnotation a = (XYAnnotation) i.next(); @@ -4500,7 +4500,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                      }                  }              } - +        }          Iterator it = includedAnnotations.iterator();          while (it.hasNext()) {              XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); @@ -4513,9 +4513,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } -          return result; -      }        /**"
1,"public class TimePeriodValues extends Series implements Serializable {       * @param index  the index of the time period.       */      private void updateBounds(TimePeriod period, int index) { -                  long start = period.getStart().getTime();          long end = period.getEnd().getTime();          long middle = start + ((end - start) / 2); -          if (this.minStartIndex >= 0) {              long minStart = getDataItem(this.minStartIndex).getPeriod()                  .getStart().getTime(); @@ -270,7 +268,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minStartIndex = index;          } -                  if (this.maxStartIndex >= 0) {              long maxStart = getDataItem(this.maxStartIndex).getPeriod()                  .getStart().getTime(); @@ -281,7 +278,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxStartIndex = index;          } -                  if (this.minMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); @@ -295,9 +291,12 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minMiddleIndex = index;          } -                  if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +// buggy code +//             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +//                 .getTime(); +//             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +           long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()                  .getTime();              long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()                  .getTime(); @@ -309,7 +308,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxMiddleIndex = index;          } -                  if (this.minEndIndex >= 0) {              long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()                  .getTime(); @@ -320,7 +318,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minEndIndex = index;          } -                 if (this.maxEndIndex >= 0) {              long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()                  .getTime(); @@ -331,7 +328,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxEndIndex = index;          } -              }            /**"
1,"public class MultiplePiePlot extends Plot implements Cloneable, Serializable {       */      public MultiplePiePlot(CategoryDataset dataset) {          super(); -        this.dataset = dataset; +// buggy code +//         this.dataset = dataset; +       this.setDataset(dataset);          PiePlot piePlot = new PiePlot(null);          this.pieChart = new JFreeChart(piePlot);          this.pieChart.removeLegend();"
1,"class CodeGenerator {          case '\\': sb.append(backslashEscape); break;          case '\""': sb.append(doublequoteEscape); break;          case '\'': sb.append(singlequoteEscape); break; -        case '>':                       // Break --> into --\> or ]]> into ]]\> +        case '>':                                   if (i >= 2 &&                ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||                 (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { @@ -1012,12 +1012,8 @@ class CodeGenerator {            }            break;          case '<': -          // Break </script into <\/script            final String END_SCRIPT = ""/script""; - -          // Break <!-- into <\!--            final String START_COMMENT = ""!--""; -            if (s.regionMatches(true, i + 1, END_SCRIPT, 0,                                END_SCRIPT.length())) {              sb.append(""<\\""); @@ -1029,25 +1025,18 @@ class CodeGenerator {            }            break;          default: -          // If we're given an outputCharsetEncoder, then check if the -          //  character can be represented in this character set.            if (outputCharsetEncoder != null) {              if (outputCharsetEncoder.canEncode(c)) {                sb.append(c);              } else { -              // Unicode-escape the character.                appendHexJavaScriptRepresentation(sb, c);              }            } else { -            // No charsetEncoder provided - pass straight latin characters -            // through, and escape the rest.  Doing the explicit character -            // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +// buggy code +//             if (c > 0x1f && c <= 0x7f) { +           if (c > 0x1f && c <= 0x7e) {                sb.append(c);              } else { -              // Other characters can be misinterpreted by some js parsers, -              // or perhaps mangled by proxies along the way, -              // so we play it safe and unicode escape them.                appendHexJavaScriptRepresentation(sb, c);              }            }"
1,public class ExtendedMessageFormat extends MessageFormat {          int start = pos.getIndex();          char[] c = pattern.toCharArray();          if (escapingOn && c[start] == QUOTE) { +// buggy code +//  +           pos.setIndex(start+1);              return appendTo == null ? null : appendTo.append(QUOTE);          }          int lastHold = start;
1,public class ClassUtils {          }          Class<?>[] classes = new Class[array.length];          for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +// buggy code +//             classes[i] = array[i].getClass(); +           Object object = array[i]; +            classes[i] = object == null ? null : object.getClass();          }          return classes;      }
1,"public class FastMath {       * @return b if a is lesser or equal to b, a otherwise       */      public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +// buggy code +//         return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +       return (a >= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);      }        /** Compute the maximum of two values"
1,"public class MultivariateNormalDistribution          if (vals.length != dim) {              throw new DimensionMismatchException(vals.length, dim);          } - -        return FastMath.pow(2 * FastMath.PI, -dim / 2) * +// buggy code +//         return FastMath.pow(2 * FastMath.PI, -dim / 2) * +       return FastMath.pow(2.0 * FastMath.PI, -dim / 2.0) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      }"
1,"public class UnivariateRealSolverUtils {              double initial, double lowerBound, double upperBound,               int maximumIterations) throws ConvergenceException,               FunctionEvaluationException { -                  if (function == null) {              throw MathRuntimeException.createIllegalArgumentException(""function is null"");          } @@ -184,18 +183,17 @@ public class UnivariateRealSolverUtils {          double fa;          double fb;          int numIterations = 0 ; -              do {              a = Math.max(a - 1.0, lowerBound);              b = Math.min(b + 1.0, upperBound);              fa = function.value(a); -                          fb = function.value(b);              numIterations++ ;          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound))); -    -        if (fa * fb >= 0.0 ) { +// buggy code +//         if (fa * fb >= 0.0 ) { +       if (numIterations >= maximumIterations) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + @@ -203,7 +201,6 @@ public class UnivariateRealSolverUtils {                        numIterations, maximumIterations, initial,                        lowerBound, upperBound, a, b, fa, fb);          } -                  return new double[]{a, b};      }"
1,public abstract class ListPopulation implements Population {       * @return chromosome iterator       */      public Iterator<Chromosome> iterator() { -        return chromosomes.iterator(); +// buggy code +//         return chromosomes.iterator(); +       return new Iterator<Chromosome>() { +            int index = 0; +            @Override +            public boolean hasNext() { +                return index < chromosomes.size(); +            } + +            @Override +            public Chromosome next() { +                return chromosomes.get(index++); +            } +        };      }  }
1,"public class DateTimeFormatter {          if (instant == null) {              throw new IllegalArgumentException(""Instant must not be null"");          } -                  long instantMillis = instant.getMillis();          Chronology chrono = instant.getChronology(); +// buggy code +//         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); +//         chrono = selectChronology(chrono); +//         int defaultYear = chrono.year().get(instantLocal); +       int defaultYear = chrono.year().get(instantMillis);          long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);          chrono = selectChronology(chrono); -        int defaultYear = chrono.year().get(instantLocal); -                  DateTimeParserBucket bucket = new DateTimeParserBucket(              instantLocal, chrono, iLocale, iPivotYear, defaultYear);          int newPos = parser.parseInto(bucket, text, position);"
1,"public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {      /** {@inheritDoc} */      @Override      protected void computeGeometricalProperties() { -          final Vector2D[][] v = getVertices(); -          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { -                // the instance covers the whole space +// buggy code +//             if ((Boolean) tree.getAttribute()) { +           if (tree != null && Boolean.TRUE.equals(tree.getAttribute())) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN);              } else { @@ -142,16 +141,12 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {                  setBarycenter(new Vector2D(0, 0));              }          } else if (v[0][0] == null) { -            // there is at least one open-loop: the polygon is infinite              setSize(Double.POSITIVE_INFINITY);              setBarycenter(Vector2D.NaN);          } else { -            // all loops are closed, we compute some integrals around the shape -              double sum  = 0;              double sumX = 0;              double sumY = 0; -              for (Vector2D[] loop : v) {                  double x1 = loop[loop.length - 1].getX();                  double y1 = loop[loop.length - 1].getY(); @@ -166,18 +161,14 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {                      sumY += factor * (y0 + y1);                  }              } -              if (sum < 0) { -                // the polygon as a finite outside surrounded by an infinite inside                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN);              } else {                  setSize(sum / 2);                  setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));              } -          } -      }        /** Get the vertices of the polygon."
1,"public final class NodeUtil {    static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {      switch (value.getType()) {        case Token.ASSIGN: -        // A result that is aliased by a non-local name, is the effectively the -        // same as returning a non-local name, but this doesn't matter if the -        // value is immutable.          return NodeUtil.isImmutableValue(value.getLastChild())              || (locals.apply(value)                  && evaluatesToLocalValue(value.getLastChild(), locals)); @@ -2452,36 +2449,28 @@ public final class NodeUtil {          return isImmutableValue(value) || locals.apply(value);        case Token.GETELEM:        case Token.GETPROP: -        // There is no information about the locality of object properties.          return locals.apply(value);        case Token.CALL:          return callHasLocalResult(value)              || isToStringMethodCall(value)              || locals.apply(value);        case Token.NEW: -        // TODO(nicksantos): This needs to be changed so that it -        // returns true iff we're sure the value was never aliased from inside -        // the constructor (similar to callHasLocalResult) -        return true; +// buggy code +//         return true; +       return isImmutableValue(value);        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT:        case Token.OBJECTLIT: -        // Literals objects with non-literal children are allowed.          return true;        case Token.IN: -        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?          return true;        default: -        // Other op force a local value: -        //  x = '' + g (x is now an local string) -        //  x -= g (x is now an local number)          if (isAssignmentOp(value)              || isSimpleOperator(value)              || isImmutableValue(value)) {            return true;          } -          throw new IllegalStateException(              ""Unexpected expression node"" + value +              ""\n parent:"" + value.getParent());"
1,"public class StrBuilder implements Cloneable {              String str = (obj == null ? getNullText() : obj.toString());              int strLen = str.length();              if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +// buggy code +//                 str.getChars(0, strLen, buffer, size); +               str.getChars(0, Math.min(strLen, width), buffer, size);              } else {                  int padLen = width - strLen;                  str.getChars(0, strLen, buffer, size);"
1,"public final class NodeUtil {    static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {      switch (value.getType()) {        case Token.ASSIGN: -        // A result that is aliased by a non-local name, is the effectively the -        // same as returning a non-local name, but this doesn't matter if the -        // value is immutable.          return NodeUtil.isImmutableValue(value.getLastChild())              || (locals.apply(value)                  && evaluatesToLocalValue(value.getLastChild(), locals)); @@ -2452,36 +2449,28 @@ public final class NodeUtil {          return isImmutableValue(value) || locals.apply(value);        case Token.GETELEM:        case Token.GETPROP: -        // There is no information about the locality of object properties.          return locals.apply(value);        case Token.CALL:          return callHasLocalResult(value)              || isToStringMethodCall(value)              || locals.apply(value);        case Token.NEW: -        // TODO(nicksantos): This needs to be changed so that it -        // returns true iff we're sure the value was never aliased from inside -        // the constructor (similar to callHasLocalResult) -        return true; +// buggy code +//         return true; +       return evaluatesToLocalValue(value.getFirstChild(), locals);        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT:        case Token.OBJECTLIT: -        // Literals objects with non-literal children are allowed.          return true;        case Token.IN: -        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?          return true;        default: -        // Other op force a local value: -        //  x = '' + g (x is now an local string) -        //  x -= g (x is now an local number)          if (isAssignmentOp(value)              || isSimpleOperator(value)              || isImmutableValue(value)) {            return true;          } -          throw new IllegalStateException(              ""Unexpected expression node"" + value +              ""\n parent:"" + value.getParent());"
1,public class ClassUtils {          }          Class<?>[] classes = new Class[array.length];          for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +// buggy code +//             classes[i] = array[i].getClass(); +           Object value = array[i]; +            if (value != null) { +                classes[i] = value.getClass(); +            }          }          return classes;      }
1,"class CodeGenerator {          case '\\': sb.append(backslashEscape); break;          case '\""': sb.append(doublequoteEscape); break;          case '\'': sb.append(singlequoteEscape); break; -        case '>':                       // Break --> into --\> or ]]> into ]]\> +        case '>':                                   if (i >= 2 &&                ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||                 (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { @@ -1012,12 +1012,8 @@ class CodeGenerator {            }            break;          case '<': -          // Break </script into <\/script            final String END_SCRIPT = ""/script""; - -          // Break <!-- into <\!--            final String START_COMMENT = ""!--""; -            if (s.regionMatches(true, i + 1, END_SCRIPT, 0,                                END_SCRIPT.length())) {              sb.append(""<\\""); @@ -1029,25 +1025,18 @@ class CodeGenerator {            }            break;          default: -          // If we're given an outputCharsetEncoder, then check if the -          //  character can be represented in this character set.            if (outputCharsetEncoder != null) {              if (outputCharsetEncoder.canEncode(c)) {                sb.append(c);              } else { -              // Unicode-escape the character.                appendHexJavaScriptRepresentation(sb, c);              }            } else { -            // No charsetEncoder provided - pass straight latin characters -            // through, and escape the rest.  Doing the explicit character -            // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +// buggy code +//             if (c > 0x1f && c <= 0x7f) { +           if (c >= 0x20 && c <= 0x7e) {                sb.append(c);              } else { -              // Other characters can be misinterpreted by some js parsers, -              // or perhaps mangled by proxies along the way, -              // so we play it safe and unicode escape them.                appendHexJavaScriptRepresentation(sb, c);              }            }"
1,"public class WordUtils {       * @since 2.4       */      public static String abbreviate(String str, int lower, int upper, String appendToEnd) { -        // initial parameter checks          if (str == null) {              return null;          }          if (str.length() == 0) {              return StringUtils.EMPTY; +// buggy code +//  +       } +        if (lower == -1 || lower > str.length()) { +            lower = str.length();          } - -        // if the lower value is greater than the length of the string, -        // set to the length of the string -        // if the upper value is -1 (i.e. no limit) or is greater -        // than the length of the string, set to the length of the string          if (upper == -1 || upper > str.length()) {              upper = str.length();          } -        // if upper is less than lower, raise it to lower          if (upper < lower) {              upper = lower;          } -          StringBuffer result = new StringBuffer();          int index = StringUtils.indexOf(str, "" "", lower);          if (index == -1) {              result.append(str.substring(0, upper)); -            // only if abbreviation has occured do we append the appendToEnd value              if (upper != str.length()) {                  result.append(StringUtils.defaultString(appendToEnd));              }"
1,"public class MannWhitneyUTest {                                               final int n1,                                               final int n2)          throws ConvergenceException, MaxCountExceededException { - -        final int n1n2prod = n1 * n2; - -        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation +// buggy code +//         final int n1n2prod = n1 * n2; +       final long n1n2prod = (long) n1 * n2;          final double EU = n1n2prod / 2.0;          final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; -          final double z = (Umin - EU) / FastMath.sqrt(VarU); -          final NormalDistribution standardNormal = new NormalDistribution(0, 1); -          return 2 * standardNormal.cumulativeProbability(z);      }"
1,public class ClassUtils {          }          Class<?>[] classes = new Class[array.length];          for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +// buggy code +//             classes[i] = array[i].getClass(); +           classes[i] = array[i] != null ? array[i].getClass() : null;          }          return classes;      }
1,"public class MultivariateNormalDistribution          if (vals.length != dim) {              throw new DimensionMismatchException(vals.length, dim);          } - -        return FastMath.pow(2 * FastMath.PI, -dim / 2) * +// buggy code +//         return FastMath.pow(2 * FastMath.PI, -dim / 2) * +       return FastMath.pow(2 * FastMath.PI, -dim / 2.0) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      }"
1,"public class UnivariateRealSolverUtils {              double initial, double lowerBound, double upperBound,               int maximumIterations) throws ConvergenceException,               FunctionEvaluationException { -                  if (function == null) {              throw MathRuntimeException.createIllegalArgumentException(""function is null"");          } @@ -184,18 +183,17 @@ public class UnivariateRealSolverUtils {          double fa;          double fb;          int numIterations = 0 ; -              do {              a = Math.max(a - 1.0, lowerBound);              b = Math.min(b + 1.0, upperBound);              fa = function.value(a); -                          fb = function.value(b);              numIterations++ ;          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound))); -    -        if (fa * fb >= 0.0 ) { +// buggy code +//         if (fa * fb >= 0.0 ) { +       if ((fa * fb >= 0.0) && (numIterations >= maximumIterations)) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + @@ -203,7 +201,6 @@ public class UnivariateRealSolverUtils {                        numIterations, maximumIterations, initial,                        lowerBound, upperBound, a, b, fa, fb);          } -                  return new double[]{a, b};      }"
1,"public class ComplexFormat extends Format implements Serializable {       */      public Complex parse(String source, ParsePosition pos) {          int initialIndex = pos.getIndex(); - -        // parse whitespace          parseAndIgnoreWhitespace(source, pos); - -        // parse real          Number re = parseNumber(source, getRealFormat(), pos);          if (re == null) { -            // invalid real number -            // set index back to initial, error index should already be set -            // character examined.              pos.setIndex(initialIndex);              return null;          } - -        // parse sign          int startIndex = pos.getIndex();          char c = parseNextCharacter(source, pos);          int sign = 0;          switch (c) {          case 0 : -            // no sign -            // return real only complex number              return new Complex(re.doubleValue(), 0.0);          case '-' :              sign = -1; @@ -349,42 +338,29 @@ public class ComplexFormat extends Format implements Serializable {              sign = 1;              break;          default : -            // invalid sign -            // set index back to initial, error index should be the last -            // character examined.              pos.setIndex(initialIndex);              pos.setErrorIndex(startIndex);              return null;          } - -        // parse whitespace          parseAndIgnoreWhitespace(source, pos); - -        // parse imaginary          Number im = parseNumber(source, getRealFormat(), pos);          if (im == null) { -            // invalid imaginary number -            // set index back to initial, error index should already be set -            // character examined.              pos.setIndex(initialIndex);              return null;          } - -        // parse imaginary character          int n = getImaginaryCharacter().length();          startIndex = pos.getIndex();          int endIndex = startIndex + n; -        if ( +// buggy code +//         if ( +       if (endIndex > source.length() ||               source.substring(startIndex, endIndex).compareTo(              getImaginaryCharacter()) != 0) { -            // set index back to initial, error index should be the start index -            // character examined.              pos.setIndex(initialIndex);              pos.setErrorIndex(startIndex);              return null;          }          pos.setIndex(endIndex); -          return new Complex(re.doubleValue(), im.doubleValue() * sign);      }"
1,"public class FastMath {       * @return b if a is lesser or equal to b, a otherwise       */      public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +// buggy code +//         return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +       return (b >= a) ? b : (Float.isNaN(a + b) ? Float.NaN : a);      }        /** Compute the maximum of two values"
1,"public class ComplexFormat extends Format implements Serializable {       */      public Complex parse(String source, ParsePosition pos) {          int initialIndex = pos.getIndex(); - -        // parse whitespace          parseAndIgnoreWhitespace(source, pos); - -        // parse real          Number re = parseNumber(source, getRealFormat(), pos);          if (re == null) { -            // invalid real number -            // set index back to initial, error index should already be set -            // character examined.              pos.setIndex(initialIndex);              return null;          } - -        // parse sign          int startIndex = pos.getIndex();          char c = parseNextCharacter(source, pos);          int sign = 0;          switch (c) {          case 0 : -            // no sign -            // return real only complex number              return new Complex(re.doubleValue(), 0.0);          case '-' :              sign = -1; @@ -349,42 +338,29 @@ public class ComplexFormat extends Format implements Serializable {              sign = 1;              break;          default : -            // invalid sign -            // set index back to initial, error index should be the last -            // character examined.              pos.setIndex(initialIndex);              pos.setErrorIndex(startIndex);              return null;          } - -        // parse whitespace          parseAndIgnoreWhitespace(source, pos); - -        // parse imaginary          Number im = parseNumber(source, getRealFormat(), pos);          if (im == null) { -            // invalid imaginary number -            // set index back to initial, error index should already be set -            // character examined.              pos.setIndex(initialIndex);              return null;          } - -        // parse imaginary character          int n = getImaginaryCharacter().length();          startIndex = pos.getIndex();          int endIndex = startIndex + n; -        if ( +// buggy code +//         if ( +       if (source.length() < endIndex ||              source.substring(startIndex, endIndex).compareTo(              getImaginaryCharacter()) != 0) { -            // set index back to initial, error index should be the start index -            // character examined.              pos.setIndex(initialIndex);              pos.setErrorIndex(startIndex);              return null;          }          pos.setIndex(endIndex); -          return new Complex(re.doubleValue(), im.doubleValue() * sign);      }"
1,"public class BooleanUtils {       * @return the boolean value of the string, <code>false</code> if no match       */      public static boolean toBoolean(String str) { -        // Previously used equalsIgnoreCase, which was fast for interned 'true'. -        // Non interned 'true' matched 15 times slower. -        //  -        // Optimisation provides same performance as before for interned 'true'. -        // Similar performance for null, 'false', and other strings not length 2/3/4. -        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.          if (str == ""true"") {              return true;          } @@ -679,6 +673,9 @@ public class BooleanUtils {                          (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&                          (str.charAt(2) == 'S' || str.charAt(2) == 's');                  } +// buggy code +//  +               return ch == 'n' || ch == 'N';              }              case 4: {                  char ch = str.charAt(0);"
1,"public class BooleanUtils {       * @return the boolean value of the string, <code>false</code> if no match       */      public static boolean toBoolean(String str) { -        // Previously used equalsIgnoreCase, which was fast for interned 'true'. -        // Non interned 'true' matched 15 times slower. -        //  -        // Optimisation provides same performance as before for interned 'true'. -        // Similar performance for null, 'false', and other strings not length 2/3/4. -        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.          if (str == ""true"") {              return true;          } @@ -679,6 +673,9 @@ public class BooleanUtils {                          (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&                          (str.charAt(2) == 'S' || str.charAt(2) == 's');                  } +// buggy code +//  +               break;               }              case 4: {                  char ch = str.charAt(0);"
1,public class ClassUtils {          }          Class<?>[] classes = new Class[array.length];          for (int i = 0; i < array.length; i++) { +// buggy code +//             classes[i] = array[i].getClass(); +           if (array[i] != null) {                  classes[i] = array[i].getClass();              }  +        }          return classes;      }
1,"public abstract class BaseSecantSolver        /** {@inheritDoc} */      protected final double doSolve() { -        // Get initial solution          double x0 = getMin();          double x1 = getMax();          double f0 = computeObjectiveValue(x0);          double f1 = computeObjectiveValue(x1); - -        // If one of the bounds is the exact root, return it. Since these are -        // not under-approximations or over-approximations, we can return them -        // regardless of the allowed solutions.          if (f0 == 0.0) {              return x0;          }          if (f1 == 0.0) {              return x1;          } - -        // Verify bracketing of initial solution.          verifyBracketing(x0, x1); - -        // Get accuracies.          final double ftol = getFunctionValueAccuracy();          final double atol = getAbsoluteAccuracy();          final double rtol = getRelativeAccuracy(); - -        // Keep track of inverted intervals, meaning that the left bound is -        // larger than the right bound.          boolean inverted = false; - -        // Keep finding better approximations.          while (true) { -            // Calculate the next approximation.              final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));              final double fx = computeObjectiveValue(x); - -            // If the new approximation is the exact root, return it. Since -            // this is not an under-approximation or an over-approximation, -            // we can return it regardless of the allowed solutions.              if (fx == 0.0) {                  return x;              } - -            // Update the bounds with the new approximation.              if (f1 * fx < 0) { -                // The value of x1 has switched to the other bound, thus inverting -                // the interval.                  x0 = x1;                  f0 = f1;                  inverted = !inverted; @@ -183,24 +160,22 @@ public abstract class BaseSecantSolver                      f0 *= f1 / (f1 + fx);                      break;                  case REGULA_FALSI: -                    // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); +// buggy code +//                     if (x == x1) { +//                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +//                         f0 = computeObjectiveValue(x0); +//                     } +                   if (x == x0) { +                        x1 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x0), atol)); +                        f1 = computeObjectiveValue(x1);                      }                      break;                  default: -                    // Should never happen.                      throw new MathInternalError();                  }              } -            // Update from [x0, x1] to [x0, x].              x1 = x;              f1 = fx; - -            // If the function value of the last approximation is too small, -            // given the function value accuracy, then we can't get closer to -            // the root than we already are.              if (FastMath.abs(f1) <= ftol) {                  switch (allowed) {                  case ANY_SIDE: @@ -229,9 +204,6 @@ public abstract class BaseSecantSolver                      throw new MathInternalError();                  }              } - -            // If the current interval is within the given accuracies, we -            // are satisfied with the current approximation.              if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),                                                       atol)) {                  switch (allowed) {"
1,public class ExtendedMessageFormat extends MessageFormat {          int start = pos.getIndex();          char[] c = pattern.toCharArray();          if (escapingOn && c[start] == QUOTE) { +// buggy code +//  +           pos.setIndex(pos.getIndex() + 1);              return appendTo == null ? null : appendTo.append(QUOTE);          }          int lastHold = start;
1,public abstract class ListPopulation implements Population {       * @return chromosome iterator       */      public Iterator<Chromosome> iterator() { -        return chromosomes.iterator(); +// buggy code +//         return chromosomes.iterator(); +       return Collections.unmodifiableCollection(chromosomes).iterator();      }  }
1,"public class Complex implements FieldElement<Complex>, Serializable  {      public Complex add(Complex rhs)          throws NullArgumentException {          MathUtils.checkNotNull(rhs); +// buggy code +//  +       if (rhs.isNaN()) { +            return NaN; +        }          return createComplex(real + rhs.getReal(),              imaginary + rhs.getImaginary());      }"
1,"public final class MathUtils {       * @return the L<sub>2</sub> distance between the two points       */      public static double distance(int[] p1, int[] p2) { -      int sum = 0; +// buggy code +//       int sum = 0; +//       for (int i = 0; i < p1.length; i++) { +//           final int dp = p1[i] - p2[i]; +     long sum = 0;        for (int i = 0; i < p1.length; i++) { -          final int dp = p1[i] - p2[i]; +          final long dp = p1[i] - p2[i];            sum += dp * dp;        }        return Math.sqrt(sum);"
1,"public class StrBuilder implements Cloneable {              String str = (obj == null ? getNullText() : obj.toString());              int strLen = str.length();              if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +// buggy code +//                 str.getChars(0, strLen, buffer, size); +               System.arraycopy(str.toCharArray(), 0, buffer, size, width);              } else {                  int padLen = width - strLen;                  str.getChars(0, strLen, buffer, size);"
1,"public class TimePeriodValues extends Series implements Serializable {       * @param index  the index of the time period.       */      private void updateBounds(TimePeriod period, int index) { -                  long start = period.getStart().getTime();          long end = period.getEnd().getTime();          long middle = start + ((end - start) / 2); -          if (this.minStartIndex >= 0) {              long minStart = getDataItem(this.minStartIndex).getPeriod()                  .getStart().getTime(); @@ -270,7 +268,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minStartIndex = index;          } -                  if (this.maxStartIndex >= 0) {              long maxStart = getDataItem(this.maxStartIndex).getPeriod()                  .getStart().getTime(); @@ -281,7 +278,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxStartIndex = index;          } -                  if (this.minMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); @@ -295,11 +291,14 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minMiddleIndex = index;          } -                  if (this.maxMiddleIndex >= 0) { +// buggy code +//             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +//                 .getTime(); +//             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) { @@ -309,7 +308,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxMiddleIndex = index;          } -                  if (this.minEndIndex >= 0) {              long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()                  .getTime(); @@ -320,7 +318,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minEndIndex = index;          } -                 if (this.maxEndIndex >= 0) {              long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()                  .getTime(); @@ -331,7 +328,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxEndIndex = index;          } -              }            /**"
1,"public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {       */      private static <T extends Clusterable<T>> List<Cluster<T>>          chooseInitialCenters(final Collection<T> points, final int k, final Random random) { -          final List<T> pointSet = new ArrayList<T>(points);          final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); - -        // Choose one center uniformly at random from among the data points.          final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));          resultSet.add(new Cluster<T>(firstPoint)); -          final double[] dx2 = new double[pointSet.size()];          while (resultSet.size() < k) { -            // For each data point x, compute D(x), the distance between x and -            // the nearest center that has already been chosen. -            int sum = 0; +// buggy code +//             int sum = 0; +           double sum = 0d;              for (int i = 0; i < pointSet.size(); i++) {                  final T p = pointSet.get(i);                  final Cluster<T> nearest = getNearestCluster(resultSet, p); @@ -180,9 +176,6 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {                  sum += d * d;                  dx2[i] = sum;              } - -            // Add one new data point as a center. Each point x is chosen with -            // probability proportional to D(x)2              final double r = random.nextDouble() * sum;              for (int i = 0 ; i < dx2.length; i++) {                  if (dx2[i] >= r) { @@ -192,9 +185,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {                  }              }          } -          return resultSet; -      }        /**"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +// buggy code +//         if (dataset != null) { +       if (index < 0 || dataset == null) {              return result;          }          int seriesCount = dataset.getRowCount();
1,"public class SimplexSolver extends AbstractLinearOptimizer {       * @return row with the minimum ratio       */      private Integer getPivotRow(SimplexTableau tableau, final int col) { -        // create a list of all the rows that tie for the lowest score in the minimum ratio test          List<Integer> minRatioPositions = new ArrayList<Integer>();          double minRatio = Double.MAX_VALUE;          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col); -              if (Precision.compareTo(entry, 0d, maxUlps) > 0) {                  final double ratio = rhs / entry; -                // check if the entry is strictly equal to the current min ratio -                // do not use a ulp/epsilon check                  final int cmp = Double.compare(ratio, minRatio);                  if (cmp == 0) {                      minRatioPositions.add(i); @@ -109,32 +105,33 @@ public class SimplexSolver extends AbstractLinearOptimizer {                  }              }          } -          if (minRatioPositions.size() == 0) {              return null;          } else if (minRatioPositions.size() > 1) { -            // there's a degeneracy as indicated by a tie in the minimum ratio test - -            // 1. check if there's an artificial variable that can be forced out of the basis -                for (Integer row : minRatioPositions) { -                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { -                        int column = i + tableau.getArtificialVariableOffset(); -                        final double entry = tableau.getEntry(row, column); -                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { -                            return row; -                        } -                    } -                } - -            // 2. apply Bland's rule to prevent cycling: -            //    take the row for which the corresponding basic variable has the smallest index -            // -            // see http://www.stanford.edu/class/msande310/blandrule.pdf -            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper) -            // -            // Additional heuristic: if we did not get a solution after half of maxIterations -            //                       revert to the simple case of just returning the top-most row -            // This heuristic is based on empirical data gathered while investigating MATH-828. +// buggy code +//                 for (Integer row : minRatioPositions) { +//                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) { +//                         int column = i + tableau.getArtificialVariableOffset(); +//                         final double entry = tableau.getEntry(row, column); +//                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) { +//                             return row; +//                         } +//                     } +//                 } +//                 Integer minRow = null; +//                 int minIndex = tableau.getWidth(); +//                 for (Integer row : minRatioPositions) { +//                     int i = tableau.getNumObjectiveFunctions(); +//                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) { +//                         if (row == tableau.getBasicRow(i)) { +//                             if (i < minIndex) { +//                                 minIndex = i; +//                                 minRow = row; +//                             } +//                         } +//                     } +//                 } +//                 return minRow;             Integer minRow = null;              int minIndex = tableau.getWidth();              for (Integer row : minRatioPositions) {"
1,"public final class NodeUtil {      static boolean mayBeString(Node n, boolean recurse) {      if (recurse) { -      return allResultsMatch(n, MAY_BE_STRING_PREDICATE); +// buggy code +//       return allResultsMatch(n, MAY_BE_STRING_PREDICATE); +     return mayBeStringHelper(n);      } else {        return mayBeStringHelper(n);      }"
1,"public class BorderArrangement implements Arrangement, Serializable {          h[3] = h[2];          if (this.rightBlock != null) {              RectangleConstraint c4 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth() - w[2]), +// buggy code +//                     new Range(0.0, constraint.getWidth() - w[2]), +                   new Range(0.0, constraint.getWidth() - w[3]),                      LengthConstraintType.RANGE, h[2], null,                      LengthConstraintType.FIXED);              Size2D size = this.rightBlock.arrange(g2, c4); @@ -464,7 +466,6 @@ public class BorderArrangement implements Arrangement, Serializable {          if (this.centerBlock != null) {              this.centerBlock.arrange(g2, c5);          } -          if (this.topBlock != null) {              this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],                      h[0]));"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +// buggy code +//         if (dataset != null) { +       if ((dataset == null) || (dataset.getRowCount() <= 0)) {              return result;          }          int seriesCount = dataset.getRowCount();
1,public class FDistributionImpl       * @return initial domain value       */      protected double getInitialDomain(double p) { -        double ret; +// buggy code +//         double ret; +//         double d = getDenominatorDegreesOfFreedom(); +//             ret = d / (d - 2.0); +       double ret = 0.0;          double d = getDenominatorDegreesOfFreedom(); -            // use mean +        if (d > 2.0) {              ret = d / (d - 2.0); +        }          return ret;      }
1,"public class BorderArrangement implements Arrangement, Serializable {          h[3] = h[2];          if (this.rightBlock != null) {              RectangleConstraint c4 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth() - w[2]), +// buggy code +//                     new Range(0.0, constraint.getWidth() - w[2]), +                   new Range(0.0, constraint.getWidth()),                      LengthConstraintType.RANGE, h[2], null,                      LengthConstraintType.FIXED);              Size2D size = this.rightBlock.arrange(g2, c4); @@ -464,7 +466,6 @@ public class BorderArrangement implements Arrangement, Serializable {          if (this.centerBlock != null) {              this.centerBlock.arrange(g2, c5);          } -          if (this.topBlock != null) {              this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],                      h[0]));"
1,"public class UnivariateRealSolverUtils {              double initial, double lowerBound, double upperBound,               int maximumIterations) throws ConvergenceException,               FunctionEvaluationException { -                  if (function == null) {              throw MathRuntimeException.createIllegalArgumentException(""function is null"");          } @@ -184,18 +183,17 @@ public class UnivariateRealSolverUtils {          double fa;          double fb;          int numIterations = 0 ; -              do {              a = Math.max(a - 1.0, lowerBound);              b = Math.min(b + 1.0, upperBound);              fa = function.value(a); -                          fb = function.value(b);              numIterations++ ;          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound))); -    -        if (fa * fb >= 0.0 ) { +// buggy code +//         if (fa * fb >= 0.0 ) { +       if ((fa * fb >= 0.0) && (numIterations == maximumIterations)) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + @@ -203,7 +201,6 @@ public class UnivariateRealSolverUtils {                        numIterations, maximumIterations, initial,                        lowerBound, upperBound, a, b, fa, fb);          } -                  return new double[]{a, b};      }"
1,"public class FastMath {       * @return b if a is lesser or equal to b, a otherwise       */      public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +// buggy code +//         return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +       return (b <= a) ? a : (Float.isNaN(a + b) ? Float.NaN : b);      }        /** Compute the maximum of two values"
1,"public final class MathUtils {       * @return the L<sub>2</sub> distance between the two points       */      public static double distance(int[] p1, int[] p2) { -      int sum = 0; +// buggy code +//       int sum = 0; +//       for (int i = 0; i < p1.length; i++) { +//           final int dp = p1[i] - p2[i]; +     double sum = 0;        for (int i = 0; i < p1.length; i++) { -          final int dp = p1[i] - p2[i]; +          final double dp = (double) (p1[i] - p2[i]);            sum += dp * dp;        }        return Math.sqrt(sum);"
1,public class FDistributionImpl       * @return initial domain value       */      protected double getInitialDomain(double p) { -        double ret; +// buggy code +//         double ret; +//         double d = getDenominatorDegreesOfFreedom(); +//             ret = d / (d - 2.0); +       double ret = 1.0;          double d = getDenominatorDegreesOfFreedom(); -            // use mean +        if (d > 2) {              ret = d / (d - 2.0); +        }          return ret;      }
1,public class ClassUtils {          }          Class<?>[] classes = new Class[array.length];          for (int i = 0; i < array.length; i++) { +// buggy code +//             classes[i] = array[i].getClass(); +           if (array[i] != null) {                  classes[i] = array[i].getClass();              } +        }          return classes;      }
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +// buggy code +//         if (dataset != null) { +       if (dataset == null || !isSeriesVisibleInLegend(index)) {              return result;          }          int seriesCount = dataset.getRowCount();
1,"public class ComplexFormat extends Format implements Serializable {       */      public Complex parse(String source, ParsePosition pos) {          int initialIndex = pos.getIndex(); - -        // parse whitespace          parseAndIgnoreWhitespace(source, pos); - -        // parse real          Number re = parseNumber(source, getRealFormat(), pos);          if (re == null) { -            // invalid real number -            // set index back to initial, error index should already be set -            // character examined.              pos.setIndex(initialIndex);              return null;          } - -        // parse sign          int startIndex = pos.getIndex();          char c = parseNextCharacter(source, pos);          int sign = 0;          switch (c) {          case 0 : -            // no sign -            // return real only complex number              return new Complex(re.doubleValue(), 0.0);          case '-' :              sign = -1; @@ -349,42 +338,29 @@ public class ComplexFormat extends Format implements Serializable {              sign = 1;              break;          default : -            // invalid sign -            // set index back to initial, error index should be the last -            // character examined.              pos.setIndex(initialIndex);              pos.setErrorIndex(startIndex);              return null;          } - -        // parse whitespace          parseAndIgnoreWhitespace(source, pos); - -        // parse imaginary          Number im = parseNumber(source, getRealFormat(), pos);          if (im == null) { -            // invalid imaginary number -            // set index back to initial, error index should already be set -            // character examined.              pos.setIndex(initialIndex);              return null;          } - -        // parse imaginary character          int n = getImaginaryCharacter().length();          startIndex = pos.getIndex();          int endIndex = startIndex + n; -        if ( +// buggy code +//         if ( +       if (endIndex > source.length() ||              source.substring(startIndex, endIndex).compareTo(              getImaginaryCharacter()) != 0) { -            // set index back to initial, error index should be the start index -            // character examined.              pos.setIndex(initialIndex);              pos.setErrorIndex(startIndex);              return null;          }          pos.setIndex(endIndex); -          return new Complex(re.doubleValue(), im.doubleValue() * sign);      }"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +// buggy code +//         if (dataset != null) { +       if (dataset == null || dataset.getRowCount() == 0) {              return result;          }          int seriesCount = dataset.getRowCount();
1,public class ClassUtils {          }          Class<?>[] classes = new Class[array.length];          for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +// buggy code +//             classes[i] = array[i].getClass(); +           classes[i] = (array[i] != null ? array[i].getClass() : null);          }          return classes;      }
1,public class ClassUtils {          }          Class<?>[] classes = new Class[array.length];          for (int i = 0; i < array.length; i++) { +// buggy code +//             classes[i] = array[i].getClass(); +           Object object = array[i]; +            if (object != null) {                  classes[i] = array[i].getClass();              } +        }          return classes;      }
1,public class ClassUtils {          }          Class<?>[] classes = new Class[array.length];          for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +// buggy code +//             classes[i] = array[i].getClass(); +           Object object = array[i]; +            classes[i] = (object != null ? object.getClass() : null);          }          return classes;      }
1,"public class BorderArrangement implements Arrangement, Serializable {          h[3] = h[2];          if (this.rightBlock != null) {              RectangleConstraint c4 = new RectangleConstraint(0.0, -                    new Range(0.0, constraint.getWidth() - w[2]), +// buggy code +//                     new Range(0.0, constraint.getWidth() - w[2]), +                   new Range(0.0, constraint.getWidth() - w[4]),                      LengthConstraintType.RANGE, h[2], null,                      LengthConstraintType.FIXED);              Size2D size = this.rightBlock.arrange(g2, c4); @@ -464,7 +466,6 @@ public class BorderArrangement implements Arrangement, Serializable {          if (this.centerBlock != null) {              this.centerBlock.arrange(g2, c5);          } -          if (this.topBlock != null) {              this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],                      h[0]));"
1,"public final class NodeUtil {    static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {      switch (value.getType()) {        case Token.ASSIGN: -        // A result that is aliased by a non-local name, is the effectively the -        // same as returning a non-local name, but this doesn't matter if the -        // value is immutable.          return NodeUtil.isImmutableValue(value.getLastChild())              || (locals.apply(value)                  && evaluatesToLocalValue(value.getLastChild(), locals)); @@ -2452,36 +2449,28 @@ public final class NodeUtil {          return isImmutableValue(value) || locals.apply(value);        case Token.GETELEM:        case Token.GETPROP: -        // There is no information about the locality of object properties.          return locals.apply(value);        case Token.CALL:          return callHasLocalResult(value)              || isToStringMethodCall(value)              || locals.apply(value);        case Token.NEW: -        // TODO(nicksantos): This needs to be changed so that it -        // returns true iff we're sure the value was never aliased from inside -        // the constructor (similar to callHasLocalResult) -        return true; +// buggy code +//         return true; +       return NodeUtil.isImmutableValue(value.getFirstChild());        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT:        case Token.OBJECTLIT: -        // Literals objects with non-literal children are allowed.          return true;        case Token.IN: -        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?          return true;        default: -        // Other op force a local value: -        //  x = '' + g (x is now an local string) -        //  x -= g (x is now an local number)          if (isAssignmentOp(value)              || isSimpleOperator(value)              || isImmutableValue(value)) {            return true;          } -          throw new IllegalStateException(              ""Unexpected expression node"" + value +              ""\n parent:"" + value.getParent());"
1,"public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {       */      private static <T extends Clusterable<T>> List<Cluster<T>>          chooseInitialCenters(final Collection<T> points, final int k, final Random random) { -          final List<T> pointSet = new ArrayList<T>(points);          final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); - -        // Choose one center uniformly at random from among the data points.          final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));          resultSet.add(new Cluster<T>(firstPoint)); -          final double[] dx2 = new double[pointSet.size()];          while (resultSet.size() < k) { -            // For each data point x, compute D(x), the distance between x and -            // the nearest center that has already been chosen. -            int sum = 0; +// buggy code +//             int sum = 0; +           double sum = 0.;              for (int i = 0; i < pointSet.size(); i++) {                  final T p = pointSet.get(i);                  final Cluster<T> nearest = getNearestCluster(resultSet, p); @@ -180,9 +176,6 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {                  sum += d * d;                  dx2[i] = sum;              } - -            // Add one new data point as a center. Each point x is chosen with -            // probability proportional to D(x)2              final double r = random.nextDouble() * sum;              for (int i = 0 ; i < dx2.length; i++) {                  if (dx2[i] >= r) { @@ -192,9 +185,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {                  }              }          } -          return resultSet; -      }        /**"
1,"public abstract class Axis implements Cloneable, Serializable {      protected AxisState drawLabel(String label, Graphics2D g2,               Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,               AxisState state, PlotRenderingInfo plotState) { - -        // it is unlikely that 'state' will be null, but check anyway...          if (state == null) {              throw new IllegalArgumentException(""Null 'state' argument."");          } -                  if ((label == null) || (label.equals(""""))) {              return state;          } -          Font font = getLabelFont();          RectangleInsets insets = getLabelInsets();          g2.setFont(font); @@ -1109,7 +1105,6 @@ public abstract class Axis implements Cloneable, Serializable {          FontMetrics fm = g2.getFontMetrics();          Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);          Shape hotspot = null; -                  if (edge == RectangleEdge.TOP) {              AffineTransform t = AffineTransform.getRotateInstance(                      getLabelAngle(), labelBounds.getCenterX(),  @@ -1166,7 +1161,6 @@ public abstract class Axis implements Cloneable, Serializable {                      + insets.getRight());          }          else if (edge == RectangleEdge.RIGHT) { -              AffineTransform t = AffineTransform.getRotateInstance(                      getLabelAngle() + Math.PI / 2.0,                       labelBounds.getCenterX(), labelBounds.getCenterY()); @@ -1185,18 +1179,17 @@ public abstract class Axis implements Cloneable, Serializable {                      labely - h / 2.0f, w, h);              state.cursorRight(insets.getLeft() + labelBounds.getWidth()                       + insets.getRight()); -          }          if (plotState != null && hotspot != null) {              ChartRenderingInfo owner = plotState.getOwner(); -                EntityCollection entities = owner.getEntityCollection(); -                if (entities != null) { -                    entities.add(new AxisLabelEntity(this, hotspot,  -                            this.labelToolTip, this.labelURL)); -                } +// buggy code +//                 EntityCollection entities = owner.getEntityCollection(); +//                 if (entities != null) { +//                     entities.add(new AxisLabelEntity(this, hotspot,  +//                             this.labelToolTip, this.labelURL)); +//                 }          }          return state; -      }        /**"
1,"public class MannWhitneyUTest {                                               final int n1,                                               final int n2)          throws ConvergenceException, MaxCountExceededException { - -        final int n1n2prod = n1 * n2; - -        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation +// buggy code +//         final int n1n2prod = n1 * n2; +       final double n1n2prod = (double) n1 * n2;          final double EU = n1n2prod / 2.0;          final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; -          final double z = (Umin - EU) / FastMath.sqrt(VarU); -          final NormalDistribution standardNormal = new NormalDistribution(0, 1); -          return 2 * standardNormal.cumulativeProbability(z);      }"
1,"public class UnivariateRealSolverUtils {              double initial, double lowerBound, double upperBound,               int maximumIterations) throws ConvergenceException,               FunctionEvaluationException { -                  if (function == null) {              throw MathRuntimeException.createIllegalArgumentException(""function is null"");          } @@ -184,18 +183,17 @@ public class UnivariateRealSolverUtils {          double fa;          double fb;          int numIterations = 0 ; -              do {              a = Math.max(a - 1.0, lowerBound);              b = Math.min(b + 1.0, upperBound);              fa = function.value(a); -                          fb = function.value(b);              numIterations++ ;          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound))); -    -        if (fa * fb >= 0.0 ) { +// buggy code +//         if (fa * fb >= 0.0 ) { +       if (fa * fb >= 0.0 && numIterations == maximumIterations) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + @@ -203,7 +201,6 @@ public class UnivariateRealSolverUtils {                        numIterations, maximumIterations, initial,                        lowerBound, upperBound, a, b, fa, fb);          } -                  return new double[]{a, b};      }"
1,"public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {      /** {@inheritDoc} */      @Override      protected void computeGeometricalProperties() { -          final Vector2D[][] v = getVertices(); -          if (v.length == 0) {              final BSPTree<Euclidean2D> tree = getTree(false); -            if ((Boolean) tree.getAttribute()) { -                // the instance covers the whole space +// buggy code +//             if ((Boolean) tree.getAttribute()) { +           if (tree.getAttribute() == Boolean.TRUE) {                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN);              } else { @@ -142,16 +141,12 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {                  setBarycenter(new Vector2D(0, 0));              }          } else if (v[0][0] == null) { -            // there is at least one open-loop: the polygon is infinite              setSize(Double.POSITIVE_INFINITY);              setBarycenter(Vector2D.NaN);          } else { -            // all loops are closed, we compute some integrals around the shape -              double sum  = 0;              double sumX = 0;              double sumY = 0; -              for (Vector2D[] loop : v) {                  double x1 = loop[loop.length - 1].getX();                  double y1 = loop[loop.length - 1].getY(); @@ -166,18 +161,14 @@ public class PolygonsSet extends AbstractRegion<Euclidean2D, Euclidean1D> {                      sumY += factor * (y0 + y1);                  }              } -              if (sum < 0) { -                // the polygon as a finite outside surrounded by an infinite inside                  setSize(Double.POSITIVE_INFINITY);                  setBarycenter(Vector2D.NaN);              } else {                  setSize(sum / 2);                  setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));              } -          } -      }        /** Get the vertices of the polygon."
1,"public final class NodeUtil {    static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {      switch (value.getType()) {        case Token.ASSIGN: -        // A result that is aliased by a non-local name, is the effectively the -        // same as returning a non-local name, but this doesn't matter if the -        // value is immutable.          return NodeUtil.isImmutableValue(value.getLastChild())              || (locals.apply(value)                  && evaluatesToLocalValue(value.getLastChild(), locals)); @@ -2452,36 +2449,28 @@ public final class NodeUtil {          return isImmutableValue(value) || locals.apply(value);        case Token.GETELEM:        case Token.GETPROP: -        // There is no information about the locality of object properties.          return locals.apply(value);        case Token.CALL:          return callHasLocalResult(value)              || isToStringMethodCall(value)              || locals.apply(value);        case Token.NEW: -        // TODO(nicksantos): This needs to be changed so that it -        // returns true iff we're sure the value was never aliased from inside -        // the constructor (similar to callHasLocalResult) -        return true; +// buggy code +//         return true; +       return locals.apply(value);        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT:        case Token.OBJECTLIT: -        // Literals objects with non-literal children are allowed.          return true;        case Token.IN: -        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?          return true;        default: -        // Other op force a local value: -        //  x = '' + g (x is now an local string) -        //  x -= g (x is now an local number)          if (isAssignmentOp(value)              || isSimpleOperator(value)              || isImmutableValue(value)) {            return true;          } -          throw new IllegalStateException(              ""Unexpected expression node"" + value +              ""\n parent:"" + value.getParent());"
1,"public class EigenDecompositionImpl implements EigenDecomposition {       */      private boolean flipIfWarranted(final int n, final int step) {          if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { -            // flip array -            int j = 4 * n - 1; +// buggy code +//             int j = 4 * n - 1; +           int j = 4 * n - 4;              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k];"
1,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +// buggy code +//         if (dataset != null) { +       if (dataset == null || dataset.getRowCount() <= 0) {              return result;          }          int seriesCount = dataset.getRowCount();
1,"public class BooleanUtils {       * @return the boolean value of the string, <code>false</code> if no match       */      public static boolean toBoolean(String str) { -        // Previously used equalsIgnoreCase, which was fast for interned 'true'. -        // Non interned 'true' matched 15 times slower. -        //  -        // Optimisation provides same performance as before for interned 'true'. -        // Similar performance for null, 'false', and other strings not length 2/3/4. -        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.          if (str == ""true"") {              return true;          } @@ -679,6 +673,14 @@ public class BooleanUtils {                          (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&                          (str.charAt(2) == 'S' || str.charAt(2) == 's');                  } +// buggy code +//  +               if (ch == 'n') { +                    return  +                        (str.charAt(1) == 'o' || str.charAt(1) == 'O') && +                        (str.charAt(2) == 'f' || str.charAt(2) == 'F'); +                } +                return false;              }              case 4: {                  char ch = str.charAt(0);"
1,"public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {       */      private static <T extends Clusterable<T>> List<Cluster<T>>          chooseInitialCenters(final Collection<T> points, final int k, final Random random) { -          final List<T> pointSet = new ArrayList<T>(points);          final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); - -        // Choose one center uniformly at random from among the data points.          final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));          resultSet.add(new Cluster<T>(firstPoint)); -          final double[] dx2 = new double[pointSet.size()];          while (resultSet.size() < k) { -            // For each data point x, compute D(x), the distance between x and -            // the nearest center that has already been chosen. -            int sum = 0; +// buggy code +//             int sum = 0; +           double sum = 0.0;              for (int i = 0; i < pointSet.size(); i++) {                  final T p = pointSet.get(i);                  final Cluster<T> nearest = getNearestCluster(resultSet, p); @@ -180,9 +176,6 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {                  sum += d * d;                  dx2[i] = sum;              } - -            // Add one new data point as a center. Each point x is chosen with -            // probability proportional to D(x)2              final double r = random.nextDouble() * sum;              for (int i = 0 ; i < dx2.length; i++) {                  if (dx2[i] >= r) { @@ -192,9 +185,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {                  }              }          } -          return resultSet; -      }        /**"
1,"public class WordUtils {       * @since 2.4       */      public static String abbreviate(String str, int lower, int upper, String appendToEnd) { -        // initial parameter checks          if (str == null) {              return null;          }          if (str.length() == 0) {              return StringUtils.EMPTY; +// buggy code +//  +       } +        if (lower == -1 || lower > str.length()) { +            lower = 0;          } - -        // if the lower value is greater than the length of the string, -        // set to the length of the string -        // if the upper value is -1 (i.e. no limit) or is greater -        // than the length of the string, set to the length of the string          if (upper == -1 || upper > str.length()) {              upper = str.length();          } -        // if upper is less than lower, raise it to lower          if (upper < lower) {              upper = lower;          } -          StringBuffer result = new StringBuffer();          int index = StringUtils.indexOf(str, "" "", lower);          if (index == -1) {              result.append(str.substring(0, upper)); -            // only if abbreviation has occured do we append the appendToEnd value              if (upper != str.length()) {                  result.append(StringUtils.defaultString(appendToEnd));              }"
1,"public class ArgumentMatchingTool {      }        private boolean toStringEquals(Matcher m, Object arg) { +// buggy code +//         return StringDescription.toString(m).equals(arg.toString()); +       try {              return StringDescription.toString(m).equals(arg.toString()); +        } catch (Exception e) { +            return false; +        }      }  }"
1,public class ShapeUtilities {              return false;          }          PathIterator iterator1 = p1.getPathIterator(null); -        PathIterator iterator2 = p1.getPathIterator(null); +// buggy code +//         PathIterator iterator2 = p1.getPathIterator(null); +       iterator1 = p1.getPathIterator(null); +        PathIterator iterator2 = p2.getPathIterator(null);          double[] d1 = new double[6];          double[] d2 = new double[6];          boolean done = iterator1.isDone() && iterator2.isDone();
1,"public final class NodeUtil {    static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {      switch (value.getType()) {        case Token.ASSIGN: -        // A result that is aliased by a non-local name, is the effectively the -        // same as returning a non-local name, but this doesn't matter if the -        // value is immutable.          return NodeUtil.isImmutableValue(value.getLastChild())              || (locals.apply(value)                  && evaluatesToLocalValue(value.getLastChild(), locals)); @@ -2452,36 +2449,28 @@ public final class NodeUtil {          return isImmutableValue(value) || locals.apply(value);        case Token.GETELEM:        case Token.GETPROP: -        // There is no information about the locality of object properties.          return locals.apply(value);        case Token.CALL:          return callHasLocalResult(value)              || isToStringMethodCall(value)              || locals.apply(value);        case Token.NEW: -        // TODO(nicksantos): This needs to be changed so that it -        // returns true iff we're sure the value was never aliased from inside -        // the constructor (similar to callHasLocalResult) -        return true; +// buggy code +//         return true; +       return NodeUtil.isImmutableValue(value);        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT:        case Token.OBJECTLIT: -        // Literals objects with non-literal children are allowed.          return true;        case Token.IN: -        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?          return true;        default: -        // Other op force a local value: -        //  x = '' + g (x is now an local string) -        //  x -= g (x is now an local number)          if (isAssignmentOp(value)              || isSimpleOperator(value)              || isImmutableValue(value)) {            return true;          } -          throw new IllegalStateException(              ""Unexpected expression node"" + value +              ""\n parent:"" + value.getParent());"
1,"public final class NodeUtil {    static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {      switch (value.getType()) {        case Token.ASSIGN: -        // A result that is aliased by a non-local name, is the effectively the -        // same as returning a non-local name, but this doesn't matter if the -        // value is immutable.          return NodeUtil.isImmutableValue(value.getLastChild())              || (locals.apply(value)                  && evaluatesToLocalValue(value.getLastChild(), locals)); @@ -2452,36 +2449,28 @@ public final class NodeUtil {          return isImmutableValue(value) || locals.apply(value);        case Token.GETELEM:        case Token.GETPROP: -        // There is no information about the locality of object properties.          return locals.apply(value);        case Token.CALL:          return callHasLocalResult(value)              || isToStringMethodCall(value)              || locals.apply(value);        case Token.NEW: -        // TODO(nicksantos): This needs to be changed so that it -        // returns true iff we're sure the value was never aliased from inside -        // the constructor (similar to callHasLocalResult) -        return true; +// buggy code +//         return true; +       return isImmutableValue(value) || locals.apply(value);        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT:        case Token.OBJECTLIT: -        // Literals objects with non-literal children are allowed.          return true;        case Token.IN: -        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?          return true;        default: -        // Other op force a local value: -        //  x = '' + g (x is now an local string) -        //  x -= g (x is now an local number)          if (isAssignmentOp(value)              || isSimpleOperator(value)              || isImmutableValue(value)) {            return true;          } -          throw new IllegalStateException(              ""Unexpected expression node"" + value +              ""\n parent:"" + value.getParent());"
1,"public class UnivariateRealSolverUtils {              double initial, double lowerBound, double upperBound,               int maximumIterations) throws ConvergenceException,               FunctionEvaluationException { -                  if (function == null) {              throw MathRuntimeException.createIllegalArgumentException(""function is null"");          } @@ -184,18 +183,17 @@ public class UnivariateRealSolverUtils {          double fa;          double fb;          int numIterations = 0 ; -              do {              a = Math.max(a - 1.0, lowerBound);              b = Math.min(b + 1.0, upperBound);              fa = function.value(a); -                          fb = function.value(b);              numIterations++ ;          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound))); -    -        if (fa * fb >= 0.0 ) { +// buggy code +//         if (fa * fb >= 0.0 ) { +       if (fa * fb >= 0.0 && numIterations >= maximumIterations) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + @@ -203,7 +201,6 @@ public class UnivariateRealSolverUtils {                        numIterations, maximumIterations, initial,                        lowerBound, upperBound, a, b, fa, fb);          } -                  return new double[]{a, b};      }"
0,"public class XYPlot extends Plot implements ValueAxisPlot, Pannable,       * @return The range.       */      public Range getDataRange(ValueAxis axis) { -          Range result = null;          List mappedDatasets = new ArrayList();          List includedAnnotations = new ArrayList();          boolean isDomainAxis = true; - -        // is it a domain axis?          int domainIndex = getDomainAxisIndex(axis);          if (domainIndex >= 0) {              isDomainAxis = true;              mappedDatasets.addAll(getDatasetsMappedToDomainAxis(                      new Integer(domainIndex)));              if (domainIndex == 0) { -                // grab the plot's annotations                  Iterator iterator = this.annotations.iterator();                  while (iterator.hasNext()) {                      XYAnnotation annotation = (XYAnnotation) iterator.next(); @@ -4446,8 +4442,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } - -        // or is it a range axis?          int rangeIndex = getRangeAxisIndex(axis);          if (rangeIndex >= 0) {              isDomainAxis = false; @@ -4463,9 +4457,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } - -        // iterate through the datasets that map to the axis and get the union -        // of the ranges.          Iterator iterator = mappedDatasets.iterator();          while (iterator.hasNext()) {              XYDataset d = (XYDataset) iterator.next(); @@ -4489,7 +4480,16 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                                  DatasetUtilities.findRangeBounds(d));                      }                  } -                 +// buggy code +//                     Collection c = r.getAnnotations(); +//                     Iterator i = c.iterator(); +//                     while (i.hasNext()) { +//                         XYAnnotation a = (XYAnnotation) i.next(); +//                         if (a instanceof XYAnnotationBoundsInfo) { +//                             includedAnnotations.add(a); +//                         } +//                     } +               if (r != null) {                      Collection c = r.getAnnotations();                      Iterator i = c.iterator();                      while (i.hasNext()) { @@ -4500,7 +4500,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                      }                  }              } - +        }          Iterator it = includedAnnotations.iterator();          while (it.hasNext()) {              XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); @@ -4513,9 +4513,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } -          return result; -      }        /**"
0,"public class BisectionSolver extends UnivariateRealSolverImpl {      /** {@inheritDoc} */      public double solve(final UnivariateRealFunction f, double min, double max, double initial)          throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +// buggy code +//         return solve(min, max); +       return solve(f,min,max);      }        /** {@inheritDoc} */"
0,"public abstract class Axis implements Cloneable, Serializable {      protected AxisState drawLabel(String label, Graphics2D g2,               Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,               AxisState state, PlotRenderingInfo plotState) { - -        // it is unlikely that 'state' will be null, but check anyway...          if (state == null) {              throw new IllegalArgumentException(""Null 'state' argument."");          } -                  if ((label == null) || (label.equals(""""))) {              return state;          } -          Font font = getLabelFont();          RectangleInsets insets = getLabelInsets();          g2.setFont(font); @@ -1109,7 +1105,6 @@ public abstract class Axis implements Cloneable, Serializable {          FontMetrics fm = g2.getFontMetrics();          Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);          Shape hotspot = null; -                  if (edge == RectangleEdge.TOP) {              AffineTransform t = AffineTransform.getRotateInstance(                      getLabelAngle(), labelBounds.getCenterX(),  @@ -1166,7 +1161,6 @@ public abstract class Axis implements Cloneable, Serializable {                      + insets.getRight());          }          else if (edge == RectangleEdge.RIGHT) { -              AffineTransform t = AffineTransform.getRotateInstance(                      getLabelAngle() + Math.PI / 2.0,                       labelBounds.getCenterX(), labelBounds.getCenterY()); @@ -1185,18 +1179,24 @@ public abstract class Axis implements Cloneable, Serializable {                      labely - h / 2.0f, w, h);              state.cursorRight(insets.getLeft() + labelBounds.getWidth()                       + insets.getRight()); -          }          if (plotState != null && hotspot != null) {              ChartRenderingInfo owner = plotState.getOwner(); +// buggy code +//                 EntityCollection entities = owner.getEntityCollection(); +//                 if (entities != null) { +//                     entities.add(new AxisLabelEntity(this, hotspot,  +//                             this.labelToolTip, this.labelURL)); +//                 } +           if (owner != null) {                  EntityCollection entities = owner.getEntityCollection();                  if (entities != null) {                      entities.add(new AxisLabelEntity(this, hotspot,                               this.labelToolTip, this.labelURL));                  }              } +        }          return state; -      }        /**"
0,"public class UnivariateRealSolverUtils {              double initial, double lowerBound, double upperBound,               int maximumIterations) throws ConvergenceException,               FunctionEvaluationException { -                  if (function == null) {              throw MathRuntimeException.createIllegalArgumentException(""function is null"");          } @@ -184,18 +183,17 @@ public class UnivariateRealSolverUtils {          double fa;          double fb;          int numIterations = 0 ; -              do {              a = Math.max(a - 1.0, lowerBound);              b = Math.min(b + 1.0, upperBound);              fa = function.value(a); -                          fb = function.value(b);              numIterations++ ;          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound))); -    -        if (fa * fb >= 0.0 ) { +// buggy code +//         if (fa * fb >= 0.0 ) { +       if (fa * fb > 0.0 ) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + @@ -203,7 +201,6 @@ public class UnivariateRealSolverUtils {                        numIterations, maximumIterations, initial,                        lowerBound, upperBound, a, b, fa, fb);          } -                  return new double[]{a, b};      }"
0,"class PeepholeOptimizationsPass    }      private void traverse(Node node) { -    // The goal here is to avoid retraversing -    // the entire AST to catch newly created opportunities. -    // So we track whether a ""unit of code"" has changed, -    // and revisit immediately.      if (!shouldVisit(node)) {        return;      } -      int visits = 0;      do {        Node c = node.getFirstChild();        while(c != null) { -        traverse(c); +// buggy code +//         traverse(c); +//         Node next = c.getNext();         Node next = c.getNext();  +        traverse(c);          c = next;        } -        visit(node);        visits++; -        Preconditions.checkState(visits < 10000, ""too many interations"");      } while (shouldRetraverse(node)); -      exitNode(node);    }"
0,"public final class NodeUtil {    static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {      switch (value.getType()) {        case Token.ASSIGN: -        // A result that is aliased by a non-local name, is the effectively the -        // same as returning a non-local name, but this doesn't matter if the -        // value is immutable.          return NodeUtil.isImmutableValue(value.getLastChild())              || (locals.apply(value)                  && evaluatesToLocalValue(value.getLastChild(), locals)); @@ -2452,36 +2449,28 @@ public final class NodeUtil {          return isImmutableValue(value) || locals.apply(value);        case Token.GETELEM:        case Token.GETPROP: -        // There is no information about the locality of object properties.          return locals.apply(value);        case Token.CALL:          return callHasLocalResult(value)              || isToStringMethodCall(value)              || locals.apply(value);        case Token.NEW: -        // TODO(nicksantos): This needs to be changed so that it -        // returns true iff we're sure the value was never aliased from inside -        // the constructor (similar to callHasLocalResult) -        return true; +// buggy code +//         return true; +       return false;        case Token.FUNCTION:        case Token.REGEXP:        case Token.ARRAYLIT:        case Token.OBJECTLIT: -        // Literals objects with non-literal children are allowed.          return true;        case Token.IN: -        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?          return true;        default: -        // Other op force a local value: -        //  x = '' + g (x is now an local string) -        //  x -= g (x is now an local number)          if (isAssignmentOp(value)              || isSimpleOperator(value)              || isImmutableValue(value)) {            return true;          } -          throw new IllegalStateException(              ""Unexpected expression node"" + value +              ""\n parent:"" + value.getParent());"
0,"public final class NodeUtil {      static boolean mayBeString(Node n, boolean recurse) {      if (recurse) { -      return allResultsMatch(n, MAY_BE_STRING_PREDICATE); +// buggy code +//       return allResultsMatch(n, MAY_BE_STRING_PREDICATE); +     return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);      } else {        return mayBeStringHelper(n);      }"
0,"public class TimePeriodValues extends Series implements Serializable {       * @param index  the index of the time period.       */      private void updateBounds(TimePeriod period, int index) { -                  long start = period.getStart().getTime();          long end = period.getEnd().getTime();          long middle = start + ((end - start) / 2); -          if (this.minStartIndex >= 0) {              long minStart = getDataItem(this.minStartIndex).getPeriod()                  .getStart().getTime(); @@ -270,7 +268,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minStartIndex = index;          } -                  if (this.maxStartIndex >= 0) {              long maxStart = getDataItem(this.maxStartIndex).getPeriod()                  .getStart().getTime(); @@ -281,7 +278,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxStartIndex = index;          } -                  if (this.minMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); @@ -295,11 +291,14 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minMiddleIndex = index;          } -                  if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +// buggy code +//             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +//                 .getTime(); +//             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +           long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()                  .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) { @@ -309,7 +308,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxMiddleIndex = index;          } -                  if (this.minEndIndex >= 0) {              long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()                  .getTime(); @@ -320,7 +318,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minEndIndex = index;          } -                 if (this.maxEndIndex >= 0) {              long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()                  .getTime(); @@ -331,7 +328,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxEndIndex = index;          } -              }            /**"
0,"public class MannWhitneyUTest {                                               final int n1,                                               final int n2)          throws ConvergenceException, MaxCountExceededException { - -        final int n1n2prod = n1 * n2; - -        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation +// buggy code +//         final int n1n2prod = n1 * n2; +       final double n1n2prod = n1 * n2;          final double EU = n1n2prod / 2.0;          final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; -          final double z = (Umin - EU) / FastMath.sqrt(VarU); -          final NormalDistribution standardNormal = new NormalDistribution(0, 1); -          return 2 * standardNormal.cumulativeProbability(z);      }"
0,"public final class MathUtils {       * @return the L<sub>2</sub> distance between the two points       */      public static double distance(int[] p1, int[] p2) { -      int sum = 0; +// buggy code +//       int sum = 0; +//       for (int i = 0; i < p1.length; i++) { +//           final int dp = p1[i] - p2[i]; +     double sum = 0;        for (int i = 0; i < p1.length; i++) { -          final int dp = p1[i] - p2[i]; +          final double dp = (p1[i] - p2[i]);            sum += dp * dp;        }        return Math.sqrt(sum);"
0,"public class ValueMarker extends Marker {       */      public ValueMarker(double value, Paint paint, Stroke stroke,                          Paint outlinePaint, Stroke outlineStroke, float alpha) { -        super(paint, stroke, paint, stroke, alpha); +// buggy code +//         super(paint, stroke, paint, stroke, alpha); +       super(paint, stroke, outlinePaint, outlineStroke, alpha);          this.value = value;      }"
0,"public class WordUtils {       * @since 2.4       */      public static String abbreviate(String str, int lower, int upper, String appendToEnd) { -        // initial parameter checks          if (str == null) {              return null;          }          if (str.length() == 0) {              return StringUtils.EMPTY; +// buggy code +//  +       } +        if (lower > str.length()) { +            lower = str.length();          } - -        // if the lower value is greater than the length of the string, -        // set to the length of the string -        // if the upper value is -1 (i.e. no limit) or is greater -        // than the length of the string, set to the length of the string          if (upper == -1 || upper > str.length()) {              upper = str.length();          } -        // if upper is less than lower, raise it to lower          if (upper < lower) {              upper = lower;          } -          StringBuffer result = new StringBuffer();          int index = StringUtils.indexOf(str, "" "", lower);          if (index == -1) {              result.append(str.substring(0, upper)); -            // only if abbreviation has occured do we append the appendToEnd value              if (upper != str.length()) {                  result.append(StringUtils.defaultString(appendToEnd));              }"
0,"public class Same extends ArgumentMatcher<Object> implements Serializable {      public void describeTo(Description description) {          description.appendText(""same("");          appendQuoting(description); -        description.appendText(wanted.toString()); +// buggy code +//         description.appendText(wanted.toString()); +       description.appendText(wanted == null ? ""null"" : wanted.toString());          appendQuoting(description);          description.appendText("")"");      }"
0,public class Frequency implements Serializable {       */      @Deprecated      public double getPct(Object v) { -        return getCumPct((Comparable<?>) v); +// buggy code +//         return getCumPct((Comparable<?>) v); +       return getPct((Comparable<?>) v);      }        /**
0,"public abstract class Axis implements Cloneable, Serializable {      protected AxisState drawLabel(String label, Graphics2D g2,               Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,               AxisState state, PlotRenderingInfo plotState) { - -        // it is unlikely that 'state' will be null, but check anyway...          if (state == null) {              throw new IllegalArgumentException(""Null 'state' argument."");          } -                  if ((label == null) || (label.equals(""""))) {              return state;          } -          Font font = getLabelFont();          RectangleInsets insets = getLabelInsets();          g2.setFont(font); @@ -1109,7 +1105,6 @@ public abstract class Axis implements Cloneable, Serializable {          FontMetrics fm = g2.getFontMetrics();          Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);          Shape hotspot = null; -                  if (edge == RectangleEdge.TOP) {              AffineTransform t = AffineTransform.getRotateInstance(                      getLabelAngle(), labelBounds.getCenterX(),  @@ -1166,7 +1161,6 @@ public abstract class Axis implements Cloneable, Serializable {                      + insets.getRight());          }          else if (edge == RectangleEdge.RIGHT) { -              AffineTransform t = AffineTransform.getRotateInstance(                      getLabelAngle() + Math.PI / 2.0,                       labelBounds.getCenterX(), labelBounds.getCenterY()); @@ -1185,18 +1179,24 @@ public abstract class Axis implements Cloneable, Serializable {                      labely - h / 2.0f, w, h);              state.cursorRight(insets.getLeft() + labelBounds.getWidth()                       + insets.getRight()); -          }          if (plotState != null && hotspot != null) {              ChartRenderingInfo owner = plotState.getOwner(); +// buggy code +//                 EntityCollection entities = owner.getEntityCollection(); +//                 if (entities != null) { +//                     entities.add(new AxisLabelEntity(this, hotspot,  +//                             this.labelToolTip, this.labelURL)); +//                 } +           if (owner != null) {                  EntityCollection entities = owner.getEntityCollection();                  if (entities != null) {                      entities.add(new AxisLabelEntity(this, hotspot,                                   this.labelToolTip, this.labelURL));                  }              } +        }          return state; -      }        /**"
0,"public class HypergeometricDistribution extends AbstractIntegerDistribution {       * size {@code n}, the mean is {@code n * m / N}.       */      public double getNumericalMean() { -        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); +// buggy code +//         return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); +       return (double) getSampleSize() * getNumberOfSuccesses() / (double) getPopulationSize();      }        /**"
0,public class FDistributionImpl       * @return initial domain value       */      protected double getInitialDomain(double p) { -        double ret; +// buggy code +//         double ret; +//         double d = getDenominatorDegreesOfFreedom(); +//             ret = d / (d - 2.0); +       double ret = 1.0;          double d = getDenominatorDegreesOfFreedom(); -            // use mean +        if (d > 2.0) {              ret = d / (d - 2.0); +        }          return ret;      }
0,public class ShapeUtilities {              return false;          }          PathIterator iterator1 = p1.getPathIterator(null); -        PathIterator iterator2 = p1.getPathIterator(null); +// buggy code +//         PathIterator iterator2 = p1.getPathIterator(null); +       PathIterator iterator2 = p2.getPathIterator(null);           double[] d1 = new double[6];          double[] d2 = new double[6];          boolean done = iterator1.isDone() && iterator2.isDone();
0,"public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {       */      private static <T extends Clusterable<T>> List<Cluster<T>>          chooseInitialCenters(final Collection<T> points, final int k, final Random random) { -          final List<T> pointSet = new ArrayList<T>(points);          final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); - -        // Choose one center uniformly at random from among the data points.          final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));          resultSet.add(new Cluster<T>(firstPoint)); -          final double[] dx2 = new double[pointSet.size()];          while (resultSet.size() < k) { -            // For each data point x, compute D(x), the distance between x and -            // the nearest center that has already been chosen. -            int sum = 0; +// buggy code +//             int sum = 0; +           double sum = 0;              for (int i = 0; i < pointSet.size(); i++) {                  final T p = pointSet.get(i);                  final Cluster<T> nearest = getNearestCluster(resultSet, p); @@ -180,9 +176,6 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {                  sum += d * d;                  dx2[i] = sum;              } - -            // Add one new data point as a center. Each point x is chosen with -            // probability proportional to D(x)2              final double r = random.nextDouble() * sum;              for (int i = 0 ; i < dx2.length; i++) {                  if (dx2[i] >= r) { @@ -192,9 +185,7 @@ public class KMeansPlusPlusClusterer<T extends Clusterable<T>> {                  }              }          } -          return resultSet; -      }        /**"
0,"public class StrBuilder implements Cloneable {              String str = (obj == null ? getNullText() : obj.toString());              int strLen = str.length();              if (strLen >= width) { -                str.getChars(0, strLen, buffer, size); +// buggy code +//                 str.getChars(0, strLen, buffer, size); +               str.getChars(0, width, buffer, size);              } else {                  int padLen = width - strLen;                  str.getChars(0, strLen, buffer, size);"
0,public class ShapeUtilities {              return false;          }          PathIterator iterator1 = p1.getPathIterator(null); -        PathIterator iterator2 = p1.getPathIterator(null); +// buggy code +//         PathIterator iterator2 = p1.getPathIterator(null); +       PathIterator iterator2 = p2.getPathIterator(null);          double[] d1 = new double[6];          double[] d2 = new double[6];          boolean done = iterator1.isDone() && iterator2.isDone();
0,"public class Variance extends AbstractStorelessUnivariateStatistic implements Se       */      public double evaluate(final double[] values, final double[] weights,                             final double mean, final int begin, final int length) { -          double var = Double.NaN; -          if (test(values, weights, begin, length)) {              if (length == 1) {                  var = 0.0; @@ -515,12 +513,12 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se                      accum += weights[i] * (dev * dev);                      accum2 += weights[i] * dev;                  } -                  double sumWts = 0; -                for (int i = 0; i < weights.length; i++) { +// buggy code +//                 for (int i = 0; i < weights.length; i++) { +               for (int i = begin; i < begin+length; i++) {                      sumWts += weights[i];                  } -                  if (isBiasCorrected) {                      var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);                  } else {"
0,"public class Variance extends AbstractStorelessUnivariateStatistic implements Se       */      public double evaluate(final double[] values, final double[] weights,                             final double mean, final int begin, final int length) { -          double var = Double.NaN; -          if (test(values, weights, begin, length)) {              if (length == 1) {                  var = 0.0; @@ -515,12 +513,12 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se                      accum += weights[i] * (dev * dev);                      accum2 += weights[i] * dev;                  } -                  double sumWts = 0; -                for (int i = 0; i < weights.length; i++) { +// buggy code +//                 for (int i = 0; i < weights.length; i++) { +               for (int i = begin; i < begin + length; i++) {                      sumWts += weights[i];                  } -                  if (isBiasCorrected) {                      var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);                  } else {"
0,"public class UnivariateRealSolverUtils {              double initial, double lowerBound, double upperBound,               int maximumIterations) throws ConvergenceException,               FunctionEvaluationException { -                  if (function == null) {              throw MathRuntimeException.createIllegalArgumentException(""function is null"");          } @@ -184,18 +183,17 @@ public class UnivariateRealSolverUtils {          double fa;          double fb;          int numIterations = 0 ; -              do {              a = Math.max(a - 1.0, lowerBound);              b = Math.min(b + 1.0, upperBound);              fa = function.value(a); -                          fb = function.value(b);              numIterations++ ;          } while ((fa * fb > 0.0) && (numIterations < maximumIterations) &&                   ((a > lowerBound) || (b < upperBound))); -    -        if (fa * fb >= 0.0 ) { +// buggy code +//         if (fa * fb >= 0.0 ) { +       if (fa * fb > 0.0) {              throw new ConvergenceException(                        ""number of iterations={0}, maximum iterations={1}, "" +                        ""initial={2}, lower bound={3}, upper bound={4}, final a value={5}, "" + @@ -203,7 +201,6 @@ public class UnivariateRealSolverUtils {                        numIterations, maximumIterations, initial,                        lowerBound, upperBound, a, b, fa, fb);          } -                  return new double[]{a, b};      }"
0,"public class TimePeriodValues extends Series implements Serializable {       * @param index  the index of the time period.       */      private void updateBounds(TimePeriod period, int index) { -                  long start = period.getStart().getTime();          long end = period.getEnd().getTime();          long middle = start + ((end - start) / 2); -          if (this.minStartIndex >= 0) {              long minStart = getDataItem(this.minStartIndex).getPeriod()                  .getStart().getTime(); @@ -270,7 +268,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minStartIndex = index;          } -                  if (this.maxStartIndex >= 0) {              long maxStart = getDataItem(this.maxStartIndex).getPeriod()                  .getStart().getTime(); @@ -281,7 +278,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxStartIndex = index;          } -                  if (this.minMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); @@ -295,11 +291,14 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minMiddleIndex = index;          } -                  if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() -                .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +// buggy code +//             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +//                 .getTime(); +//             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +           long s = getDataItem(this.maxMiddleIndex).getPeriod() +                .getStart().getTime(); +            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) { @@ -309,7 +308,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxMiddleIndex = index;          } -                  if (this.minEndIndex >= 0) {              long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()                  .getTime(); @@ -320,7 +318,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minEndIndex = index;          } -                 if (this.maxEndIndex >= 0) {              long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()                  .getTime(); @@ -331,7 +328,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxEndIndex = index;          } -              }            /**"
0,"public final class MathUtils {       * @return the L<sub>2</sub> distance between the two points       */      public static double distance(int[] p1, int[] p2) { -      int sum = 0; +// buggy code +//       int sum = 0; +//       for (int i = 0; i < p1.length; i++) { +//           final int dp = p1[i] - p2[i]; +     double sum = 0;        for (int i = 0; i < p1.length; i++) { -          final int dp = p1[i] - p2[i]; +          final double dp = p1[i] - p2[i];            sum += dp * dp;        }        return Math.sqrt(sum);"
0,"public abstract class Axis implements Cloneable, Serializable {      protected AxisState drawLabel(String label, Graphics2D g2,               Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,               AxisState state, PlotRenderingInfo plotState) { - -        // it is unlikely that 'state' will be null, but check anyway...          if (state == null) {              throw new IllegalArgumentException(""Null 'state' argument."");          } -                  if ((label == null) || (label.equals(""""))) {              return state;          } -          Font font = getLabelFont();          RectangleInsets insets = getLabelInsets();          g2.setFont(font); @@ -1109,7 +1105,6 @@ public abstract class Axis implements Cloneable, Serializable {          FontMetrics fm = g2.getFontMetrics();          Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);          Shape hotspot = null; -                  if (edge == RectangleEdge.TOP) {              AffineTransform t = AffineTransform.getRotateInstance(                      getLabelAngle(), labelBounds.getCenterX(),  @@ -1166,7 +1161,6 @@ public abstract class Axis implements Cloneable, Serializable {                      + insets.getRight());          }          else if (edge == RectangleEdge.RIGHT) { -              AffineTransform t = AffineTransform.getRotateInstance(                      getLabelAngle() + Math.PI / 2.0,                       labelBounds.getCenterX(), labelBounds.getCenterY()); @@ -1185,18 +1179,24 @@ public abstract class Axis implements Cloneable, Serializable {                      labely - h / 2.0f, w, h);              state.cursorRight(insets.getLeft() + labelBounds.getWidth()                       + insets.getRight()); -          }          if (plotState != null && hotspot != null) {              ChartRenderingInfo owner = plotState.getOwner(); +// buggy code +//                 EntityCollection entities = owner.getEntityCollection(); +//                 if (entities != null) { +//                     entities.add(new AxisLabelEntity(this, hotspot,  +//                             this.labelToolTip, this.labelURL)); +//                 } +           if (owner != null) {                  EntityCollection entities = owner.getEntityCollection();                  if (entities != null) {                      entities.add(new AxisLabelEntity(this, hotspot,                               this.labelToolTip, this.labelURL));                  }              }  +        }          return state; -      }        /**"
0,"public class LightweightMessageFormatter extends AbstractMessageFormatter {    }      private String format(JSError error, boolean warning) { -    // extract source excerpt      SourceExcerptProvider source = getSource();      String sourceExcerpt = source == null ? null :          excerpt.get(              source, error.sourceName, error.lineNumber, excerptFormatter); - -    // formatting the message      StringBuilder b = new StringBuilder();      if (error.sourceName != null) {        b.append(error.sourceName); @@ -80,22 +77,18 @@ public class LightweightMessageFormatter extends AbstractMessageFormatter {        }        b.append("": "");      } -      b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));      b.append("" - ""); -      b.append(error.description);      b.append('\n');      if (sourceExcerpt != null) {        b.append(sourceExcerpt);        b.append('\n');        int charno = error.getCharno(); - -      // padding equal to the excerpt and arrow at the end -      // charno == sourceExpert.length() means something is missing -      // at the end of the line        if (excerpt.equals(LINE) -          && 0 <= charno && charno < sourceExcerpt.length()) { +// buggy code +//           && 0 <= charno && charno < sourceExcerpt.length()) { +         && 0 <= charno && charno <= sourceExcerpt.length()) {          for (int i = 0; i < charno; i++) {            char c = sourceExcerpt.charAt(i);            if (Character.isWhitespace(c)) {"
0,"public class Variance extends AbstractStorelessUnivariateStatistic implements Se       */      public double evaluate(final double[] values, final double[] weights,                             final double mean, final int begin, final int length) { -          double var = Double.NaN; -          if (test(values, weights, begin, length)) {              if (length == 1) {                  var = 0.0; @@ -515,12 +513,12 @@ public class Variance extends AbstractStorelessUnivariateStatistic implements Se                      accum += weights[i] * (dev * dev);                      accum2 += weights[i] * dev;                  } -                  double sumWts = 0; -                for (int i = 0; i < weights.length; i++) { +// buggy code +//                 for (int i = 0; i < weights.length; i++) { +               for (int i = begin; i < (begin + length); i++) {                      sumWts += weights[i];                  } -                  if (isBiasCorrected) {                      var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);                  } else {"
0,"public class SimplexSolver extends AbstractLinearOptimizer {          for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {              final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);              final double entry = tableau.getEntry(i, col); -            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +// buggy code +//             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { +           if (MathUtils.compareTo(entry, 0, epsilon) > 0) {                  final double ratio = rhs / entry;                  if (ratio < minRatio) {                      minRatio = ratio;"
0,"public class GaussianFitter extends CurveFitter {       */      public double[] fit() {          final double[] guess = (new ParameterGuesser(getObservations())).guess(); -        return fit(new Gaussian.Parametric(), guess); +// buggy code +//         return fit(new Gaussian.Parametric(), guess); +       return fit(guess);      }        /**"
0,"public class FastDateParser implements DateParser, Serializable {       * @return The <code>StringBuilder</code>       */      private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { -        boolean wasWhite= false; +// buggy code +//         boolean wasWhite= false; +//         for(int i= 0; i<value.length(); ++i) { +//             char c= value.charAt(i); +//             if(Character.isWhitespace(c)) { +//                 if(!wasWhite) { +//                     wasWhite= true; +//                     regex.append(""\\s*+""); +//                 } +//                 continue; +//             } +//             wasWhite= false;         for(int i= 0; i<value.length(); ++i) {              char c= value.charAt(i); -            if(Character.isWhitespace(c)) { -                if(!wasWhite) { -                    wasWhite= true; -                    regex.append(""\\s*+""); -                } -                continue; -            } -            wasWhite= false;              switch(c) {              case '\'':                  if(unquote) {"
0,public class ShapeUtilities {              return false;          }          PathIterator iterator1 = p1.getPathIterator(null); -        PathIterator iterator2 = p1.getPathIterator(null); +// buggy code +//         PathIterator iterator2 = p1.getPathIterator(null); +       PathIterator iterator2 +                = p2.getPathIterator(null);          double[] d1 = new double[6];          double[] d2 = new double[6];          boolean done = iterator1.isDone() && iterator2.isDone();
0,"public class TimeSeries extends Series implements Cloneable, Serializable {       */      public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)          throws CloneNotSupportedException { -          if (start == null) {              throw new IllegalArgumentException(""Null 'start' argument."");          } @@ -933,15 +932,17 @@ public class TimeSeries extends Series implements Cloneable, Serializable {          if (startIndex < 0) {              startIndex = -(startIndex + 1);              if (startIndex == this.data.size()) { -                emptyRange = true;  // start is after last data item +                emptyRange = true;                }          }          int endIndex = getIndex(end); -        if (endIndex < 0) {             // end period is not in original series -            endIndex = -(endIndex + 1); // this is first item AFTER end period -            endIndex = endIndex - 1;    // so this is last item BEFORE end -        }          if (endIndex < 0) {              +            endIndex = -(endIndex + 1);  +            endIndex = endIndex - 1;     +        } +// buggy code +//         if (endIndex < 0) { +       if ((endIndex < 0) || (startIndex > endIndex)) {              emptyRange = true;          }          if (emptyRange) { @@ -952,7 +953,6 @@ public class TimeSeries extends Series implements Cloneable, Serializable {          else {              return createCopy(startIndex, endIndex);          } -      }        /**"
0,"public class PearsonsCorrelation {                  } else {                      double r = correlationMatrix.getEntry(i, j);                      double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); -                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); +// buggy code +//                     out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); +                   out[i][j] = 2 * tDistribution.cumulativeProbability(-t);                  }              }          }"
0,"public class Week extends RegularTimePeriod implements Serializable {       * @deprecated As of 1.0.7, use {@link #Week(Date, TimeZone, Locale)}.       */      public Week(Date time, TimeZone zone) { -        // defer argument checking... -        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); +// buggy code +//         this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); +       this(time, zone, Locale.getDefault());      }        /**"
0,"class CodeGenerator {          case '\\': sb.append(backslashEscape); break;          case '\""': sb.append(doublequoteEscape); break;          case '\'': sb.append(singlequoteEscape); break; -        case '>':                       // Break --> into --\> or ]]> into ]]\> +        case '>':                                   if (i >= 2 &&                ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||                 (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { @@ -1012,12 +1012,8 @@ class CodeGenerator {            }            break;          case '<': -          // Break </script into <\/script            final String END_SCRIPT = ""/script""; - -          // Break <!-- into <\!--            final String START_COMMENT = ""!--""; -            if (s.regionMatches(true, i + 1, END_SCRIPT, 0,                                END_SCRIPT.length())) {              sb.append(""<\\""); @@ -1029,25 +1025,18 @@ class CodeGenerator {            }            break;          default: -          // If we're given an outputCharsetEncoder, then check if the -          //  character can be represented in this character set.            if (outputCharsetEncoder != null) {              if (outputCharsetEncoder.canEncode(c)) {                sb.append(c);              } else { -              // Unicode-escape the character.                appendHexJavaScriptRepresentation(sb, c);              }            } else { -            // No charsetEncoder provided - pass straight latin characters -            // through, and escape the rest.  Doing the explicit character -            // check is measurably faster than using the CharsetEncoder. -            if (c > 0x1f && c <= 0x7f) { +// buggy code +//             if (c > 0x1f && c <= 0x7f) { +           if (c > 0x1f && c < 0x7f) {                sb.append(c);              } else { -              // Other characters can be misinterpreted by some js parsers, -              // or perhaps mangled by proxies along the way, -              // so we play it safe and unicode escape them.                appendHexJavaScriptRepresentation(sb, c);              }            }"
0,public class ClassUtils {          }          Class<?>[] classes = new Class[array.length];          for (int i = 0; i < array.length; i++) { -            classes[i] = array[i].getClass(); +// buggy code +//             classes[i] = array[i].getClass(); +           classes[i] = array[i] == null ? null : array[i].getClass();          }          return classes;      }
0,"public class EigenDecompositionImpl implements EigenDecomposition {       */      private boolean flipIfWarranted(final int n, final int step) {          if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { -            // flip array -            int j = 4 * n - 1; +// buggy code +//             int j = 4 * n - 1; +           int j = 4 * (n - 1);              for (int i = 0; i < j; i += 4) {                  for (int k = 0; k < 4; k += step) {                      final double tmp = work[i + k];"
0,"public class TimeSeries extends Series implements Cloneable, Serializable {       */      public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)          throws CloneNotSupportedException { -          if (start == null) {              throw new IllegalArgumentException(""Null 'start' argument."");          } @@ -933,15 +932,17 @@ public class TimeSeries extends Series implements Cloneable, Serializable {          if (startIndex < 0) {              startIndex = -(startIndex + 1);              if (startIndex == this.data.size()) { -                emptyRange = true;  // start is after last data item +                emptyRange = true;                }          }          int endIndex = getIndex(end); -        if (endIndex < 0) {             // end period is not in original series -            endIndex = -(endIndex + 1); // this is first item AFTER end period -            endIndex = endIndex - 1;    // so this is last item BEFORE end -        }          if (endIndex < 0) {              +            endIndex = -(endIndex + 1);  +            endIndex = endIndex - 1;     +        } +// buggy code +//         if (endIndex < 0) { +       if (endIndex < 0 || startIndex > endIndex) {               emptyRange = true;          }          if (emptyRange) { @@ -952,7 +953,6 @@ public class TimeSeries extends Series implements Cloneable, Serializable {          else {              return createCopy(startIndex, endIndex);          } -      }        /**"
0,"public class Complex implements FieldElement<Complex>, Serializable  {      public Complex add(Complex rhs)          throws NullArgumentException {          MathUtils.checkNotNull(rhs); +// buggy code +//  +       if (isNaN() || rhs.isNaN()) { +            return NaN; +        }          return createComplex(real + rhs.getReal(),              imaginary + rhs.getImaginary());      }"
0,public abstract class AbstractCategoryItemRenderer extends AbstractRenderer          }          int index = this.plot.getIndexOf(this);          CategoryDataset dataset = this.plot.getDataset(index); -        if (dataset != null) { +// buggy code +//         if (dataset != null) { +       if (dataset == null) {              return result;          }          int seriesCount = dataset.getRowCount();
0,"public abstract class Axis implements Cloneable, Serializable {      protected AxisState drawLabel(String label, Graphics2D g2,               Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,               AxisState state, PlotRenderingInfo plotState) { - -        // it is unlikely that 'state' will be null, but check anyway...          if (state == null) {              throw new IllegalArgumentException(""Null 'state' argument."");          } -                  if ((label == null) || (label.equals(""""))) {              return state;          } -          Font font = getLabelFont();          RectangleInsets insets = getLabelInsets();          g2.setFont(font); @@ -1109,7 +1105,6 @@ public abstract class Axis implements Cloneable, Serializable {          FontMetrics fm = g2.getFontMetrics();          Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);          Shape hotspot = null; -                  if (edge == RectangleEdge.TOP) {              AffineTransform t = AffineTransform.getRotateInstance(                      getLabelAngle(), labelBounds.getCenterX(),  @@ -1166,7 +1161,6 @@ public abstract class Axis implements Cloneable, Serializable {                      + insets.getRight());          }          else if (edge == RectangleEdge.RIGHT) { -              AffineTransform t = AffineTransform.getRotateInstance(                      getLabelAngle() + Math.PI / 2.0,                       labelBounds.getCenterX(), labelBounds.getCenterY()); @@ -1185,18 +1179,24 @@ public abstract class Axis implements Cloneable, Serializable {                      labely - h / 2.0f, w, h);              state.cursorRight(insets.getLeft() + labelBounds.getWidth()                       + insets.getRight()); -          }          if (plotState != null && hotspot != null) {              ChartRenderingInfo owner = plotState.getOwner(); +// buggy code +//                 EntityCollection entities = owner.getEntityCollection(); +//                 if (entities != null) { +//                     entities.add(new AxisLabelEntity(this, hotspot,  +//                             this.labelToolTip, this.labelURL)); +//                 } +           if (owner != null) {                  EntityCollection entities = owner.getEntityCollection();                  if (entities != null) {                      entities.add(new AxisLabelEntity(this, hotspot,                           this.labelToolTip, this.labelURL));                  }              } +        }          return state; -      }        /**"
0,"public class BisectionSolver extends UnivariateRealSolverImpl {      /** {@inheritDoc} */      public double solve(final UnivariateRealFunction f, double min, double max, double initial)          throws MaxIterationsExceededException, FunctionEvaluationException { -        return solve(min, max); +// buggy code +//         return solve(min, max); +       return solve(f, min, max);      }        /** {@inheritDoc} */"
0,"public class FastMath {       * @return b if a is lesser or equal to b, a otherwise       */      public static float max(final float a, final float b) { -        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +// buggy code +//         return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); +       return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);      }        /** Compute the maximum of two values"
0,public class ExtendedMessageFormat extends MessageFormat {          int start = pos.getIndex();          char[] c = pattern.toCharArray();          if (escapingOn && c[start] == QUOTE) { +// buggy code +//  +           next(pos);              return appendTo == null ? null : appendTo.append(QUOTE);          }          int lastHold = start;
0,"public class MultivariateNormalDistribution          if (vals.length != dim) {              throw new DimensionMismatchException(vals.length, dim);          } - -        return FastMath.pow(2 * FastMath.PI, -dim / 2) * +// buggy code +//         return FastMath.pow(2 * FastMath.PI, -dim / 2) * +       return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *              FastMath.pow(covarianceMatrixDeterminant, -0.5) *              getExponentTerm(vals);      }"
0,"public class DiscreteDistribution<T> {       * @throws NotStrictlyPositiveException if {@code sampleSize} is not       * positive.       */ -    public T[] sample(int sampleSize) throws NotStrictlyPositiveException { +// buggy code +//     public T[] sample(int sampleSize) throws NotStrictlyPositiveException { +//         if (sampleSize <= 0) { +//             throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES, +//                     sampleSize); +//         } +//         final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); +   public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {          if (sampleSize <= 0) {              throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,                      sampleSize);          } - -        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize); - +        final Object[] out = new Object[sampleSize];          for (int i = 0; i < sampleSize; i++) {              out[i] = sample();          } -          return out; -      }    }"
0,"class FunctionInjector {      if (!isDirectCallNodeReplacementPossible(fnNode)) {        return CanInlineResult.NO;      } -      Node block = fnNode.getLastChild(); - -    boolean hasSideEffects = false; -    if (block.hasChildren()) { -      Preconditions.checkState(block.hasOneChild()); -      Node stmt = block.getFirstChild(); -      if (stmt.isReturn()) { -        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); -      } -    } -    // CALL NODE: [ NAME, ARG1, ARG2, ... ] +// buggy code +//     boolean hasSideEffects = false; +//     if (block.hasChildren()) { +//       Preconditions.checkState(block.hasOneChild()); +//       Node stmt = block.getFirstChild(); +//       if (stmt.isReturn()) { +//         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler); +//       } +//     } +//     Node cArg = callNode.getFirstChild().getNext(); +//     if (!callNode.getFirstChild().isName()) { +//       if (NodeUtil.isFunctionObjectCall(callNode)) { +//         if (cArg == null || !cArg.isThis()) { +//           return CanInlineResult.NO; +//         } +//         cArg = cArg.getNext(); +//       } else { +//         Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode)); +//       } +//     } +//     Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild(); +//     while (cArg != null || fnParam != null) { +//       if (fnParam != null) { +//         if (cArg != null) { +//           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { +//             return CanInlineResult.NO; +//           }     Node cArg = callNode.getFirstChild().getNext(); - -    // Functions called via 'call' and 'apply' have a this-object as -    // the first parameter, but this is not part of the called function's -    // parameter list.      if (!callNode.getFirstChild().isName()) {        if (NodeUtil.isFunctionObjectCall(callNode)) { -        // TODO(johnlenz): Support replace this with a value.          if (cArg == null || !cArg.isThis()) {            return CanInlineResult.NO;          }          cArg = cArg.getNext();        } else { -        // "".apply"" call should be filtered before this.          Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));        }      } - -    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]      Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();      while (cArg != null || fnParam != null) { -      // For each named parameter check if a mutable argument use more than one.        if (fnParam != null) {          if (cArg != null) { -          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) { -            return CanInlineResult.NO; -          } -          // Check for arguments that are evaluated more than once. -          // Note: Unlike block inlining, there it is not possible that a -          // parameter reference will be in a loop.            if (NodeUtil.mayEffectMutableState(cArg, compiler)                && NodeUtil.getNameReferenceCount(                    block, fnParam.getString()) > 1) {              return CanInlineResult.NO;            }          } - -        // Move to the next name.          fnParam = fnParam.getNext();        } - -      // For every call argument check for side-effects, even if there -      // isn't a named parameter to match.        if (cArg != null) {          if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {            return CanInlineResult.NO; @@ -753,7 +749,6 @@ class FunctionInjector {          cArg = cArg.getNext();        }      } -      return CanInlineResult.YES;    }"
0,"public class XYPlot extends Plot implements ValueAxisPlot, Pannable,       * @return The range.       */      public Range getDataRange(ValueAxis axis) { -          Range result = null;          List mappedDatasets = new ArrayList();          List includedAnnotations = new ArrayList();          boolean isDomainAxis = true; - -        // is it a domain axis?          int domainIndex = getDomainAxisIndex(axis);          if (domainIndex >= 0) {              isDomainAxis = true;              mappedDatasets.addAll(getDatasetsMappedToDomainAxis(                      new Integer(domainIndex)));              if (domainIndex == 0) { -                // grab the plot's annotations                  Iterator iterator = this.annotations.iterator();                  while (iterator.hasNext()) {                      XYAnnotation annotation = (XYAnnotation) iterator.next(); @@ -4446,8 +4442,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } - -        // or is it a range axis?          int rangeIndex = getRangeAxisIndex(axis);          if (rangeIndex >= 0) {              isDomainAxis = false; @@ -4463,9 +4457,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } - -        // iterate through the datasets that map to the axis and get the union -        // of the ranges.          Iterator iterator = mappedDatasets.iterator();          while (iterator.hasNext()) {              XYDataset d = (XYDataset) iterator.next(); @@ -4489,7 +4480,16 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                                  DatasetUtilities.findRangeBounds(d));                      }                  } -                 +// buggy code +//                     Collection c = r.getAnnotations(); +//                     Iterator i = c.iterator(); +//                     while (i.hasNext()) { +//                         XYAnnotation a = (XYAnnotation) i.next(); +//                         if (a instanceof XYAnnotationBoundsInfo) { +//                             includedAnnotations.add(a); +//                         } +//                     } +               if (r != null) {                      Collection c = r.getAnnotations();                      Iterator i = c.iterator();                      while (i.hasNext()) { @@ -4500,7 +4500,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                      }                  }                              } - +        }          Iterator it = includedAnnotations.iterator();          while (it.hasNext()) {              XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); @@ -4513,9 +4513,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } -          return result; -      }        /**"
0,"public abstract class Axis implements Cloneable, Serializable {      protected AxisState drawLabel(String label, Graphics2D g2,               Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,               AxisState state, PlotRenderingInfo plotState) { - -        // it is unlikely that 'state' will be null, but check anyway...          if (state == null) {              throw new IllegalArgumentException(""Null 'state' argument."");          } -                  if ((label == null) || (label.equals(""""))) {              return state;          } -          Font font = getLabelFont();          RectangleInsets insets = getLabelInsets();          g2.setFont(font); @@ -1109,7 +1105,6 @@ public abstract class Axis implements Cloneable, Serializable {          FontMetrics fm = g2.getFontMetrics();          Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);          Shape hotspot = null; -                  if (edge == RectangleEdge.TOP) {              AffineTransform t = AffineTransform.getRotateInstance(                      getLabelAngle(), labelBounds.getCenterX(),  @@ -1166,7 +1161,6 @@ public abstract class Axis implements Cloneable, Serializable {                      + insets.getRight());          }          else if (edge == RectangleEdge.RIGHT) { -              AffineTransform t = AffineTransform.getRotateInstance(                      getLabelAngle() + Math.PI / 2.0,                       labelBounds.getCenterX(), labelBounds.getCenterY()); @@ -1185,18 +1179,24 @@ public abstract class Axis implements Cloneable, Serializable {                      labely - h / 2.0f, w, h);              state.cursorRight(insets.getLeft() + labelBounds.getWidth()                       + insets.getRight()); -          }          if (plotState != null && hotspot != null) {              ChartRenderingInfo owner = plotState.getOwner(); +// buggy code +//                 EntityCollection entities = owner.getEntityCollection(); +//                 if (entities != null) { +//                     entities.add(new AxisLabelEntity(this, hotspot,  +//                             this.labelToolTip, this.labelURL)); +//                 } +           if (owner != null) {                  EntityCollection entities = owner.getEntityCollection();                  if (entities != null) {                      entities.add(new AxisLabelEntity(this, hotspot,                              this.labelToolTip, this.labelURL));                  }              } +        }          return state; -      }        /**"
0,"public class TimeSeries extends Series implements Cloneable, Serializable {       */      public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)          throws CloneNotSupportedException { -          if (start == null) {              throw new IllegalArgumentException(""Null 'start' argument."");          } @@ -933,15 +932,17 @@ public class TimeSeries extends Series implements Cloneable, Serializable {          if (startIndex < 0) {              startIndex = -(startIndex + 1);              if (startIndex == this.data.size()) { -                emptyRange = true;  // start is after last data item +                emptyRange = true;                }          }          int endIndex = getIndex(end); -        if (endIndex < 0) {             // end period is not in original series -            endIndex = -(endIndex + 1); // this is first item AFTER end period -            endIndex = endIndex - 1;    // so this is last item BEFORE end -        }          if (endIndex < 0) {              +            endIndex = -(endIndex + 1);  +            endIndex = endIndex - 1;     +        } +// buggy code +//         if (endIndex < 0) { +       if (endIndex < 0 || startIndex > endIndex) {              emptyRange = true;          }          if (emptyRange) { @@ -952,7 +953,6 @@ public class TimeSeries extends Series implements Cloneable, Serializable {          else {              return createCopy(startIndex, endIndex);          } -      }        /**"
0,"public class MultiplePiePlot extends Plot implements Cloneable, Serializable {       */      public MultiplePiePlot(CategoryDataset dataset) {          super(); -        this.dataset = dataset; +// buggy code +//         this.dataset = dataset; +       setDataset(dataset);          PiePlot piePlot = new PiePlot(null);          this.pieChart = new JFreeChart(piePlot);          this.pieChart.removeLegend();"
0,"public abstract class Axis implements Cloneable, Serializable {      protected AxisState drawLabel(String label, Graphics2D g2,               Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge,               AxisState state, PlotRenderingInfo plotState) { - -        // it is unlikely that 'state' will be null, but check anyway...          if (state == null) {              throw new IllegalArgumentException(""Null 'state' argument."");          } -                  if ((label == null) || (label.equals(""""))) {              return state;          } -          Font font = getLabelFont();          RectangleInsets insets = getLabelInsets();          g2.setFont(font); @@ -1109,7 +1105,6 @@ public abstract class Axis implements Cloneable, Serializable {          FontMetrics fm = g2.getFontMetrics();          Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);          Shape hotspot = null; -                  if (edge == RectangleEdge.TOP) {              AffineTransform t = AffineTransform.getRotateInstance(                      getLabelAngle(), labelBounds.getCenterX(),  @@ -1166,7 +1161,6 @@ public abstract class Axis implements Cloneable, Serializable {                      + insets.getRight());          }          else if (edge == RectangleEdge.RIGHT) { -              AffineTransform t = AffineTransform.getRotateInstance(                      getLabelAngle() + Math.PI / 2.0,                       labelBounds.getCenterX(), labelBounds.getCenterY()); @@ -1185,18 +1179,24 @@ public abstract class Axis implements Cloneable, Serializable {                      labely - h / 2.0f, w, h);              state.cursorRight(insets.getLeft() + labelBounds.getWidth()                       + insets.getRight()); -          }          if (plotState != null && hotspot != null) {              ChartRenderingInfo owner = plotState.getOwner(); +// buggy code +//                 EntityCollection entities = owner.getEntityCollection(); +//                 if (entities != null) { +//                     entities.add(new AxisLabelEntity(this, hotspot,  +//                             this.labelToolTip, this.labelURL)); +//                 } +           if (owner != null) {                   EntityCollection entities = owner.getEntityCollection();                  if (entities != null) {                      entities.add(new AxisLabelEntity(this, hotspot,                               this.labelToolTip, this.labelURL));                  }              } +        }          return state; -      }        /**"
0,"class PeepholeOptimizationsPass    }      private void traverse(Node node) { -    // The goal here is to avoid retraversing -    // the entire AST to catch newly created opportunities. -    // So we track whether a ""unit of code"" has changed, -    // and revisit immediately.      if (!shouldVisit(node)) {        return;      } -      int visits = 0;      do {        Node c = node.getFirstChild();        while(c != null) { -        traverse(c); +// buggy code +//         traverse(c); +//         Node next = c.getNext();       Node next = c.getNext(); +      traverse(c);          c = next;        } -        visit(node);        visits++; -        Preconditions.checkState(visits < 10000, ""too many interations"");      } while (shouldRetraverse(node)); -      exitNode(node);    }"
0,"public abstract class BaseSecantSolver        /** {@inheritDoc} */      protected final double doSolve() { -        // Get initial solution          double x0 = getMin();          double x1 = getMax();          double f0 = computeObjectiveValue(x0);          double f1 = computeObjectiveValue(x1); - -        // If one of the bounds is the exact root, return it. Since these are -        // not under-approximations or over-approximations, we can return them -        // regardless of the allowed solutions.          if (f0 == 0.0) {              return x0;          }          if (f1 == 0.0) {              return x1;          } - -        // Verify bracketing of initial solution.          verifyBracketing(x0, x1); - -        // Get accuracies.          final double ftol = getFunctionValueAccuracy();          final double atol = getAbsoluteAccuracy();          final double rtol = getRelativeAccuracy(); - -        // Keep track of inverted intervals, meaning that the left bound is -        // larger than the right bound.          boolean inverted = false; - -        // Keep finding better approximations.          while (true) { -            // Calculate the next approximation.              final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));              final double fx = computeObjectiveValue(x); - -            // If the new approximation is the exact root, return it. Since -            // this is not an under-approximation or an over-approximation, -            // we can return it regardless of the allowed solutions.              if (fx == 0.0) {                  return x;              } - -            // Update the bounds with the new approximation.              if (f1 * fx < 0) { -                // The value of x1 has switched to the other bound, thus inverting -                // the interval.                  x0 = x1;                  f0 = f1;                  inverted = !inverted; @@ -183,24 +160,18 @@ public abstract class BaseSecantSolver                      f0 *= f1 / (f1 + fx);                      break;                  case REGULA_FALSI: -                    // Nothing. -                    if (x == x1) { -                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); -                        f0 = computeObjectiveValue(x0); -                    } +// buggy code +//                     if (x == x1) { +//                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); +//                         f0 = computeObjectiveValue(x0); +//                     }                      break;                  default: -                    // Should never happen.                      throw new MathInternalError();                  }              } -            // Update from [x0, x1] to [x0, x].              x1 = x;              f1 = fx; - -            // If the function value of the last approximation is too small, -            // given the function value accuracy, then we can't get closer to -            // the root than we already are.              if (FastMath.abs(f1) <= ftol) {                  switch (allowed) {                  case ANY_SIDE: @@ -229,9 +200,6 @@ public abstract class BaseSecantSolver                      throw new MathInternalError();                  }              } - -            // If the current interval is within the given accuracies, we -            // are satisfied with the current approximation.              if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),                                                       atol)) {                  switch (allowed) {"
0,"public class TimePeriodValues extends Series implements Serializable {       * @param index  the index of the time period.       */      private void updateBounds(TimePeriod period, int index) { -                  long start = period.getStart().getTime();          long end = period.getEnd().getTime();          long middle = start + ((end - start) / 2); -          if (this.minStartIndex >= 0) {              long minStart = getDataItem(this.minStartIndex).getPeriod()                  .getStart().getTime(); @@ -270,7 +268,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minStartIndex = index;          } -                  if (this.maxStartIndex >= 0) {              long maxStart = getDataItem(this.maxStartIndex).getPeriod()                  .getStart().getTime(); @@ -281,7 +278,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxStartIndex = index;          } -                  if (this.minMiddleIndex >= 0) {              long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()                  .getTime(); @@ -295,11 +291,14 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minMiddleIndex = index;          } -                  if (this.maxMiddleIndex >= 0) { -            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +// buggy code +//             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart() +//                 .getTime(); +//             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()                   .getTime(); -            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd() +             long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()                  .getTime();              long maxMiddle = s + (e - s) / 2;              if (middle > maxMiddle) { @@ -309,7 +308,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxMiddleIndex = index;          } -                  if (this.minEndIndex >= 0) {              long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()                  .getTime(); @@ -320,7 +318,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.minEndIndex = index;          } -                 if (this.maxEndIndex >= 0) {              long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()                  .getTime(); @@ -331,7 +328,6 @@ public class TimePeriodValues extends Series implements Serializable {          else {              this.maxEndIndex = index;          } -              }            /**"
0,"public class BooleanUtils {       * @return the boolean value of the string, <code>false</code> if no match       */      public static boolean toBoolean(String str) { -        // Previously used equalsIgnoreCase, which was fast for interned 'true'. -        // Non interned 'true' matched 15 times slower. -        //  -        // Optimisation provides same performance as before for interned 'true'. -        // Similar performance for null, 'false', and other strings not length 2/3/4. -        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.          if (str == ""true"") {              return true;          } @@ -679,6 +673,9 @@ public class BooleanUtils {                          (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&                          (str.charAt(2) == 'S' || str.charAt(2) == 's');                  } +// buggy code +//  +               return false;              }              case 4: {                  char ch = str.charAt(0);"
0,"public class XYPlot extends Plot implements ValueAxisPlot, Pannable,       * @return The range.       */      public Range getDataRange(ValueAxis axis) { -          Range result = null;          List mappedDatasets = new ArrayList();          List includedAnnotations = new ArrayList();          boolean isDomainAxis = true; - -        // is it a domain axis?          int domainIndex = getDomainAxisIndex(axis);          if (domainIndex >= 0) {              isDomainAxis = true;              mappedDatasets.addAll(getDatasetsMappedToDomainAxis(                      new Integer(domainIndex)));              if (domainIndex == 0) { -                // grab the plot's annotations                  Iterator iterator = this.annotations.iterator();                  while (iterator.hasNext()) {                      XYAnnotation annotation = (XYAnnotation) iterator.next(); @@ -4446,8 +4442,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } - -        // or is it a range axis?          int rangeIndex = getRangeAxisIndex(axis);          if (rangeIndex >= 0) {              isDomainAxis = false; @@ -4463,9 +4457,6 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } - -        // iterate through the datasets that map to the axis and get the union -        // of the ranges.          Iterator iterator = mappedDatasets.iterator();          while (iterator.hasNext()) {              XYDataset d = (XYDataset) iterator.next(); @@ -4489,7 +4480,16 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                                  DatasetUtilities.findRangeBounds(d));                      }                  } -                 +// buggy code +//                     Collection c = r.getAnnotations(); +//                     Iterator i = c.iterator(); +//                     while (i.hasNext()) { +//                         XYAnnotation a = (XYAnnotation) i.next(); +//                         if (a instanceof XYAnnotationBoundsInfo) { +//                             includedAnnotations.add(a); +//                         } +//                     } +               if (r != null) {                      Collection c = r.getAnnotations();                      Iterator i = c.iterator();                      while (i.hasNext()) { @@ -4500,7 +4500,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                      }                  }               } - +        }          Iterator it = includedAnnotations.iterator();          while (it.hasNext()) {              XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); @@ -4513,9 +4513,7 @@ public class XYPlot extends Plot implements ValueAxisPlot, Pannable,                  }              }          } -          return result; -      }        /**"
0,public class ExtendedMessageFormat extends MessageFormat {          int start = pos.getIndex();          char[] c = pattern.toCharArray();          if (escapingOn && c[start] == QUOTE) { +// buggy code +//  +           next(pos);               return appendTo == null ? null : appendTo.append(QUOTE);          }          int lastHold = start;
0,public class ClosureCodingConvention extends DefaultCodingConvention {          String qualifiedName = callee.getQualifiedName();          if (functionName.equals(qualifiedName)) {            Node target = callee.getNext(); -          if (target != null) { +// buggy code +//           if (target != null) { +         if (target != null && target.getType() == Token.STRING) {              className = target.getString();            }          }
0,"public class ArgumentMatchingTool {      }        private boolean toStringEquals(Matcher m, Object arg) { -        return StringDescription.toString(m).equals(arg.toString()); +// buggy code +//         return StringDescription.toString(m).equals(arg.toString()); +       return StringDescription.toString(m).equals(String.valueOf(arg));      }  }"
0,"class PeepholeOptimizationsPass    }      private void traverse(Node node) { -    // The goal here is to avoid retraversing -    // the entire AST to catch newly created opportunities. -    // So we track whether a ""unit of code"" has changed, -    // and revisit immediately.      if (!shouldVisit(node)) {        return;      } -      int visits = 0;      do {        Node c = node.getFirstChild();        while(c != null) { -        traverse(c); +// buggy code +//         traverse(c); +//         Node next = c.getNext();         Node next = c.getNext(); +        traverse(c);          c = next;        } -        visit(node);        visits++; -        Preconditions.checkState(visits < 10000, ""too many interations"");      } while (shouldRetraverse(node)); -      exitNode(node);    }"

[
    {
        "PatchId": "Chart_4_repairllama-ir4_patch_8.diff",
        "BugId": "Chart_4",
        "PatchedMethods": [
            {
                "DevIntention": "get|data|range",
                "OrgCode": "public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                // grab the plot's annotations\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n                \n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n            }\n        }\n\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n\n        return result;\n\n    }",
                "PatCode": "public Range getDataRange(ValueAxis axis) {\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n// buggy code\n//                     Collection c = r.getAnnotations();\n//                     Iterator i = c.iterator();\n//                     while (i.hasNext()) {\n//                         XYAnnotation a = (XYAnnotation) i.next();\n//                         if (a instanceof XYAnnotationBoundsInfo) {\n//                             includedAnnotations.add(a);\n//                         }\n//                     }\n               if (r != null) {\n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n            }\n        }\n        }\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n        return result;\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_11_repairllama-ir4_patch_8.diff",
        "BugId": "Chart_11",
        "PatchedMethods": [
            {
                "DevIntention": "equal",
                "OrgCode": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p1.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }",
                "PatCode": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n// buggy code\n//         PathIterator iterator2 = p1.getPathIterator(null);\n       PathIterator iterator2\n                = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_9_repairllama-ir4_patch_9.diff",
        "BugId": "Chart_9",
        "PatchedMethods": [
            {
                "DevIntention": "create|copy",
                "OrgCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if (endIndex < 0) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }",
                "PatCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {\n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n// buggy code\n//         if (endIndex < 0) {\n       if (endIndex < 0 || startIndex > endIndex) { \n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param object  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                s.getDomainDescription())) {\n            return false;\n        }\n\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                s.getRangeDescription())) {\n            return false;\n        }\n\n        if (!getClass().equals(s.getClass())) {\n            return false;\n        }\n\n        if (getMaximumItemAge() != s.getMaximumItemAge()) {\n            return false;\n        }\n\n        if (getMaximumItemCount() != s.getMaximumItemCount()) {\n            return false;\n        }\n\n        int count = getItemCount();\n        if (count != s.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(s.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Chart_7_repairllama-ir4_patch_9.diff",
        "BugId": "Chart_7",
        "PatchedMethods": [
            {
                "DevIntention": "update|bounds",
                "OrgCode": "private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }",
                "PatCode": "private void updateBounds(TimePeriod period, int index) {\n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        if (this.maxMiddleIndex >= 0) {\n// buggy code\n//             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n//                 .getTime();\n//             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n           long s = getDataItem(this.maxMiddleIndex).getPeriod()\n                .getStart().getTime();\n            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_26_repairllama-ir4_patch_3.diff",
        "BugId": "Chart_26",
        "PatchedMethods": [
            {
                "DevIntention": "draw|label",
                "OrgCode": "protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n\n        // it is unlikely that 'state' will be null, but check anyway...\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        \n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        \n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        return state;\n\n    }",
                "PatCode": "protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n// buggy code\n//                 EntityCollection entities = owner.getEntityCollection();\n//                 if (entities != null) {\n//                     entities.add(new AxisLabelEntity(this, hotspot, \n//                             this.labelToolTip, this.labelURL));\n//                 }\n           if (owner != null) { \n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        }\n        return state;\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_59_repairllama-ir4_patch_2.diff",
        "BugId": "Lang_59",
        "PatchedMethods": [
            {
                "DevIntention": "append|fixed|width|pad|right",
                "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }",
                "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n// buggy code\n//                 str.getChars(0, strLen, buffer, size);\n               str.getChars(0, width, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_41_repairllama-ir4_patch_5.diff",
        "BugId": "Math_41",
        "PatchedMethods": [
            {
                "DevIntention": "evaluate",
                "OrgCode": "public double evaluate(final double[] values, final double[] weights,\n                           final double mean, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, weights, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += weights[i] * (dev * dev);\n                    accum2 += weights[i] * dev;\n                }\n\n                double sumWts = 0;\n                for (int i = 0; i < weights.length; i++) {\n                    sumWts += weights[i];\n                }\n\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n                }\n            }\n        }\n        return var;\n    }",
                "PatCode": "public double evaluate(final double[] values, final double[] weights,\n                           final double mean, final int begin, final int length) {\n        double var = Double.NaN;\n        if (test(values, weights, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += weights[i] * (dev * dev);\n                    accum2 += weights[i] * dev;\n                }\n                double sumWts = 0;\n// buggy code\n//                 for (int i = 0; i < weights.length; i++) {\n               for (int i = begin; i < begin+length; i++) {\n                    sumWts += weights[i];\n                }\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n                }\n            }\n        }\n        return var;\n    }\n\n    /**\n     * <p>Returns the weighted variance of the values in the input array, using\n     * the precomputed weighted mean value.</p>\n     * <p>\n     * Uses the formula <pre>\n     *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n     * </pre></p>\n     * <p>\n     * The formula used assumes that the supplied mean value is the weighted arithmetic\n     * mean of the sample data, not a known population parameter. This method\n     * is supplied only to save computation when the mean has already been\n     * computed.</p>\n     * <p>\n     * This formula will not return the same result as the unweighted variance when all\n     * weights are equal, unless all weights are equal to 1. The formula assumes that\n     * weights are to be treated as \"expansion values,\" as will be the case if for example\n     * the weights represent frequency counts. To normalize weights so that the denominator\n     * in the variance computation equals the length of the input vector minus one, use <pre>\n     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>\n     * </pre>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n     * <ul><li>the values array is null</li>\n     *     <li>the weights array is null</li>\n     *     <li>the weights array does not have the same length as the values array</li>\n     *     <li>the weights array contains one or more infinite values</li>\n     *     <li>the weights array contains one or more NaN values</li>\n     *     <li>the weights array contains negative values</li>\n     * </ul></p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     *\n     * @param values the input array\n     * @param weights the weights array\n     * @param mean the precomputed weighted mean value\n     * @return the variance of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights, final double mean) {\n        return evaluate(values, weights, mean, 0, values.length);\n    }\n\n    /**\n     * @return Returns the isBiasCorrected.\n     */\n    public boolean isBiasCorrected() {\n        return isBiasCorrected;\n    }\n\n    /**\n     * @param biasCorrected The isBiasCorrected to set.\n     */\n    public void setBiasCorrected(boolean biasCorrected) {\n        this.isBiasCorrected = biasCorrected;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Variance copy() {\n        Variance result = new Variance();\n        copy(this, result);\n        return result;\n    }\n\n    /**\n     * Copies source to dest.\n     * <p>Neither source nor dest can be null.</p>\n     *\n     * @param source Variance to copy\n     * @param dest Variance to copy to\n     * @throws NullArgumentException if either source or dest is null\n     */\n    public static void copy(Variance source, Variance dest)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(source);\n        MathUtils.checkNotNull(dest);\n        dest.setData(source.getDataRef());\n        dest.moment = source.moment.copy();\n        dest.isBiasCorrected = source.isBiasCorrected;\n        dest.incMoment = source.incMoment;\n    }\n}"
            }
        ]
    },
    {
        "PatchId": "Math_11_repairllama-ir4_patch_0.diff",
        "BugId": "Math_11",
        "PatchedMethods": [
            {
                "DevIntention": "density",
                "OrgCode": "public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n\n        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }",
                "PatCode": "public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n// buggy code\n//         return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n       return FastMath.pow(2 * FastMath.PI, -0.5 * dim) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_75_repairllama-ir4_patch_2.diff",
        "BugId": "Math_75",
        "PatchedMethods": [
            {
                "DevIntention": "get|pct",
                "OrgCode": "public double getPct(Object v) {\n        return getCumPct((Comparable<?>) v);\n    }",
                "PatCode": "public double getPct(Object v) {\n// buggy code\n//         return getCumPct((Comparable<?>) v);\n       return getPct((Comparable<?>) v);\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_9_repairllama-ir4_patch_4.diff",
        "BugId": "Chart_9",
        "PatchedMethods": [
            {
                "DevIntention": "create|copy",
                "OrgCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if (endIndex < 0) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }",
                "PatCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {\n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n// buggy code\n//         if (endIndex < 0) {\n       if (endIndex < 0 || startIndex > endIndex) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param object  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                s.getDomainDescription())) {\n            return false;\n        }\n\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                s.getRangeDescription())) {\n            return false;\n        }\n\n        if (!getClass().equals(s.getClass())) {\n            return false;\n        }\n\n        if (getMaximumItemAge() != s.getMaximumItemAge()) {\n            return false;\n        }\n\n        if (getMaximumItemCount() != s.getMaximumItemCount()) {\n            return false;\n        }\n\n        int count = getItemCount();\n        if (count != s.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(s.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Lang_33_repairllama-ir4_patch_1.diff",
        "BugId": "Lang_33",
        "PatchedMethods": [
            {
                "DevIntention": "to|class",
                "OrgCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }",
                "PatCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n// buggy code\n//             classes[i] = array[i].getClass();\n           classes[i] = array[i] == null ? null : array[i].getClass();\n        }\n        return classes;\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_26_repairllama-ir4_patch_2.diff",
        "BugId": "Chart_26",
        "PatchedMethods": [
            {
                "DevIntention": "draw|label",
                "OrgCode": "protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n\n        // it is unlikely that 'state' will be null, but check anyway...\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        \n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        \n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        return state;\n\n    }",
                "PatCode": "protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n// buggy code\n//                 EntityCollection entities = owner.getEntityCollection();\n//                 if (entities != null) {\n//                     entities.add(new AxisLabelEntity(this, hotspot, \n//                             this.labelToolTip, this.labelURL));\n//                 }\n           if (owner != null) {\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        }\n        return state;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_41_repairllama-ir4_patch_8.diff",
        "BugId": "Math_41",
        "PatchedMethods": [
            {
                "DevIntention": "evaluate",
                "OrgCode": "public double evaluate(final double[] values, final double[] weights,\n                           final double mean, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, weights, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += weights[i] * (dev * dev);\n                    accum2 += weights[i] * dev;\n                }\n\n                double sumWts = 0;\n                for (int i = 0; i < weights.length; i++) {\n                    sumWts += weights[i];\n                }\n\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n                }\n            }\n        }\n        return var;\n    }",
                "PatCode": "public double evaluate(final double[] values, final double[] weights,\n                           final double mean, final int begin, final int length) {\n        double var = Double.NaN;\n        if (test(values, weights, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += weights[i] * (dev * dev);\n                    accum2 += weights[i] * dev;\n                }\n                double sumWts = 0;\n// buggy code\n//                 for (int i = 0; i < weights.length; i++) {\n               for (int i = begin; i < (begin + length); i++) {\n                    sumWts += weights[i];\n                }\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n                }\n            }\n        }\n        return var;\n    }\n\n    /**\n     * <p>Returns the weighted variance of the values in the input array, using\n     * the precomputed weighted mean value.</p>\n     * <p>\n     * Uses the formula <pre>\n     *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n     * </pre></p>\n     * <p>\n     * The formula used assumes that the supplied mean value is the weighted arithmetic\n     * mean of the sample data, not a known population parameter. This method\n     * is supplied only to save computation when the mean has already been\n     * computed.</p>\n     * <p>\n     * This formula will not return the same result as the unweighted variance when all\n     * weights are equal, unless all weights are equal to 1. The formula assumes that\n     * weights are to be treated as \"expansion values,\" as will be the case if for example\n     * the weights represent frequency counts. To normalize weights so that the denominator\n     * in the variance computation equals the length of the input vector minus one, use <pre>\n     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>\n     * </pre>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n     * <ul><li>the values array is null</li>\n     *     <li>the weights array is null</li>\n     *     <li>the weights array does not have the same length as the values array</li>\n     *     <li>the weights array contains one or more infinite values</li>\n     *     <li>the weights array contains one or more NaN values</li>\n     *     <li>the weights array contains negative values</li>\n     * </ul></p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     *\n     * @param values the input array\n     * @param weights the weights array\n     * @param mean the precomputed weighted mean value\n     * @return the variance of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights, final double mean) {\n        return evaluate(values, weights, mean, 0, values.length);\n    }\n\n    /**\n     * @return Returns the isBiasCorrected.\n     */\n    public boolean isBiasCorrected() {\n        return isBiasCorrected;\n    }\n\n    /**\n     * @param biasCorrected The isBiasCorrected to set.\n     */\n    public void setBiasCorrected(boolean biasCorrected) {\n        this.isBiasCorrected = biasCorrected;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Variance copy() {\n        Variance result = new Variance();\n        copy(this, result);\n        return result;\n    }\n\n    /**\n     * Copies source to dest.\n     * <p>Neither source nor dest can be null.</p>\n     *\n     * @param source Variance to copy\n     * @param dest Variance to copy to\n     * @throws NullArgumentException if either source or dest is null\n     */\n    public static void copy(Variance source, Variance dest)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(source);\n        MathUtils.checkNotNull(dest);\n        dest.setData(source.getDataRef());\n        dest.moment = source.moment.copy();\n        dest.isBiasCorrected = source.isBiasCorrected;\n        dest.incMoment = source.incMoment;\n    }\n}"
            }
        ]
    },
    {
        "PatchId": "Lang_43_repairllama-ir4_patch_0.diff",
        "BugId": "Lang_43",
        "PatchedMethods": [
            {
                "DevIntention": "append|quoted|string",
                "OrgCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }",
                "PatCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n// buggy code\n// \n           next(pos);\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_79_repairllama-ir4_patch_0.diff",
        "BugId": "Math_79",
        "PatchedMethods": [
            {
                "DevIntention": "distance",
                "OrgCode": "public static double distance(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }",
                "PatCode": "public static double distance(int[] p1, int[] p2) {\n// buggy code\n//       int sum = 0;\n//       for (int i = 0; i < p1.length; i++) {\n//           final int dp = p1[i] - p2[i];\n     double sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }\n\n    /**\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>&infin;</sub> distance between the two points\n     */\n    public static double distanceInf(double[] p1, double[] p2) {\n        double max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    /**\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>&infin;</sub> distance between the two points\n     */\n    public static int distanceInf(int[] p1, int[] p2) {\n        int max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n\n}"
            }
        ]
    },
    {
        "PatchId": "Closure_13_repairllama-ir4_patch_0.diff",
        "BugId": "Closure_13",
        "PatchedMethods": [
            {
                "DevIntention": "process",
                "OrgCode": "public void process(Node externs, Node root) {\n    PeepholeChangeHandler handler = new PeepholeChangeHandler();\n    compiler.addChangeHandler(handler);\n    beginTraversal();\n    traverse(root);\n    endTraversal();\n    compiler.removeChangeHandler(handler);\n  }",
                "PatCode": "public void process(Node externs, Node root) {\n    PeepholeChangeHandler handler = new PeepholeChangeHandler();\n    compiler.addChangeHandler(handler);\n    beginTraversal();\n    traverse(root);\n    endTraversal();\n    compiler.removeChangeHandler(handler);\n  }"
            },
            {
                "DevIntention": "traverse",
                "OrgCode": "private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n        traverse(c);\n        Node next = c.getNext();\n        c = next;\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }",
                "PatCode": "private void traverse(Node node) {\n    if (!shouldVisit(node)) {\n      return;\n    }\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n// buggy code\n//         traverse(c);\n//         Node next = c.getNext();\n        Node next = c.getNext();\n        traverse(c);\n        c = next;\n      }\n      visit(node);\n      visits++;\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n    exitNode(node);\n  }"
            }
        ]
    },
    {
        "PatchId": "Math_70_repairllama-ir4_patch_8.diff",
        "BugId": "Math_70",
        "PatchedMethods": [
            {
                "DevIntention": "solve",
                "OrgCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(min, max);\n    }",
                "PatCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n// buggy code\n//         return solve(min, max);\n       return solve(f,min,max);\n    }"
            }
        ]
    },
    {
        "PatchId": "Closure_10_repairllama-ir4_patch_1.diff",
        "BugId": "Closure_10",
        "PatchedMethods": [
            {
                "DevIntention": "may|be|string",
                "OrgCode": "static boolean mayBeString(Node n, boolean recurse) {\n    if (recurse) {\n      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    } else {\n      return mayBeStringHelper(n);\n    }\n  }",
                "PatCode": "static boolean mayBeString(Node n, boolean recurse) {\n    if (recurse) {\n// buggy code\n//       return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     return anyResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    } else {\n      return mayBeStringHelper(n);\n    }\n  }"
            }
        ]
    },
    {
        "PatchId": "Chart_4_repairllama-ir4_patch_9.diff",
        "BugId": "Chart_4",
        "PatchedMethods": [
            {
                "DevIntention": "get|data|range",
                "OrgCode": "public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                // grab the plot's annotations\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n                \n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n            }\n        }\n\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n\n        return result;\n\n    }",
                "PatCode": "public Range getDataRange(ValueAxis axis) {\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n// buggy code\n//                     Collection c = r.getAnnotations();\n//                     Iterator i = c.iterator();\n//                     while (i.hasNext()) {\n//                         XYAnnotation a = (XYAnnotation) i.next();\n//                         if (a instanceof XYAnnotationBoundsInfo) {\n//                             includedAnnotations.add(a);\n//                         }\n//                     }\n               if (r != null) {\n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n            }\n        }\n        }\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n        return result;\n    }"
            }
        ]
    },
    {
        "PatchId": "Closure_86_repairllama-ir4_patch_1.diff",
        "BugId": "Closure_86",
        "PatchedMethods": [
            {
                "DevIntention": "evaluates|to|local|value",
                "OrgCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n        return true;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }",
                "PatCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n// buggy code\n//         return true;\n       return false;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return true;\n      case Token.IN:\n        return true;\n      default:\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }"
            }
        ]
    },
    {
        "PatchId": "Math_59_repairllama-ir4_patch_2.diff",
        "BugId": "Math_59",
        "PatchedMethods": [
            {
                "DevIntention": "max",
                "OrgCode": "public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n    }",
                "PatCode": "public static float max(final float a, final float b) {\n// buggy code\n//         return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n       return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_26_repairllama-ir4_patch_5.diff",
        "BugId": "Chart_26",
        "PatchedMethods": [
            {
                "DevIntention": "draw|label",
                "OrgCode": "protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n\n        // it is unlikely that 'state' will be null, but check anyway...\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        \n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        \n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        return state;\n\n    }",
                "PatCode": "protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n// buggy code\n//                 EntityCollection entities = owner.getEntityCollection();\n//                 if (entities != null) {\n//                     entities.add(new AxisLabelEntity(this, hotspot, \n//                             this.labelToolTip, this.labelURL));\n//                 }\n           if (owner != null) {\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        }\n        return state;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_30_repairllama-ir4_patch_1.diff",
        "BugId": "Math_30",
        "PatchedMethods": [
            {
                "DevIntention": "calculate|asymptotic|p|value",
                "OrgCode": "private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n\n        final int n1n2prod = n1 * n2;\n\n        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n        final double EU = n1n2prod / 2.0;\n        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n\n        final double z = (Umin - EU) / FastMath.sqrt(VarU);\n\n        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n\n        return 2 * standardNormal.cumulativeProbability(z);\n    }",
                "PatCode": "private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n// buggy code\n//         final int n1n2prod = n1 * n2;\n       final double n1n2prod = n1 * n2;\n        final double EU = n1n2prod / 2.0;\n        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n        final double z = (Umin - EU) / FastMath.sqrt(VarU);\n        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n        return 2 * standardNormal.cumulativeProbability(z);\n    }"
            }
        ]
    },
    {
        "PatchId": "Closure_73_repairllama-ir4_patch_0.diff",
        "BugId": "Closure_73",
        "PatchedMethods": [
            {
                "DevIntention": "str|escape",
                "OrgCode": "static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n\n  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // Identifiers should always go to Latin1/ ASCII characters because\n      // different browser's rules for valid identifier characters are\n      // crazy.\n      if (c > 0x1F && c < 0x7F) {\n        sb.append(c);\n      } else {\n        appendHexJavaScriptRepresentation(sb, c);\n      }\n    }\n    return sb.toString();\n  }",
                "PatCode": "static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       \n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          final String END_SCRIPT = \"/script\";\n          final String START_COMMENT = \"!--\";\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n// buggy code\n//             if (c > 0x1f && c <= 0x7f) {\n           if (c > 0x1f && c < 0x7f) {\n              sb.append(c);\n            } else {\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n\n  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // Identifiers should always go to Latin1/ ASCII characters because\n      // different browser's rules for valid identifier characters are\n      // crazy.\n      if (c > 0x1F && c < 0x7F) {\n        sb.append(c);\n      } else {\n        appendHexJavaScriptRepresentation(sb, c);\n      }\n    }\n    return sb.toString();\n  }"
            }
        ]
    },
    {
        "PatchId": "Chart_26_repairllama-ir4_patch_9.diff",
        "BugId": "Chart_26",
        "PatchedMethods": [
            {
                "DevIntention": "draw|label",
                "OrgCode": "protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n\n        // it is unlikely that 'state' will be null, but check anyway...\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        \n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        \n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        return state;\n\n    }",
                "PatCode": "protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n// buggy code\n//                 EntityCollection entities = owner.getEntityCollection();\n//                 if (entities != null) {\n//                     entities.add(new AxisLabelEntity(this, hotspot, \n//                             this.labelToolTip, this.labelURL));\n//                 }\n           if (owner != null) {\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        }\n        return state;\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_8_repairllama-ir4_patch_0.diff",
        "BugId": "Chart_8",
        "PatchedMethods": [
            {
                "DevIntention": "week",
                "OrgCode": "public Week(Date time, TimeZone zone) {\n        // defer argument checking...\n        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n    }",
                "PatCode": "public Week(Date time, TimeZone zone) {\n// buggy code\n//         this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n       this(time, zone, Locale.getDefault());\n    }"
            }
        ]
    },
    {
        "PatchId": "Closure_115_repairllama-ir4_patch_1.diff",
        "BugId": "Closure_115",
        "PatchedMethods": [
            {
                "DevIntention": "can|inline|reference|directly",
                "OrgCode": "private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    boolean hasSideEffects = false;\n    if (block.hasChildren()) {\n      Preconditions.checkState(block.hasOneChild());\n      Node stmt = block.getFirstChild();\n      if (stmt.isReturn()) {\n        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n      }\n    }\n    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n    Node cArg = callNode.getFirstChild().getNext();\n\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        // TODO(johnlenz): Support replace this with a value.\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        // \".apply\" call should be filtered before this.\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n\n    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      // For each named parameter check if a mutable argument use more than one.\n      if (fnParam != null) {\n        if (cArg != null) {\n          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n            return CanInlineResult.NO;\n          }\n          // Check for arguments that are evaluated more than once.\n          // Note: Unlike block inlining, there it is not possible that a\n          // parameter reference will be in a loop.\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n\n        // Move to the next name.\n        fnParam = fnParam.getNext();\n      }\n\n      // For every call argument check for side-effects, even if there\n      // isn't a named parameter to match.\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n\n    return CanInlineResult.YES;\n  }",
                "PatCode": "private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n    Node block = fnNode.getLastChild();\n// buggy code\n//     boolean hasSideEffects = false;\n//     if (block.hasChildren()) {\n//       Preconditions.checkState(block.hasOneChild());\n//       Node stmt = block.getFirstChild();\n//       if (stmt.isReturn()) {\n//         hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n//       }\n//     }\n//     Node cArg = callNode.getFirstChild().getNext();\n//     if (!callNode.getFirstChild().isName()) {\n//       if (NodeUtil.isFunctionObjectCall(callNode)) {\n//         if (cArg == null || !cArg.isThis()) {\n//           return CanInlineResult.NO;\n//         }\n//         cArg = cArg.getNext();\n//       } else {\n//         Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n//       }\n//     }\n//     Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n//     while (cArg != null || fnParam != null) {\n//       if (fnParam != null) {\n//         if (cArg != null) {\n//           if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n//             return CanInlineResult.NO;\n//           }\n    Node cArg = callNode.getFirstChild().getNext();\n    if (!callNode.getFirstChild().isName()) {\n      if (NodeUtil.isFunctionObjectCall(callNode)) {\n        if (cArg == null || !cArg.isThis()) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      } else {\n        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n      }\n    }\n    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n    while (cArg != null || fnParam != null) {\n      if (fnParam != null) {\n        if (cArg != null) {\n          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n              && NodeUtil.getNameReferenceCount(\n                  block, fnParam.getString()) > 1) {\n            return CanInlineResult.NO;\n          }\n        }\n        fnParam = fnParam.getNext();\n      }\n      if (cArg != null) {\n        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n          return CanInlineResult.NO;\n        }\n        cArg = cArg.getNext();\n      }\n    }\n    return CanInlineResult.YES;\n  }"
            }
        ]
    },
    {
        "PatchId": "Mockito_29_repairllama-ir4_patch_4.diff",
        "BugId": "Mockito_29",
        "PatchedMethods": [
            {
                "DevIntention": "describe|to",
                "OrgCode": "public void describeTo(Description description) {\n        description.appendText(\"same(\");\n        appendQuoting(description);\n        description.appendText(wanted.toString());\n        appendQuoting(description);\n        description.appendText(\")\");\n    }",
                "PatCode": "public void describeTo(Description description) {\n        description.appendText(\"same(\");\n        appendQuoting(description);\n// buggy code\n//         description.appendText(wanted.toString());\n       description.appendText(wanted == null ? \"null\" : wanted.toString());\n        appendQuoting(description);\n        description.appendText(\")\");\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_43_repairllama-ir4_patch_6.diff",
        "BugId": "Lang_43",
        "PatchedMethods": [
            {
                "DevIntention": "append|quoted|string",
                "OrgCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }",
                "PatCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n// buggy code\n// \n           next(pos); \n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }"
            }
        ]
    },
    {
        "PatchId": "Closure_13_repairllama-ir4_patch_6.diff",
        "BugId": "Closure_13",
        "PatchedMethods": [
            {
                "DevIntention": "process",
                "OrgCode": "public void process(Node externs, Node root) {\n    PeepholeChangeHandler handler = new PeepholeChangeHandler();\n    compiler.addChangeHandler(handler);\n    beginTraversal();\n    traverse(root);\n    endTraversal();\n    compiler.removeChangeHandler(handler);\n  }",
                "PatCode": "public void process(Node externs, Node root) {\n    PeepholeChangeHandler handler = new PeepholeChangeHandler();\n    compiler.addChangeHandler(handler);\n    beginTraversal();\n    traverse(root);\n    endTraversal();\n    compiler.removeChangeHandler(handler);\n  }"
            },
            {
                "DevIntention": "traverse",
                "OrgCode": "private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n        traverse(c);\n        Node next = c.getNext();\n        c = next;\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }",
                "PatCode": "private void traverse(Node node) {\n    if (!shouldVisit(node)) {\n      return;\n    }\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n// buggy code\n//         traverse(c);\n//         Node next = c.getNext();\n        Node next = c.getNext();\n      traverse(c);\n        c = next;\n      }\n      visit(node);\n      visits++;\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n    exitNode(node);\n  }"
            }
        ]
    },
    {
        "PatchId": "Math_85_repairllama-ir4_patch_4.diff",
        "BugId": "Math_85",
        "PatchedMethods": [
            {
                "DevIntention": "bracket",
                "OrgCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }",
                "PatCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n// buggy code\n//         if (fa * fb >= 0.0 ) {\n       if (fa * fb > 0.0) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        return new double[]{a, b};\n    }\n\n    /**\n     * Compute the midpoint of two values.\n     * \n     * @param a first value.\n     * @param b second value.\n     * @return the midpoint. \n     */\n    public static double midpoint(double a, double b) {\n        return (a + b) * .5;\n    }\n    \n    /**\n     * Checks to see if f is null, throwing IllegalArgumentException if so.\n     * @param f  input function\n     * @throws IllegalArgumentException if f is null\n     */\n    private static void setup(UnivariateRealFunction f) {\n        if (f == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n    }\n\n    /** Holder for the factory.\n     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n     */\n    private static class LazyHolder {\n        /** Cached solver factory */\n        private static final UnivariateRealSolverFactory FACTORY =\n            UnivariateRealSolverFactory.newInstance();\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Math_95_repairllama-ir4_patch_2.diff",
        "BugId": "Math_95",
        "PatchedMethods": [
            {
                "DevIntention": "get|initial|domain",
                "OrgCode": "protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n            ret = d / (d - 2.0);\n        return ret;\n    }",
                "PatCode": "protected double getInitialDomain(double p) {\n// buggy code\n//         double ret;\n//         double d = getDenominatorDegreesOfFreedom();\n//             ret = d / (d - 2.0);\n       double ret = 1.0;\n        double d = getDenominatorDegreesOfFreedom();\n        if (d > 2.0) {\n            ret = d / (d - 2.0);\n        }\n        return ret;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_82_repairllama-ir4_patch_0.diff",
        "BugId": "Math_82",
        "PatchedMethods": [
            {
                "DevIntention": "get|pivot|row",
                "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }",
                "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n// buggy code\n//             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n           if (MathUtils.compareTo(entry, 0, epsilon) > 0) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n\n\n    /**\n     * Runs one iteration of the Simplex method on the given model.\n     * @param tableau simple tableau for the problem\n     * @throws OptimizationException if the maximal iteration count has been\n     * exceeded or if the model is found not to have a bounded solution\n     */\n    protected void doIteration(final SimplexTableau tableau)\n        throws OptimizationException {\n\n        incrementIterationsCounter();\n\n        Integer pivotCol = getPivotColumn(tableau);\n        Integer pivotRow = getPivotRow(pivotCol, tableau);\n        if (pivotRow == null) {\n            throw new UnboundedSolutionException();\n        }\n\n        // set the pivot element to 1\n        double pivotVal = tableau.getEntry(pivotRow, pivotCol);\n        tableau.divideRow(pivotRow, pivotVal);\n\n        // set the rest of the pivot column to 0\n        for (int i = 0; i < tableau.getHeight(); i++) {\n            if (i != pivotRow) {\n                double multiplier = tableau.getEntry(i, pivotCol);\n                tableau.subtractRow(i, pivotRow, multiplier);\n            }\n        }\n    }\n\n    /**\n     * Checks whether Phase 1 is solved.\n     * @param tableau simple tableau for the problem\n     * @return whether Phase 1 is solved\n     */\n    private boolean isPhase1Solved(final SimplexTableau tableau) {\n        if (tableau.getNumArtificialVariables() == 0) {\n            return true;\n        }\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns whether the problem is at an optimal state.\n     * @param tableau simple tableau for the problem\n     * @return whether the model has been solved\n     */\n    public boolean isOptimal(final SimplexTableau tableau) {\n        if (tableau.getNumArtificialVariables() > 0) {\n            return false;\n        }\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Solves Phase 1 of the Simplex method.\n     * @param tableau simple tableau for the problem\n     * @exception OptimizationException if the maximal number of iterations is\n     * exceeded, or if the problem is found not to have a bounded solution, or\n     * if there is no feasible solution\n     */\n    protected void solvePhase1(final SimplexTableau tableau)\n        throws OptimizationException {\n        // make sure we're in Phase 1\n        if (tableau.getNumArtificialVariables() == 0) {\n            return;\n        }\n\n        while (!isPhase1Solved(tableau)) {\n            doIteration(tableau);\n        }\n\n        // if W is not zero then we have no feasible solution\n        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {\n            throw new NoFeasibleSolutionException();\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public RealPointValuePair doOptimize()\n        throws OptimizationException {\n        final SimplexTableau tableau =\n            new SimplexTableau(f, constraints, goalType, restrictToNonNegative, epsilon);\n        solvePhase1(tableau);\n        tableau.discardArtificialVariables();\n        while (!isOptimal(tableau)) {\n            doIteration(tableau);\n        }\n        return tableau.getSolution();\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Lang_51_repairllama-ir4_patch_2.diff",
        "BugId": "Lang_51",
        "PatchedMethods": [
            {
                "DevIntention": "to|boolean",
                "OrgCode": "public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }",
                "PatCode": "public static boolean toBoolean(String str) {\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n// buggy code\n// \n               return false;\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_26_repairllama-ir4_patch_4.diff",
        "BugId": "Chart_26",
        "PatchedMethods": [
            {
                "DevIntention": "draw|label",
                "OrgCode": "protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n\n        // it is unlikely that 'state' will be null, but check anyway...\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        \n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        \n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        return state;\n\n    }",
                "PatCode": "protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n// buggy code\n//                 EntityCollection entities = owner.getEntityCollection();\n//                 if (entities != null) {\n//                     entities.add(new AxisLabelEntity(this, hotspot, \n//                             this.labelToolTip, this.labelURL));\n//                 }\n           if (owner != null) {\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        }\n        return state;\n    }"
            }
        ]
    },
    {
        "PatchId": "Closure_57_repairllama-ir4_patch_1.diff",
        "BugId": "Closure_57",
        "PatchedMethods": [
            {
                "DevIntention": "extract|class|name|if|goog",
                "OrgCode": "private static String extractClassNameIfGoog(Node node, Node parent,\n      String functionName){\n    String className = null;\n    if (NodeUtil.isExprCall(parent)) {\n      Node callee = node.getFirstChild();\n      if (callee != null && callee.getType() == Token.GETPROP) {\n        String qualifiedName = callee.getQualifiedName();\n        if (functionName.equals(qualifiedName)) {\n          Node target = callee.getNext();\n          if (target != null) {\n            className = target.getString();\n          }\n        }\n      }\n    }\n    return className;\n  }",
                "PatCode": "private static String extractClassNameIfGoog(Node node, Node parent,\n      String functionName){\n    String className = null;\n    if (NodeUtil.isExprCall(parent)) {\n      Node callee = node.getFirstChild();\n      if (callee != null && callee.getType() == Token.GETPROP) {\n        String qualifiedName = callee.getQualifiedName();\n        if (functionName.equals(qualifiedName)) {\n          Node target = callee.getNext();\n// buggy code\n//           if (target != null) {\n         if (target != null && target.getType() == Token.STRING) {\n            className = target.getString();\n          }\n        }\n      }\n    }\n    return className;\n  }\n\n  /**\n   * Use closure's implementation.\n   * @return closure's function name for exporting properties.\n   */\n  @Override\n  public String getExportPropertyFunction() {\n    return \"goog.exportProperty\";\n  }\n\n  /**\n   * Use closure's implementation.\n   * @return closure's function name for exporting symbols.\n   */\n  @Override\n  public String getExportSymbolFunction() {\n    return \"goog.exportSymbol\";\n  }\n\n  @Override\n  public List<String> identifyTypeDeclarationCall(Node n) {\n    Node callName = n.getFirstChild();\n    if (\"goog.addDependency\".equals(callName.getQualifiedName()) &&\n        n.getChildCount() >= 3) {\n      Node typeArray = callName.getNext().getNext();\n      if (typeArray.getType() == Token.ARRAYLIT) {\n        List<String> typeNames = Lists.newArrayList();\n        for (Node name = typeArray.getFirstChild(); name != null;\n             name = name.getNext()) {\n          if (name.getType() == Token.STRING) {\n            typeNames.add(name.getString());\n          }\n        }\n        return typeNames;\n      }\n    }\n    return null;\n  }\n\n  @Override\n  public String getAbstractMethodName() {\n    return \"goog.abstractMethod\";\n  }\n\n  @Override\n  public String getSingletonGetterClassName(Node callNode) {\n    Node callArg = callNode.getFirstChild();\n    String callName = callArg.getQualifiedName();\n\n    // Use both the original name and the post-CollapseProperties name.\n    if (!(\"goog.addSingletonGetter\".equals(callName) ||\n          \"goog$addSingletonGetter\".equals(callName)) ||\n        callNode.getChildCount() != 2) {\n      return null;\n    }\n\n    return callArg.getNext().getQualifiedName();\n  }\n\n  @Override\n  public void applySingletonGetter(FunctionType functionType,\n      FunctionType getterType, ObjectType objectType) {\n    functionType.defineDeclaredProperty(\"getInstance\", getterType,\n        functionType.getSource());\n    functionType.defineDeclaredProperty(\"instance_\", objectType,\n        functionType.getSource());\n  }\n\n  @Override\n  public String getGlobalObject() {\n    return \"goog.global\";\n  }\n\n  private final Set<String> propertyTestFunctions = ImmutableSet.of(\n      \"goog.isDef\", \"goog.isNull\", \"goog.isDefAndNotNull\",\n      \"goog.isString\", \"goog.isNumber\", \"goog.isBoolean\",\n      \"goog.isFunction\", \"goog.isArray\", \"goog.isObject\");\n\n  @Override\n  public boolean isPropertyTestFunction(Node call) {\n    Preconditions.checkArgument(call.getType() == Token.CALL);\n    return propertyTestFunctions.contains(\n        call.getFirstChild().getQualifiedName());\n  }\n\n  @Override\n  public ObjectLiteralCast getObjectLiteralCast(NodeTraversal t,\n      Node callNode) {\n    Preconditions.checkArgument(callNode.getType() == Token.CALL);\n    Node callName = callNode.getFirstChild();\n    if (!\"goog.reflect.object\".equals(callName.getQualifiedName()) ||\n        callNode.getChildCount() != 3) {\n      return null;\n    }\n\n    Node typeNode = callName.getNext();\n    if (!typeNode.isQualifiedName()) {\n      return null;\n    }\n\n    Node objectNode = typeNode.getNext();\n    if (objectNode.getType() != Token.OBJECTLIT) {\n      // TODO(johnlenz): The coding convention should not be performing checks.\n      t.getCompiler().report(JSError.make(t.getSourceName(), callNode,\n                                          OBJECTLIT_EXPECTED));\n      return null;\n    }\n\n    return new ObjectLiteralCast(typeNode.getQualifiedName(),\n                                 typeNode.getNext());\n  }\n\n  @Override\n  public boolean isOptionalParameter(Node parameter) {\n    return false;\n  }\n\n  @Override\n  public boolean isVarArgsParameter(Node parameter) {\n    return false;\n  }\n\n  @Override\n  public boolean isPrivate(String name) {\n    return false;\n  }\n\n  @Override\n  public Collection<AssertionFunctionSpec> getAssertionFunctions() {\n    return ImmutableList.<AssertionFunctionSpec>of(\n        new AssertionFunctionSpec(\"goog.asserts.assert\"),\n        new AssertionFunctionSpec(\"goog.asserts.assertNumber\",\n            JSTypeNative.NUMBER_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertString\",\n            JSTypeNative.STRING_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertFunction\",\n            JSTypeNative.FUNCTION_INSTANCE_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertObject\",\n            JSTypeNative.OBJECT_TYPE),\n        new AssertionFunctionSpec(\"goog.asserts.assertArray\",\n            JSTypeNative.ARRAY_TYPE),\n        // TODO(agrieve): It would be better if this could make the first\n        // parameter the type of the second parameter.\n        new AssertionFunctionSpec(\"goog.asserts.assertInstanceof\",\n            JSTypeNative.OBJECT_TYPE)\n    );\n  }\n\n  @Override\n  public Bind describeFunctionBind(Node n) {\n    Bind result = super.describeFunctionBind(n);\n    if (result != null) {\n      return result;\n    }\n\n    // It would be nice to be able to identify a fn.bind call\n    // but that requires knowing the type of \"fn\".\n\n    if (n.getType() != Token.CALL) {\n      return null;\n    }\n\n    Node callTarget = n.getFirstChild();\n    String name = callTarget.getQualifiedName();\n    if (name != null) {\n      if (name.equals(\"goog.bind\")\n          || name.equals(\"goog$bind\")) {\n        // goog.bind(fn, self, args...);\n        Node fn = callTarget.getNext();\n        if (fn == null) {\n          return null;\n        }\n        Node thisValue = safeNext(fn);\n        Node parameters = safeNext(thisValue);\n        return new Bind(fn, thisValue, parameters);\n      }\n\n      if (name.equals(\"goog.partial\") || name.equals(\"goog$partial\")) {\n        // goog.partial(fn, args...);\n        Node fn = callTarget.getNext();\n        if (fn == null) {\n          return null;\n        }\n        Node thisValue = null;\n        Node parameters = safeNext(fn);\n        return new Bind(fn, thisValue, parameters);\n      }\n    }\n\n    return null;\n  }\n\n  private Node safeNext(Node n) {\n    if (n != null) {\n      return n.getNext();\n    }\n    return null;\n  }\n}"
            }
        ]
    },
    {
        "PatchId": "Chart_11_repairllama-ir4_patch_0.diff",
        "BugId": "Chart_11",
        "PatchedMethods": [
            {
                "DevIntention": "equal",
                "OrgCode": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p1.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }",
                "PatCode": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n// buggy code\n//         PathIterator iterator2 = p1.getPathIterator(null);\n       PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_7_repairllama-ir4_patch_1.diff",
        "BugId": "Chart_7",
        "PatchedMethods": [
            {
                "DevIntention": "update|bounds",
                "OrgCode": "private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }",
                "PatCode": "private void updateBounds(TimePeriod period, int index) {\n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        if (this.maxMiddleIndex >= 0) {\n// buggy code\n//             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n//                 .getTime();\n//             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n            long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n                .getTime();\n             long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_70_repairllama-ir4_patch_1.diff",
        "BugId": "Math_70",
        "PatchedMethods": [
            {
                "DevIntention": "solve",
                "OrgCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        return solve(min, max);\n    }",
                "PatCode": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n// buggy code\n//         return solve(min, max);\n       return solve(f, min, max);\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_4_repairllama-ir4_patch_0.diff",
        "BugId": "Chart_4",
        "PatchedMethods": [
            {
                "DevIntention": "get|data|range",
                "OrgCode": "public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                // grab the plot's annotations\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n                \n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n            }\n        }\n\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n\n        return result;\n\n    }",
                "PatCode": "public Range getDataRange(ValueAxis axis) {\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n// buggy code\n//                     Collection c = r.getAnnotations();\n//                     Iterator i = c.iterator();\n//                     while (i.hasNext()) {\n//                         XYAnnotation a = (XYAnnotation) i.next();\n//                         if (a instanceof XYAnnotationBoundsInfo) {\n//                             includedAnnotations.add(a);\n//                         }\n//                     }\n               if (r != null) {\n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n            }\n        }\n        }\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n        return result;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_57_repairllama-ir4_patch_0.diff",
        "BugId": "Math_57",
        "PatchedMethods": [
            {
                "DevIntention": "choose|initial|centers",
                "OrgCode": "private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n        // Choose one center uniformly at random from among the data points.\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n\n        final double[] dx2 = new double[pointSet.size()];\n        while (resultSet.size() < k) {\n            // For each data point x, compute D(x), the distance between x and\n            // the nearest center that has already been chosen.\n            int sum = 0;\n            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n\n            // Add one new data point as a center. Each point x is chosen with\n            // probability proportional to D(x)2\n            final double r = random.nextDouble() * sum;\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    break;\n                }\n            }\n        }\n\n        return resultSet;\n\n    }",
                "PatCode": "private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n        final double[] dx2 = new double[pointSet.size()];\n        while (resultSet.size() < k) {\n// buggy code\n//             int sum = 0;\n           double sum = 0;\n            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n            final double r = random.nextDouble() * sum;\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    break;\n                }\n            }\n        }\n        return resultSet;\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_20_repairllama-ir4_patch_0.diff",
        "BugId": "Chart_20",
        "PatchedMethods": [
            {
                "DevIntention": "value|marker",
                "OrgCode": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                       Paint outlinePaint, Stroke outlineStroke, float alpha) {\n        super(paint, stroke, paint, stroke, alpha);\n        this.value = value;\n    }",
                "PatCode": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                       Paint outlinePaint, Stroke outlineStroke, float alpha) {\n// buggy code\n//         super(paint, stroke, paint, stroke, alpha);\n       super(paint, stroke, outlinePaint, outlineStroke, alpha);\n        this.value = value;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_50_repairllama-ir4_patch_4.diff",
        "BugId": "Math_50",
        "PatchedMethods": [
            {
                "DevIntention": "do|solve",
                "OrgCode": "protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }",
                "PatCode": "protected final double doSolve() {\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n        verifyBracketing(x0, x1);\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n        boolean inverted = false;\n        while (true) {\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n            if (fx == 0.0) {\n                return x;\n            }\n            if (f1 * fx < 0) {\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n// buggy code\n//                     if (x == x1) {\n//                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n//                         f0 = computeObjectiveValue(x0);\n//                     }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n            x1 = x;\n            f1 = fx;\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_10_repairllama-ir4_patch_0.diff",
        "BugId": "Lang_10",
        "PatchedMethods": [
            {
                "DevIntention": "escape|regex",
                "OrgCode": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n        boolean wasWhite= false;\n        for(int i= 0; i<value.length(); ++i) {\n            char c= value.charAt(i);\n            if(Character.isWhitespace(c)) {\n                if(!wasWhite) {\n                    wasWhite= true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n            wasWhite= false;\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n        }\n        return regex;\n    }",
                "PatCode": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n// buggy code\n//         boolean wasWhite= false;\n//         for(int i= 0; i<value.length(); ++i) {\n//             char c= value.charAt(i);\n//             if(Character.isWhitespace(c)) {\n//                 if(!wasWhite) {\n//                     wasWhite= true;\n//                     regex.append(\"\\\\s*+\");\n//                 }\n//                 continue;\n//             }\n//             wasWhite= false;\n        for(int i= 0; i<value.length(); ++i) {\n            char c= value.charAt(i);\n            switch(c) {\n            case '\\'':\n                if(unquote) {\n                    if(++i==value.length()) {\n                        return regex;\n                    }\n                    c= value.charAt(i);\n                }\n                break;\n            case '?':\n            case '[':\n            case ']':\n            case '(':\n            case ')':\n            case '{':\n            case '}':\n            case '\\\\':\n            case '|':\n            case '*':\n            case '+':\n            case '^':\n            case '$':\n            case '.':\n                regex.append('\\\\');\n            }\n            regex.append(c);\n        }\n        return regex;\n    }\n\n    /**\n     * A class to store Key / Value pairs\n     */\n    private static class KeyValue {\n        public String key;\n        public int value;\n\n        /**\n         * Construct a Key / Value pair\n         * @param key The key\n         * @param value The value\n         */\n        public KeyValue(String key, int value) {\n            this.key= key;\n            this.value= value;\n        }\n    }\n\n    /**\n     * ignore case comparison of keys\n     */\n    private static final Comparator<KeyValue> IGNORE_CASE_COMPARATOR = new Comparator<KeyValue> () {\n        @Override\n        public int compare(KeyValue left, KeyValue right) {\n            return left.key.compareToIgnoreCase(right.key);\n        }\n    };\n\n    /**\n     * Get the short and long values displayed for a field\n     * @param field The field of interest\n     * @return A sorted array of the field key / value pairs\n     */\n    KeyValue[] getDisplayNames(int field) {\n        Integer fieldInt = Integer.valueOf(field);\n        KeyValue[] fieldKeyValues= nameValues.get(fieldInt);\n        if(fieldKeyValues==null) {\n            DateFormatSymbols symbols= DateFormatSymbols.getInstance(locale);\n            switch(field) {\n            case Calendar.ERA:\n                // DateFormatSymbols#getEras() only returns AD/BC or translations\n                // It does not work for the Thai Buddhist or Japanese Imperial calendars.\n                // see: https://issues.apache.org/jira/browse/TRINIDAD-2126\n                Calendar c = Calendar.getInstance(locale);\n                // N.B. Some calendars have different short and long symbols, e.g. ja_JP_JP\n                String[] shortEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.SHORT, locale));\n                String[] longEras = toArray(c.getDisplayNames(Calendar.ERA, Calendar.LONG, locale));\n                fieldKeyValues= createKeyValues(longEras, shortEras);\n                break;\n            case Calendar.DAY_OF_WEEK:\n                fieldKeyValues= createKeyValues(symbols.getWeekdays(), symbols.getShortWeekdays());\n                break;\n            case Calendar.AM_PM:\n                fieldKeyValues= createKeyValues(symbols.getAmPmStrings(), null);\n                break;\n            case Calendar.MONTH:\n                fieldKeyValues= createKeyValues(symbols.getMonths(), symbols.getShortMonths());\n                break;\n            default:\n                throw new IllegalArgumentException(\"Invalid field value \"+field);\n            }\n            KeyValue[] prior = nameValues.putIfAbsent(fieldInt, fieldKeyValues);\n            if(prior!=null) {\n                fieldKeyValues= prior;\n            }\n        }\n        return fieldKeyValues;\n    }\n\n    private String[] toArray(Map<String, Integer> era) {\n        String[] eras = new String[era.size()]; // assume no gaps in entry values\n        for(Map.Entry<String, Integer> me : era.entrySet()) {\n            int idx = me.getValue().intValue();\n            final String key = me.getKey();\n            if (key == null) {\n                throw new IllegalArgumentException();\n            }\n            eras[idx] = key;\n        }\n        return eras;\n    }\n\n    /**\n     * Create key / value pairs from keys\n     * @param longValues The allowable long names for a field\n     * @param shortValues The optional allowable short names for a field\n     * @return The sorted name / value pairs for the field\n     */\n    private static KeyValue[] createKeyValues(String[] longValues, String[] shortValues) {\n        KeyValue[] fieldKeyValues= new KeyValue[count(longValues)+count(shortValues)];\n        copy(fieldKeyValues, copy(fieldKeyValues, 0, longValues), shortValues);\n        Arrays.sort(fieldKeyValues, IGNORE_CASE_COMPARATOR);\n        return fieldKeyValues;\n    }\n\n    /**\n     * Get a count of valid values in array.  A valid value is of non-zero length.\n     * @param values The values to check.  This parameter may be null\n     * @return The number of valid values\n     */\n    private static int count(String[] values) {\n        int count= 0;\n        if(values!=null) {\n            for(String value : values) {\n                if(value.length()>0) {\n                    ++count;\n                }\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Create key / value pairs from values\n     * @param fieldKeyValues The destination array\n     * @param offset The offset into the destination array\n     * @param values The values to use to create key / value pairs.  This parameter may be null.\n     * @return The offset into the destination array\n     */\n    private static int copy(KeyValue[] fieldKeyValues, int offset, String[] values) {\n        if(values!=null) {\n            for(int i= 0; i<values.length; ++i) {\n                String value= values[i];\n                if(value.length()>0) {\n                    fieldKeyValues[offset++]= new KeyValue(value, i);\n                }\n            }\n        }\n        return offset;\n    }\n\n    /**\n     * Adjust dates to be within 80 years before and 20 years after instantiation\n     * @param twoDigitYear The year to adjust\n     * @return A value within -80 and +20 years from instantiation of this instance\n     */\n    int adjustYear(int twoDigitYear) {\n        int trial= twoDigitYear + thisYear - thisYear%100;\n        if(trial < thisYear+20) {\n            return trial;\n        }\n        return trial-100;\n    }\n\n    /**\n     * Is the next field a number?\n     * @return true, if next field will be a number\n     */\n    boolean isNextNumber() {\n        return nextStrategy!=null && nextStrategy.isNumber();\n    }\n\n    /**\n     * What is the width of the current field?\n     * @return The number of characters in the current format field\n     */\n    int getFieldWidth() {\n        return currentFormatField.length();\n    }\n\n    /**\n     * A strategy to parse a single field from the parsing pattern\n     */\n    private interface Strategy {\n        /**\n         * Is this field a number?\n         * @return true, if field is a number\n         */\n        boolean isNumber();\n        /**\n         * Set the Calendar with the parsed field\n         * @param parser The parser calling this strategy\n         * @param cal The <code>Calendar</code> to set\n         * @param value The parsed field to translate and set in cal\n         */\n        void setCalendar(FastDateParser parser, Calendar cal, String value);\n        /**\n         * Generate a <code>Pattern</code> regular expression to the <code>StringBuilder</code>\n         * which will accept this field\n         * @param parser The parser calling this strategy\n         * @param regex The <code>StringBuilder</code> to append to\n         * @return true, if this field will set the calendar;\n         * false, if this field is a constant value\n         */\n        boolean addRegex(FastDateParser parser, StringBuilder regex);\n    }\n\n    /**\n     * A <code>Pattern</code> to parse the user supplied SimpleDateFormat pattern\n     */\n    private static final Pattern formatPattern= Pattern.compile(\n            \"D+|E+|F+|G+|H+|K+|M+|S+|W+|Z+|a+|d+|h+|k+|m+|s+|w+|y+|z+|''|'[^']++(''[^']*+)*+'|[^'A-Za-z]++\");\n\n    /**\n     * Obtain a Strategy given a field from a SimpleDateFormat pattern\n     * @param formatField A sub-sequence of the SimpleDateFormat pattern\n     * @return The Strategy that will handle parsing for the field\n     */\n    private Strategy getStrategy(String formatField) {\n        switch(formatField.charAt(0)) {\n        case '\\'':\n            if(formatField.length()>2) {\n                formatField= formatField.substring(1, formatField.length()-1);\n            }\n            //$FALL-THROUGH$\n        default:\n            return new CopyQuotedStrategy(formatField);\n        case 'D':\n            return DAY_OF_YEAR_STRATEGY;\n        case 'E':\n            return DAY_OF_WEEK_STRATEGY;\n        case 'F':\n            return DAY_OF_WEEK_IN_MONTH_STRATEGY;\n        case 'G':\n            return ERA_STRATEGY;\n        case 'H':\n            return MODULO_HOUR_OF_DAY_STRATEGY;\n        case 'K':\n            return HOUR_STRATEGY;\n        case 'M':\n            return formatField.length()>=3 ?TEXT_MONTH_STRATEGY :NUMBER_MONTH_STRATEGY;\n        case 'S':\n            return MILLISECOND_STRATEGY;\n        case 'W':\n            return WEEK_OF_MONTH_STRATEGY;\n        case 'Z':\n            break;\n        case 'a':\n            return AM_PM_STRATEGY;\n        case 'd':\n            return DAY_OF_MONTH_STRATEGY;\n        case 'h':\n            return MODULO_HOUR_STRATEGY;\n        case 'k':\n            return HOUR_OF_DAY_STRATEGY;\n        case 'm':\n            return MINUTE_STRATEGY;\n        case 's':\n            return SECOND_STRATEGY;\n        case 'w':\n            return WEEK_OF_YEAR_STRATEGY;\n        case 'y':\n            return formatField.length()>2 ?LITERAL_YEAR_STRATEGY :ABBREVIATED_YEAR_STRATEGY;\n        case 'z':\n            break;\n        }\n        TimeZoneStrategy tzs= tzsCache.get(locale);\n        if(tzs==null) {\n            tzs= new TimeZoneStrategy(locale);\n            TimeZoneStrategy inCache= tzsCache.putIfAbsent(locale, tzs);\n            if(inCache!=null) {\n                return inCache;\n            }\n        }\n        return tzs;\n    }\n\n    /**\n     * A strategy that copies the static or quoted field in the parsing pattern\n     */\n    private static class CopyQuotedStrategy implements Strategy {\n        private final String formatField;\n\n        /**\n         * Construct a Strategy that ensures the formatField has literal text\n         * @param formatField The literal text to match\n         */\n        CopyQuotedStrategy(String formatField) {\n            this.formatField= formatField;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isNumber() {\n            char c= formatField.charAt(0);\n            if(c=='\\'') {\n                c= formatField.charAt(1);\n            }\n            return Character.isDigit(c);\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            escapeRegex(regex, formatField, true);\n            return false;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n        }\n    }\n\n    /**\n     * A strategy that handles a text field in the parsing pattern\n     */\n    private static class TextStrategy implements Strategy {\n        private final int field;\n\n        /**\n         * Construct a Strategy that parses a Text field\n         * @param field The Calendar field\n         */\n        TextStrategy(int field) {\n            this.field= field;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isNumber() {\n            return false;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            regex.append('(');\n            for(KeyValue textKeyValue : parser.getDisplayNames(field)) {\n                escapeRegex(regex, textKeyValue.key, false).append('|');\n            }\n            regex.setCharAt(regex.length()-1, ')');\n            return true;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n            KeyValue[] textKeyValues= parser.getDisplayNames(field);\n            int idx= Arrays.binarySearch(textKeyValues, new KeyValue(value, -1), IGNORE_CASE_COMPARATOR);\n            if(idx<0) {\n                StringBuilder sb= new StringBuilder(value);\n                sb.append(\" not in (\");\n                for(KeyValue textKeyValue : textKeyValues) {\n                    sb.append(textKeyValue.key).append(' ');\n                }\n                sb.setCharAt(sb.length()-1, ')');\n                throw new IllegalArgumentException(sb.toString());\n            }\n            cal.set(field, textKeyValues[idx].value);\n        }\n    }\n\n    /**\n     * A strategy that handles a number field in the parsing pattern\n     */\n    private static class NumberStrategy implements Strategy {\n        protected final int field;\n\n        /**\n         * Construct a Strategy that parses a Number field\n         * @param field The Calendar field\n         */\n        NumberStrategy(int field) {\n             this.field= field;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isNumber() {\n            return true;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            if(parser.isNextNumber()) {\n                regex.append(\"(\\\\p{IsNd}{\").append(parser.getFieldWidth()).append(\"}+)\");\n            }\n            else {\n                regex.append(\"(\\\\p{IsNd}++)\");\n            }\n            return true;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n            cal.set(field, modify(Integer.parseInt(value)));\n        }\n\n        /**\n         * Make any modifications to parsed integer\n         * @param iValue The parsed integer\n         * @return The modified value\n         */\n        public int modify(int iValue) {\n            return iValue;\n        }\n    }\n\n    private static final Strategy ABBREVIATED_YEAR_STRATEGY = new NumberStrategy(Calendar.YEAR) {\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n            int iValue= Integer.parseInt(value);\n            if(iValue<100) {\n                iValue= parser.adjustYear(iValue);\n            }\n            cal.set(Calendar.YEAR, iValue);\n        }\n    };\n\n    /**\n     * A strategy that handles a timezone field in the parsing pattern\n     */\n    private static class TimeZoneStrategy implements Strategy {\n\n        final String validTimeZoneChars;\n        final SortedMap<String, TimeZone> tzNames= new TreeMap<String, TimeZone>(String.CASE_INSENSITIVE_ORDER);\n\n        /**\n         * Construct a Strategy that parses a TimeZone\n         * @param locale The Locale\n         */\n        TimeZoneStrategy(Locale locale) {\n            for(String id : TimeZone.getAvailableIDs()) {\n                if(id.startsWith(\"GMT\")) {\n                    continue;\n                }\n                TimeZone tz= TimeZone.getTimeZone(id);\n                tzNames.put(tz.getDisplayName(false, TimeZone.SHORT, locale), tz);\n                tzNames.put(tz.getDisplayName(false, TimeZone.LONG, locale), tz);\n                if(tz.useDaylightTime()) {\n                    tzNames.put(tz.getDisplayName(true, TimeZone.SHORT, locale), tz);\n                    tzNames.put(tz.getDisplayName(true, TimeZone.LONG, locale), tz);\n                }\n            }\n            StringBuilder sb= new StringBuilder();\n            sb.append(\"(GMT[+\\\\-]\\\\d{0,1}\\\\d{2}|[+\\\\-]\\\\d{2}:?\\\\d{2}|\");\n            for(String id : tzNames.keySet()) {\n                escapeRegex(sb, id, false).append('|');\n            }\n            sb.setCharAt(sb.length()-1, ')');\n            validTimeZoneChars= sb.toString();\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean isNumber() {\n            return false;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public boolean addRegex(FastDateParser parser, StringBuilder regex) {\n            regex.append(validTimeZoneChars);\n            return true;\n        }\n\n        /**\n         * {@inheritDoc}\n         */\n        @Override\n        public void setCalendar(FastDateParser parser, Calendar cal, String value) {\n            TimeZone tz;\n            if(value.charAt(0)=='+' || value.charAt(0)=='-') {\n                tz= TimeZone.getTimeZone(\"GMT\"+value);\n            }\n            else if(value.startsWith(\"GMT\")) {\n                tz= TimeZone.getTimeZone(value);\n            }\n            else {\n                tz= tzNames.get(value);\n                if(tz==null) {\n                    throw new IllegalArgumentException(value + \" is not a supported timezone name\");\n                }\n            }\n            cal.setTimeZone(tz);\n        }\n    }\n\n\n    private static final Strategy ERA_STRATEGY = new TextStrategy(Calendar.ERA);\n    private static final Strategy DAY_OF_WEEK_STRATEGY = new TextStrategy(Calendar.DAY_OF_WEEK);\n    private static final Strategy AM_PM_STRATEGY = new TextStrategy(Calendar.AM_PM);\n    private static final Strategy TEXT_MONTH_STRATEGY = new TextStrategy(Calendar.MONTH);\n\n    private static final Strategy NUMBER_MONTH_STRATEGY = new NumberStrategy(Calendar.MONTH) {\n        @Override\n        public int modify(int iValue) {\n            return iValue-1;\n        }\n    };\n    private static final Strategy LITERAL_YEAR_STRATEGY = new NumberStrategy(Calendar.YEAR);\n    private static final Strategy WEEK_OF_YEAR_STRATEGY = new NumberStrategy(Calendar.WEEK_OF_YEAR);\n    private static final Strategy WEEK_OF_MONTH_STRATEGY = new NumberStrategy(Calendar.WEEK_OF_MONTH);\n    private static final Strategy DAY_OF_YEAR_STRATEGY = new NumberStrategy(Calendar.DAY_OF_YEAR);\n    private static final Strategy DAY_OF_MONTH_STRATEGY = new NumberStrategy(Calendar.DAY_OF_MONTH);\n    private static final Strategy DAY_OF_WEEK_IN_MONTH_STRATEGY = new NumberStrategy(Calendar.DAY_OF_WEEK_IN_MONTH);\n    private static final Strategy HOUR_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY);\n    private static final Strategy MODULO_HOUR_OF_DAY_STRATEGY = new NumberStrategy(Calendar.HOUR_OF_DAY) {\n        @Override\n        public int modify(int iValue) {\n            return iValue%24;\n        }\n    };\n    private static final Strategy MODULO_HOUR_STRATEGY = new NumberStrategy(Calendar.HOUR) {\n        @Override\n        public int modify(int iValue) {\n            return iValue%12;\n        }\n    };\n    private static final Strategy HOUR_STRATEGY = new NumberStrategy(Calendar.HOUR);\n    private static final Strategy MINUTE_STRATEGY = new NumberStrategy(Calendar.MINUTE);\n    private static final Strategy SECOND_STRATEGY = new NumberStrategy(Calendar.SECOND);\n    private static final Strategy MILLISECOND_STRATEGY = new NumberStrategy(Calendar.MILLISECOND);\n}"
            }
        ]
    },
    {
        "PatchId": "Math_2_repairllama-ir4_patch_3.diff",
        "BugId": "Math_2",
        "PatchedMethods": [
            {
                "DevIntention": "get|numerical|mean",
                "OrgCode": "public double getNumericalMean() {\n        return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n    }",
                "PatCode": "public double getNumericalMean() {\n// buggy code\n//         return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n       return (double) getSampleSize() * getNumberOfSuccesses() / (double) getPopulationSize();\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_80_repairllama-ir4_patch_0.diff",
        "BugId": "Math_80",
        "PatchedMethods": [
            {
                "DevIntention": "flip|if|warranted",
                "OrgCode": "private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }",
                "PatCode": "private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// buggy code\n//             int j = 4 * n - 1;\n           int j = 4 * (n - 1);\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_12_repairllama-ir4_patch_0.diff",
        "BugId": "Chart_12",
        "PatchedMethods": [
            {
                "DevIntention": "multiple|pie|plot",
                "OrgCode": "public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n        this.dataset = dataset;\n        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }",
                "PatCode": "public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n// buggy code\n//         this.dataset = dataset;\n       setDataset(dataset);\n        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_8_repairllama-ir4_patch_6.diff",
        "BugId": "Math_8",
        "PatchedMethods": [
            {
                "DevIntention": "sample",
                "OrgCode": "public T[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                    sampleSize);\n        }\n\n        final T[]out = (T[]) java.lang.reflect.Array.newInstance(singletons.get(0).getClass(), sampleSize);\n\n        for (int i = 0; i < sampleSize; i++) {\n            out[i] = sample();\n        }\n\n        return out;\n\n    }",
                "PatCode": "public Object[] sample(int sampleSize) throws NotStrictlyPositiveException {\n        if (sampleSize <= 0) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.NUMBER_OF_SAMPLES,\n                    sampleSize);\n        }\n        final Object[] out = new Object[sampleSize];\n        for (int i = 0; i < sampleSize; i++) {\n            out[i] = sample();\n        }\n        return out;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_79_repairllama-ir4_patch_8.diff",
        "BugId": "Math_79",
        "PatchedMethods": [
            {
                "DevIntention": "distance",
                "OrgCode": "public static double distance(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }",
                "PatCode": "public static double distance(int[] p1, int[] p2) {\n// buggy code\n//       int sum = 0;\n//       for (int i = 0; i < p1.length; i++) {\n//           final int dp = p1[i] - p2[i];\n     double sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final double dp = (p1[i] - p2[i]);\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }\n\n    /**\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>&infin;</sub> distance between the two points\n     */\n    public static double distanceInf(double[] p1, double[] p2) {\n        double max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    /**\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>&infin;</sub> distance between the two points\n     */\n    public static int distanceInf(int[] p1, int[] p2) {\n        int max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n\n}"
            }
        ]
    },
    {
        "PatchId": "Chart_7_repairllama-ir4_patch_0.diff",
        "BugId": "Chart_7",
        "PatchedMethods": [
            {
                "DevIntention": "update|bounds",
                "OrgCode": "private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }",
                "PatCode": "private void updateBounds(TimePeriod period, int index) {\n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        if (this.maxMiddleIndex >= 0) {\n// buggy code\n//             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n//                 .getTime();\n//             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n           long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_41_repairllama-ir4_patch_0.diff",
        "BugId": "Math_41",
        "PatchedMethods": [
            {
                "DevIntention": "evaluate",
                "OrgCode": "public double evaluate(final double[] values, final double[] weights,\n                           final double mean, final int begin, final int length) {\n\n        double var = Double.NaN;\n\n        if (test(values, weights, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += weights[i] * (dev * dev);\n                    accum2 += weights[i] * dev;\n                }\n\n                double sumWts = 0;\n                for (int i = 0; i < weights.length; i++) {\n                    sumWts += weights[i];\n                }\n\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n                }\n            }\n        }\n        return var;\n    }",
                "PatCode": "public double evaluate(final double[] values, final double[] weights,\n                           final double mean, final int begin, final int length) {\n        double var = Double.NaN;\n        if (test(values, weights, begin, length)) {\n            if (length == 1) {\n                var = 0.0;\n            } else if (length > 1) {\n                double accum = 0.0;\n                double dev = 0.0;\n                double accum2 = 0.0;\n                for (int i = begin; i < begin + length; i++) {\n                    dev = values[i] - mean;\n                    accum += weights[i] * (dev * dev);\n                    accum2 += weights[i] * dev;\n                }\n                double sumWts = 0;\n// buggy code\n//                 for (int i = 0; i < weights.length; i++) {\n               for (int i = begin; i < begin + length; i++) {\n                    sumWts += weights[i];\n                }\n                if (isBiasCorrected) {\n                    var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0);\n                } else {\n                    var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n                }\n            }\n        }\n        return var;\n    }\n\n    /**\n     * <p>Returns the weighted variance of the values in the input array, using\n     * the precomputed weighted mean value.</p>\n     * <p>\n     * Uses the formula <pre>\n     *   &Sigma;(weights[i]*(values[i] - mean)<sup>2</sup>)/(&Sigma;(weights[i]) - 1)\n     * </pre></p>\n     * <p>\n     * The formula used assumes that the supplied mean value is the weighted arithmetic\n     * mean of the sample data, not a known population parameter. This method\n     * is supplied only to save computation when the mean has already been\n     * computed.</p>\n     * <p>\n     * This formula will not return the same result as the unweighted variance when all\n     * weights are equal, unless all weights are equal to 1. The formula assumes that\n     * weights are to be treated as \"expansion values,\" as will be the case if for example\n     * the weights represent frequency counts. To normalize weights so that the denominator\n     * in the variance computation equals the length of the input vector minus one, use <pre>\n     *   <code>evaluate(values, MathArrays.normalizeArray(weights, values.length), mean); </code>\n     * </pre>\n     * <p>\n     * Returns 0 for a single-value (i.e. length = 1) sample.</p>\n     * <p>\n     * Throws <code>IllegalArgumentException</code> if any of the following are true:\n     * <ul><li>the values array is null</li>\n     *     <li>the weights array is null</li>\n     *     <li>the weights array does not have the same length as the values array</li>\n     *     <li>the weights array contains one or more infinite values</li>\n     *     <li>the weights array contains one or more NaN values</li>\n     *     <li>the weights array contains negative values</li>\n     * </ul></p>\n     * <p>\n     * Does not change the internal state of the statistic.</p>\n     *\n     * @param values the input array\n     * @param weights the weights array\n     * @param mean the precomputed weighted mean value\n     * @return the variance of the values or Double.NaN if length = 0\n     * @throws IllegalArgumentException if the parameters are not valid\n     * @since 2.1\n     */\n    public double evaluate(final double[] values, final double[] weights, final double mean) {\n        return evaluate(values, weights, mean, 0, values.length);\n    }\n\n    /**\n     * @return Returns the isBiasCorrected.\n     */\n    public boolean isBiasCorrected() {\n        return isBiasCorrected;\n    }\n\n    /**\n     * @param biasCorrected The isBiasCorrected to set.\n     */\n    public void setBiasCorrected(boolean biasCorrected) {\n        this.isBiasCorrected = biasCorrected;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public Variance copy() {\n        Variance result = new Variance();\n        copy(this, result);\n        return result;\n    }\n\n    /**\n     * Copies source to dest.\n     * <p>Neither source nor dest can be null.</p>\n     *\n     * @param source Variance to copy\n     * @param dest Variance to copy to\n     * @throws NullArgumentException if either source or dest is null\n     */\n    public static void copy(Variance source, Variance dest)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(source);\n        MathUtils.checkNotNull(dest);\n        dest.setData(source.getDataRef());\n        dest.moment = source.moment.copy();\n        dest.isBiasCorrected = source.isBiasCorrected;\n        dest.incMoment = source.incMoment;\n    }\n}"
            }
        ]
    },
    {
        "PatchId": "Math_58_repairllama-ir4_patch_5.diff",
        "BugId": "Math_58",
        "PatchedMethods": [
            {
                "DevIntention": "fit",
                "OrgCode": "public double[] fit() {\n        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n        return fit(new Gaussian.Parametric(), guess);\n    }",
                "PatCode": "public double[] fit() {\n        final double[] guess = (new ParameterGuesser(getObservations())).guess();\n// buggy code\n//         return fit(new Gaussian.Parametric(), guess);\n       return fit(guess);\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_45_repairllama-ir4_patch_4.diff",
        "BugId": "Lang_45",
        "PatchedMethods": [
            {
                "DevIntention": "abbreviate",
                "OrgCode": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n        if (upper < lower) {\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }",
                "PatCode": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n// buggy code\n// \n       }\n        if (lower > str.length()) {\n            lower = str.length();\n        }\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        if (upper < lower) {\n            upper = lower;\n        }\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }"
            }
        ]
    },
    {
        "PatchId": "Closure_13_repairllama-ir4_patch_3.diff",
        "BugId": "Closure_13",
        "PatchedMethods": [
            {
                "DevIntention": "process",
                "OrgCode": "public void process(Node externs, Node root) {\n    PeepholeChangeHandler handler = new PeepholeChangeHandler();\n    compiler.addChangeHandler(handler);\n    beginTraversal();\n    traverse(root);\n    endTraversal();\n    compiler.removeChangeHandler(handler);\n  }",
                "PatCode": "public void process(Node externs, Node root) {\n    PeepholeChangeHandler handler = new PeepholeChangeHandler();\n    compiler.addChangeHandler(handler);\n    beginTraversal();\n    traverse(root);\n    endTraversal();\n    compiler.removeChangeHandler(handler);\n  }"
            },
            {
                "DevIntention": "traverse",
                "OrgCode": "private void traverse(Node node) {\n    // The goal here is to avoid retraversing\n    // the entire AST to catch newly created opportunities.\n    // So we track whether a \"unit of code\" has changed,\n    // and revisit immediately.\n    if (!shouldVisit(node)) {\n      return;\n    }\n\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n        traverse(c);\n        Node next = c.getNext();\n        c = next;\n      }\n\n      visit(node);\n      visits++;\n\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n\n    exitNode(node);\n  }",
                "PatCode": "private void traverse(Node node) {\n    if (!shouldVisit(node)) {\n      return;\n    }\n    int visits = 0;\n    do {\n      Node c = node.getFirstChild();\n      while(c != null) {\n// buggy code\n//         traverse(c);\n//         Node next = c.getNext();\n        Node next = c.getNext();\n        traverse(c);\n        c = next;\n      }\n      visit(node);\n      visits++;\n      Preconditions.checkState(visits < 10000, \"too many interations\");\n    } while (shouldRetraverse(node));\n    exitNode(node);\n  }"
            }
        ]
    },
    {
        "PatchId": "Math_53_repairllama-ir4_patch_3.diff",
        "BugId": "Math_53",
        "PatchedMethods": [
            {
                "DevIntention": "add",
                "OrgCode": "public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }",
                "PatCode": "public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n// buggy code\n// \n       if (isNaN() || rhs.isNaN()) {\n            return NaN;\n        }\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_1_repairllama-ir4_patch_0.diff",
        "BugId": "Chart_1",
        "PatchedMethods": [
            {
                "DevIntention": "get|legend|items",
                "OrgCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset != null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }",
                "PatCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n// buggy code\n//         if (dataset != null) {\n       if (dataset == null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Adds an entity with the specified hotspot.\n     *\n     * @param entities  the entity collection.\n     * @param hotspot  the hotspot (<code>null</code> not permitted).\n     * @param dataset  the dataset.\n     * @param row  the row index.\n     * @param column  the column index.\n     * @param selected  is the item selected?\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected) {\n\n        if (hotspot == null) {\n            throw new IllegalArgumentException(\"Null 'hotspot' argument.\");\n        }\n        addEntity(entities, hotspot, dataset, row, column, selected, 0.0, 0.0);\n    }\n\n    /**\n     * Adds an entity to the collection.\n     *\n     * @param entities  the entity collection being populated.\n     * @param hotspot  the entity area (if <code>null</code> a default will be\n     *              used).\n     * @param dataset  the dataset.\n     * @param row  the series.\n     * @param column  the item.\n     * @param selected  is the item selected?\n     * @param entityX  the entity's center x-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     * @param entityY  the entity's center y-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            double entityX, double entityY) {\n        if (!getItemCreateEntity(row, column, selected)) {\n            return;\n        }\n        Shape s = hotspot;\n        if (hotspot == null) {\n            double r = getDefaultEntityRadius();\n            double w = r * 2;\n            if (getPlot().getOrientation() == PlotOrientation.VERTICAL) {\n                s = new Ellipse2D.Double(entityX - r, entityY - r, w, w);\n            }\n            else {\n                s = new Ellipse2D.Double(entityY - r, entityX - r, w, w);\n            }\n        }\n        String tip = null;\n        CategoryToolTipGenerator generator = getToolTipGenerator(row, column,\n                selected);\n        if (generator != null) {\n            tip = generator.generateToolTip(dataset, row, column);\n        }\n        String url = null;\n        CategoryURLGenerator urlster = getURLGenerator(row, column, selected);\n        if (urlster != null) {\n            url = urlster.generateURL(dataset, row, column);\n        }\n        CategoryItemEntity entity = new CategoryItemEntity(s, tip, url,\n                dataset, dataset.getRowKey(row), dataset.getColumnKey(column));\n        entities.add(entity);\n    }\n\n        /**\n     * Returns a shape that can be used for hit testing on a data item drawn\n     * by the renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area within which the data is being rendered.\n     * @param plot  the plot (can be used to obtain standard color\n     *              information etc).\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the dataset.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param selected  is the item selected?\n     *\n     * @return A shape equal to the hot spot for a data item.\n     */\n    public Shape createHotSpotShape(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state) {\n        throw new RuntimeException(\"Not implemented.\");\n    }\n\n    /**\n     * Returns the rectangular bounds for the hot spot for an item drawn by\n     * this renderer.  This is intended to provide a quick test for\n     * eliminating data points before more accurate testing against the\n     * shape returned by createHotSpotShape().\n     *\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     * @param result\n     * @return\n     */\n    public Rectangle2D createHotSpotBounds(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state, Rectangle2D result) {\n        if (result == null) {\n            result = new Rectangle();\n        }\n        Comparable key = dataset.getColumnKey(column);\n        Number y = dataset.getValue(row, column);\n        if (y == null) {\n            return null;\n        }\n        double xx = domainAxis.getCategoryMiddle(key,\n                plot.getCategoriesForAxis(domainAxis),\n                dataArea, plot.getDomainAxisEdge());\n        double yy = rangeAxis.valueToJava2D(y.doubleValue(), dataArea,\n                plot.getRangeAxisEdge());\n        result.setRect(xx - 2, yy - 2, 4, 4);\n        return result;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified point (xx, yy) in Java2D\n     * space falls within the \"hot spot\" for the specified data item, and\n     * <code>false</code> otherwise.\n     *\n     * @param xx\n     * @param yy\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     *\n     * @return\n     *\n     * @since 1.2.0\n     */\n    public boolean hitTest(double xx, double yy, Graphics2D g2,\n            Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,\n            ValueAxis rangeAxis, CategoryDataset dataset, int row, int column,\n            boolean selected, CategoryItemRendererState state) {\n        Rectangle2D bounds = createHotSpotBounds(g2, dataArea, plot,\n                domainAxis, rangeAxis, dataset, row, column, selected,\n                state, null);\n        if (bounds == null) {\n            return false;\n        }\n        // FIXME:  if the following test passes, we should then do the more\n        // expensive test against the hotSpotShape\n        return bounds.contains(xx, yy);\n    }\n    \n}"
            }
        ]
    },
    {
        "PatchId": "Chart_9_repairllama-ir4_patch_7.diff",
        "BugId": "Chart_9",
        "PatchedMethods": [
            {
                "DevIntention": "create|copy",
                "OrgCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if (endIndex < 0) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }",
                "PatCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {\n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n// buggy code\n//         if (endIndex < 0) {\n       if ((endIndex < 0) || (startIndex > endIndex)) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param object  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                s.getDomainDescription())) {\n            return false;\n        }\n\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                s.getRangeDescription())) {\n            return false;\n        }\n\n        if (!getClass().equals(s.getClass())) {\n            return false;\n        }\n\n        if (getMaximumItemAge() != s.getMaximumItemAge()) {\n            return false;\n        }\n\n        if (getMaximumItemCount() != s.getMaximumItemCount()) {\n            return false;\n        }\n\n        int count = getItemCount();\n        if (count != s.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(s.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Chart_26_repairllama-ir4_patch_0.diff",
        "BugId": "Chart_26",
        "PatchedMethods": [
            {
                "DevIntention": "draw|label",
                "OrgCode": "protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n\n        // it is unlikely that 'state' will be null, but check anyway...\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        \n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        \n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        return state;\n\n    }",
                "PatCode": "protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n// buggy code\n//                 EntityCollection entities = owner.getEntityCollection();\n//                 if (entities != null) {\n//                     entities.add(new AxisLabelEntity(this, hotspot, \n//                             this.labelToolTip, this.labelURL));\n//                 }\n           if (owner != null) {\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        }\n        return state;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_69_repairllama-ir4_patch_8.diff",
        "BugId": "Math_69",
        "PatchedMethods": [
            {
                "DevIntention": "get|correlation|p|values",
                "OrgCode": "public RealMatrix getCorrelationPValues() throws MathException {\n        TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n        int nVars = correlationMatrix.getColumnDimension();\n        double[][] out = new double[nVars][nVars];\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < nVars; j++) {\n                if (i == j) {\n                    out[i][j] = 0d;\n                } else {\n                    double r = correlationMatrix.getEntry(i, j);\n                    double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n                    out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                }\n            }\n        }\n        return new BlockRealMatrix(out);\n    }",
                "PatCode": "public RealMatrix getCorrelationPValues() throws MathException {\n        TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n        int nVars = correlationMatrix.getColumnDimension();\n        double[][] out = new double[nVars][nVars];\n        for (int i = 0; i < nVars; i++) {\n            for (int j = 0; j < nVars; j++) {\n                if (i == j) {\n                    out[i][j] = 0d;\n                } else {\n                    double r = correlationMatrix.getEntry(i, j);\n                    double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n// buggy code\n//                     out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                   out[i][j] = 2 * tDistribution.cumulativeProbability(-t);\n                }\n            }\n        }\n        return new BlockRealMatrix(out);\n    }"
            }
        ]
    },
    {
        "PatchId": "Mockito_38_repairllama-ir4_patch_4.diff",
        "BugId": "Mockito_38",
        "PatchedMethods": [
            {
                "DevIntention": "safely|matches",
                "OrgCode": "private boolean safelyMatches(Matcher m, Object arg) {\n        try {\n            return m.matches(arg);\n        } catch (Throwable t) {\n            return false;\n        }\n    }",
                "PatCode": "private boolean safelyMatches(Matcher m, Object arg) {\n        try {\n            return m.matches(arg);\n        } catch (Throwable t) {\n            return false;\n        }\n    }"
            },
            {
                "DevIntention": "to|string|equals",
                "OrgCode": "private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg.toString());\n    }",
                "PatCode": "private boolean toStringEquals(Matcher m, Object arg) {\n// buggy code\n//         return StringDescription.toString(m).equals(arg.toString());\n       return StringDescription.toString(m).equals(String.valueOf(arg));\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_11_repairllama-ir4_patch_7.diff",
        "BugId": "Chart_11",
        "PatchedMethods": [
            {
                "DevIntention": "equal",
                "OrgCode": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p1.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }",
                "PatCode": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n// buggy code\n//         PathIterator iterator2 = p1.getPathIterator(null);\n       PathIterator iterator2 = p2.getPathIterator(null); \n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_85_repairllama-ir4_patch_0.diff",
        "BugId": "Math_85",
        "PatchedMethods": [
            {
                "DevIntention": "bracket",
                "OrgCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }",
                "PatCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n// buggy code\n//         if (fa * fb >= 0.0 ) {\n       if (fa * fb > 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        return new double[]{a, b};\n    }\n\n    /**\n     * Compute the midpoint of two values.\n     * \n     * @param a first value.\n     * @param b second value.\n     * @return the midpoint. \n     */\n    public static double midpoint(double a, double b) {\n        return (a + b) * .5;\n    }\n    \n    /**\n     * Checks to see if f is null, throwing IllegalArgumentException if so.\n     * @param f  input function\n     * @throws IllegalArgumentException if f is null\n     */\n    private static void setup(UnivariateRealFunction f) {\n        if (f == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n    }\n\n    /** Holder for the factory.\n     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n     */\n    private static class LazyHolder {\n        /** Cached solver factory */\n        private static final UnivariateRealSolverFactory FACTORY =\n            UnivariateRealSolverFactory.newInstance();\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Closure_62_repairllama-ir4_patch_0.diff",
        "BugId": "Closure_62",
        "PatchedMethods": [
            {
                "DevIntention": "format|warning",
                "OrgCode": "public String formatWarning(JSError warning) {\n    return format(warning, true);\n  }",
                "PatCode": "public String formatWarning(JSError warning) {\n    return format(warning, true);\n  }"
            },
            {
                "DevIntention": "format",
                "OrgCode": "private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n      if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }",
                "PatCode": "private String format(JSError error, boolean warning) {\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n      if (excerpt.equals(LINE)\n// buggy code\n//           && 0 <= charno && charno < sourceExcerpt.length()) {\n         && 0 <= charno && charno <= sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n\n  /**\n   * Formats a region by appending line numbers in front, e.g.\n   * <pre>   9| if (foo) {\n   *   10|   alert('bar');\n   *   11| }</pre>\n   * and return line excerpt without any modification.\n   */\n  static class LineNumberingFormatter implements ExcerptFormatter {\n    public String formatLine(String line, int lineNumber) {\n      return line;\n    }\n\n    public String formatRegion(Region region) {\n      if (region == null) {\n        return null;\n      }\n      String code = region.getSourceExcerpt();\n      if (code.length() == 0) {\n        return null;\n      }\n\n      // max length of the number display\n      int numberLength = Integer.toString(region.getEndingLineNumber())\n          .length();\n\n      // formatting\n      StringBuilder builder = new StringBuilder(code.length() * 2);\n      int start = 0;\n      int end = code.indexOf('\\n', start);\n      int lineNumber = region.getBeginningLineNumber();\n      while (start >= 0) {\n        // line extraction\n        String line;\n        if (end < 0) {\n          line = code.substring(start);\n          if (line.length() == 0) {\n            return builder.substring(0, builder.length() - 1);\n          }\n        } else {\n          line = code.substring(start, end);\n        }\n        builder.append(\"  \");\n\n        // nice spaces for the line number\n        int spaces = numberLength - Integer.toString(lineNumber).length();\n        builder.append(Strings.repeat(\" \", spaces));\n        builder.append(lineNumber);\n        builder.append(\"| \");\n\n        // end & update\n        if (end < 0) {\n          builder.append(line);\n          start = -1;\n        } else {\n          builder.append(line);\n          builder.append('\\n');\n          start = end + 1;\n          end = code.indexOf('\\n', start);\n          lineNumber++;\n        }\n      }\n      return builder.toString();\n    }\n  }\n}"
            }
        ]
    },
    {
        "PatchId": "Closure_86_repairllama-ir4_patch_0.diff",
        "BugId": "Closure_86",
        "PatchedMethods": [
            {
                "DevIntention": "evaluates|to|local|value",
                "OrgCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n        return true;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }",
                "PatCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n// buggy code\n//         return true;\n       return locals.apply(value);\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return true;\n      case Token.IN:\n        return true;\n      default:\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }"
            }
        ]
    },
    {
        "PatchId": "Math_59_repairllama-ir4_patch_8.diff",
        "BugId": "Math_59",
        "PatchedMethods": [
            {
                "DevIntention": "max",
                "OrgCode": "public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n    }",
                "PatCode": "public static float max(final float a, final float b) {\n// buggy code\n//         return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n       return (b <= a) ? a : (Float.isNaN(a + b) ? Float.NaN : b);\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_101_repairllama-ir4_patch_0.diff",
        "BugId": "Math_101",
        "PatchedMethods": [
            {
                "DevIntention": "parse",
                "OrgCode": "public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse real\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            // invalid real number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse sign\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse imaginary\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            // invalid imaginary number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse imaginary character\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if (\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            // set index back to initial, error index should be the start index\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }",
                "PatCode": "public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n        parseAndIgnoreWhitespace(source, pos);\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        parseAndIgnoreWhitespace(source, pos);\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n// buggy code\n//         if (\n       if (endIndex > source.length() ||\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_51_repairllama-ir4_patch_9.diff",
        "BugId": "Lang_51",
        "PatchedMethods": [
            {
                "DevIntention": "to|boolean",
                "OrgCode": "public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }",
                "PatCode": "public static boolean toBoolean(String str) {\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n// buggy code\n// \n               if (ch == 'n') {\n                    return \n                        (str.charAt(1) == 'o' || str.charAt(1) == 'O') &&\n                        (str.charAt(2) == 'f' || str.charAt(2) == 'F');\n                }\n                return false;\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_85_repairllama-ir4_patch_3.diff",
        "BugId": "Math_85",
        "PatchedMethods": [
            {
                "DevIntention": "bracket",
                "OrgCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }",
                "PatCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n// buggy code\n//         if (fa * fb >= 0.0 ) {\n       if (numIterations >= maximumIterations) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        return new double[]{a, b};\n    }\n\n    /**\n     * Compute the midpoint of two values.\n     * \n     * @param a first value.\n     * @param b second value.\n     * @return the midpoint. \n     */\n    public static double midpoint(double a, double b) {\n        return (a + b) * .5;\n    }\n    \n    /**\n     * Checks to see if f is null, throwing IllegalArgumentException if so.\n     * @param f  input function\n     * @throws IllegalArgumentException if f is null\n     */\n    private static void setup(UnivariateRealFunction f) {\n        if (f == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n    }\n\n    /** Holder for the factory.\n     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n     */\n    private static class LazyHolder {\n        /** Cached solver factory */\n        private static final UnivariateRealSolverFactory FACTORY =\n            UnivariateRealSolverFactory.newInstance();\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Mockito_29_repairllama-ir4_patch_2.diff",
        "BugId": "Mockito_29",
        "PatchedMethods": [
            {
                "DevIntention": "describe|to",
                "OrgCode": "public void describeTo(Description description) {\n        description.appendText(\"same(\");\n        appendQuoting(description);\n        description.appendText(wanted.toString());\n        appendQuoting(description);\n        description.appendText(\")\");\n    }",
                "PatCode": "public void describeTo(Description description) {\n        description.appendText(\"same(\");\n        appendQuoting(description);\n// buggy code\n//         description.appendText(wanted.toString());\n       description.appendText(String.valueOf(wanted));\n        appendQuoting(description);\n        description.appendText(\")\");\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_58_repairllama-ir4_patch_1.diff",
        "BugId": "Lang_58",
        "PatchedMethods": [
            {
                "DevIntention": "create|number",
                "OrgCode": "public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear \n            // to be in specification of class. OS X Java parses it to \n            // a wrong value.\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n\n        if (decPos > -1) {\n\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            //Requesting a specific type..\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n                        && isDigits(numeric.substring(1))\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                            //Too big for a long\n                        }\n                        return createBigInteger(numeric);\n\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            //If it's too big for a float or the float value = 0 and the string\n                            //has non-zeros in it, then float does not have the precision we want\n                            return f;\n                        }\n\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                        // ignore the bad number\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                        // ignore the bad number\n                    }\n                    //Fall through\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n\n            }\n        } else {\n            //User doesn't have a preference on the return type, so let's start\n            //small and go from there...\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                //Must be an int,long,bigint\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                return createBigInteger(str);\n\n            } else {\n                //Must be a float,double,BigDec\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                    // ignore the bad number\n                }\n\n                return createBigDecimal(str);\n\n            }\n        }\n    }",
                "PatCode": "public static Number createNumber(String str) throws NumberFormatException {\n        if (str == null) {\n            return null;\n        }\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        if (str.startsWith(\"--\")) {\n            return null;\n        }\n        if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n            return createInteger(str);\n        }   \n        char lastChar = str.charAt(str.length() - 1);\n        String mant;\n        String dec;\n        String exp;\n        int decPos = str.indexOf('.');\n        int expPos = str.indexOf('e') + str.indexOf('E') + 1;\n        if (decPos > -1) {\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                }\n                dec = str.substring(decPos + 1, expPos);\n            } else {\n                dec = str.substring(decPos + 1);\n            }\n            mant = str.substring(0, decPos);\n        } else {\n            if (expPos > -1) {\n                mant = str.substring(0, expPos);\n            } else {\n                mant = str;\n            }\n            dec = null;\n        }\n        if (!Character.isDigit(lastChar)) {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length() - 1);\n            } else {\n                exp = null;\n            }\n            String numeric = str.substring(0, str.length() - 1);\n            boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n            switch (lastChar) {\n                case 'l' :\n                case 'L' :\n                    if (dec == null\n                        && exp == null\n// buggy code\n//                         && isDigits(numeric.substring(1))\n//                         && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n                        try {\n                            return createLong(numeric);\n                        } catch (NumberFormatException nfe) {\n                        }\n                        return createBigInteger(numeric);\n                    }\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n                case 'f' :\n                case 'F' :\n                    try {\n                        Float f = NumberUtils.createFloat(numeric);\n                        if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                            return f;\n                        }\n                    } catch (NumberFormatException nfe) {\n                    }\n                case 'd' :\n                case 'D' :\n                    try {\n                        Double d = NumberUtils.createDouble(numeric);\n                        if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) {\n                            return d;\n                        }\n                    } catch (NumberFormatException nfe) {\n                    }\n                    try {\n                        return createBigDecimal(numeric);\n                    } catch (NumberFormatException e) {\n                    }\n                default :\n                    throw new NumberFormatException(str + \" is not a valid number.\");\n            }\n        } else {\n            if (expPos > -1 && expPos < str.length() - 1) {\n                exp = str.substring(expPos + 1, str.length());\n            } else {\n                exp = null;\n            }\n            if (dec == null && exp == null) {\n                try {\n                    return createInteger(str);\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    return createLong(str);\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigInteger(str);\n            } else {\n                boolean allZeros = isAllZeros(mant) && isAllZeros(exp);\n                try {\n                    Float f = createFloat(str);\n                    if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) {\n                        return f;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                try {\n                    Double d = createDouble(str);\n                    if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) {\n                        return d;\n                    }\n                } catch (NumberFormatException nfe) {\n                }\n                return createBigDecimal(str);\n            }\n        }\n    }\n\n    /**\n     * <p>Utility method for {@link #createNumber(java.lang.String)}.</p>\n     *\n     * <p>Returns <code>true</code> if s is <code>null</code>.</p>\n     * \n     * @param str  the String to check\n     * @return if it is all zeros or <code>null</code>\n     */\n    private static boolean isAllZeros(String str) {\n        if (str == null) {\n            return true;\n        }\n        for (int i = str.length() - 1; i >= 0; i--) {\n            if (str.charAt(i) != '0') {\n                return false;\n            }\n        }\n        return str.length() > 0;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Convert a <code>String</code> to a <code>Float</code>.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Float</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Float createFloat(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Float.valueOf(str);\n    }\n\n    /**\n     * <p>Convert a <code>String</code> to a <code>Double</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Double</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Double createDouble(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Double.valueOf(str);\n    }\n\n    /**\n     * <p>Convert a <code>String</code> to a <code>Integer</code>, handling\n     * hex and octal notations.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Integer</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Integer createInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        // decode() handles 0xAABD and 0777 (hex and octal) as well.\n        return Integer.decode(str);\n    }\n\n    /**\n     * <p>Convert a <code>String</code> to a <code>Long</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>Long</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static Long createLong(String str) {\n        if (str == null) {\n            return null;\n        }\n        return Long.valueOf(str);\n    }\n\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigInteger</code>.</p>\n     *\n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     * \n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigInteger</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigInteger createBigInteger(String str) {\n        if (str == null) {\n            return null;\n        }\n        return new BigInteger(str);\n    }\n\n    /**\n     * <p>Convert a <code>String</code> to a <code>BigDecimal</code>.</p>\n     * \n     * <p>Returns <code>null</code> if the string is <code>null</code>.</p>\n     *\n     * @param str  a <code>String</code> to convert, may be null\n     * @return converted <code>BigDecimal</code>\n     * @throws NumberFormatException if the value cannot be converted\n     */\n    public static BigDecimal createBigDecimal(String str) {\n        if (str == null) {\n            return null;\n        }\n        // handle JDK1.3.1 bug where \"\" throws IndexOutOfBoundsException\n        if (StringUtils.isBlank(str)) {\n            throw new NumberFormatException(\"A blank string is not a valid number\");\n        }  \n        return new BigDecimal(str);\n    }\n\n    // Equals in array\n    //--------------------------------------------------------------------\n    /**\n     * <p>Whether the contents of two byte[] arrays are equal.</p>\n     * \n     * @param array1  first array to compare\n     * @param array2  second array to compare\n     * @return whether the two arrays are equal\n     */\n    public static boolean equals(byte[] array1, byte[] array2) {\n        if (array1 == array2) {\n            return true;\n        }\n        if (array1 == null || array2 == null) {\n            return false;\n        }\n        if (array1.length != array2.length) {\n            return false;\n        }\n\n        for (int i=0; i<array1.length; i++) {\n            if (array1[i] != array2[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * <p>Whether the contents of two short[] arrays are equal.</p>\n     * \n     * @param array1  first array to compare\n     * @param array2  second array to compare\n     * @return whether the two arrays are equal\n     */\n    public static boolean equals(short[] array1, short[] array2) {\n        if (array1 == array2) {\n            return true;\n        }\n        if (array1 == null || array2 == null) {\n            return false;\n        }\n        if (array1.length != array2.length) {\n            return false;\n        }\n\n        for (int i=0; i<array1.length; i++) {\n            if (array1[i] != array2[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * <p>Whether the contents of two int[] arrays are equal.</p>\n     * \n     * @param array1  first array to compare\n     * @param array2  second array to compare\n     * @return whether the two arrays are equal\n     */\n    public static boolean equals(int[] array1, int[] array2) {\n        if (array1 == array2) {\n            return true;\n        }\n        if (array1 == null || array2 == null) {\n            return false;\n        }\n        if (array1.length != array2.length) {\n            return false;\n        }\n\n        for (int i=0; i<array1.length; i++) {\n            if (array1[i] != array2[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * <p>Whether the contents of two long[] arrays are equal.</p>\n     * \n     * @param array1  first array to compare\n     * @param array2  second array to compare\n     * @return whether the two arrays are equal\n     */\n    public static boolean equals(long[] array1, long[] array2) {\n        if (array1 == array2) {\n            return true;\n        }\n        if (array1 == null || array2 == null) {\n            return false;\n        }\n        if (array1.length != array2.length) {\n            return false;\n        }\n\n        for (int i=0; i<array1.length; i++) {\n            if (array1[i] != array2[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * <p>Whether the contents of two float[] arrays are equal.</p>\n     * \n     * @param array1  first array to compare\n     * @param array2  second array to compare\n     * @return whether the two arrays are equal\n     */\n    public static boolean equals(float[] array1, float[] array2) {\n        if (array1 == array2) {\n            return true;\n        }\n        if (array1 == null || array2 == null) {\n            return false;\n        }\n        if (array1.length != array2.length) {\n            return false;\n        }\n\n        for (int i=0; i<array1.length; i++) {\n            if (compare(array1[i], array2[i]) != 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * <p>Whether the contents of two double[] arrays are equal.</p>\n     * \n     * @param array1  first array to compare\n     * @param array2  second array to compare\n     * @return whether the two arrays are equal\n     */\n    public static boolean equals(double[] array1, double[] array2) {\n        if (array1 == array2) {\n            return true;\n        }\n        if (array1 == null || array2 == null) {\n            return false;\n        }\n        if (array1.length != array2.length) {\n            return false;\n        }\n\n        for (int i=0; i<array1.length; i++) {\n            if (compare(array1[i], array2[i]) != 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Min in array\n    //--------------------------------------------------------------------\n    /**\n     * <p>Returns the minimum value in an array.</p>\n     * \n     * @param array  an array, must not be null or empty\n     * @return the minimum value in the array\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty\n     */\n    public static long min(long[] array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        // Finds and returns min\n        long min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    /**\n     * <p>Returns the minimum value in an array.</p>\n     * \n     * @param array  an array, must not be null or empty\n     * @return the minimum value in the array\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty\n     */\n    public static int min(int[] array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        // Finds and returns min\n        int min = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] < min) {\n                min = array[j];\n            }\n        }\n    \n        return min;\n    }\n\n    /**\n     * <p>Returns the minimum value in an array.</p>\n     * \n     * @param array  an array, must not be null or empty\n     * @return the minimum value in the array\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty\n     */\n    public static short min(short[] array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        // Finds and returns min\n        short min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    /**\n     * <p>Returns the minimum value in an array.</p>\n     * \n     * @param array  an array, must not be null or empty\n     * @return the minimum value in the array\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty\n     */\n    public static byte min(byte[] array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        // Finds and returns min\n        byte min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n     /**\n     * <p>Returns the minimum value in an array.</p>\n     * \n     * @param array  an array, must not be null or empty\n     * @return the minimum value in the array\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty\n     */\n    public static double min(double[] array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        // Finds and returns min\n        double min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    /**\n     * <p>Returns the minimum value in an array.</p>\n     * \n     * @param array  an array, must not be null or empty\n     * @return the minimum value in the array\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty\n     */\n    public static float min(float[] array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        // Finds and returns min\n        float min = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] < min) {\n                min = array[i];\n            }\n        }\n    \n        return min;\n    }\n\n    // Max in array\n    //--------------------------------------------------------------------\n    /**\n     * <p>Returns the maximum value in an array.</p>\n     * \n     * @param array  an array, must not be null or empty\n     * @return the minimum value in the array\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty\n     */\n    public static long max(long[] array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n\n        // Finds and returns max\n        long max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n\n        return max;\n    }\n\n    /**\n     * <p>Returns the maximum value in an array.</p>\n     * \n     * @param array  an array, must not be null or empty\n     * @return the minimum value in the array\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty\n     */\n    public static int max(int[] array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        // Finds and returns max\n        int max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n    \n        return max;\n    }\n\n    /**\n     * <p>Returns the maximum value in an array.</p>\n     * \n     * @param array  an array, must not be null or empty\n     * @return the minimum value in the array\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty\n     */\n    public static short max(short[] array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        // Finds and returns max\n        short max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n    \n        return max;\n    }\n\n    /**\n     * <p>Returns the maximum value in an array.</p>\n     * \n     * @param array  an array, must not be null or empty\n     * @return the minimum value in the array\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty\n     */\n    public static byte max(byte[] array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        // Finds and returns max\n        byte max = array[0];\n        for (int i = 1; i < array.length; i++) {\n            if (array[i] > max) {\n                max = array[i];\n            }\n        }\n    \n        return max;\n    }\n\n    /**\n     * <p>Returns the maximum value in an array.</p>\n     * \n     * @param array  an array, must not be null or empty\n     * @return the minimum value in the array\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty\n     */\n    public static double max(double[] array) {\n        // Validates input\n        if (array== null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n    \n        // Finds and returns max\n        double max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n    \n        return max;\n    }\n\n    /**\n     * <p>Returns the maximum value in an array.</p>\n     * \n     * @param array  an array, must not be null or empty\n     * @return the minimum value in the array\n     * @throws IllegalArgumentException if <code>array</code> is <code>null</code>\n     * @throws IllegalArgumentException if <code>array</code> is empty\n     */\n    public static float max(float[] array) {\n        // Validates input\n        if (array == null) {\n            throw new IllegalArgumentException(\"The Array must not be null\");\n        } else if (array.length == 0) {\n            throw new IllegalArgumentException(\"Array cannot be empty.\");\n        }\n\n        // Finds and returns max\n        float max = array[0];\n        for (int j = 1; j < array.length; j++) {\n            if (array[j] > max) {\n                max = array[j];\n            }\n        }\n\n        return max;\n    }\n     \n    // 3 param min\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets the minimum of three <code>long</code> values.</p>\n     * \n     * @param a  value 1\n     * @param b  value 2\n     * @param c  value 3\n     * @return  the smallest of the values\n     */\n    public static long min(long a, long b, long c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    /**\n     * <p>Gets the minimum of three <code>int</code> values.</p>\n     * \n     * @param a  value 1\n     * @param b  value 2\n     * @param c  value 3\n     * @return  the smallest of the values\n     */\n    public static int min(int a, int b, int c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    /**\n     * <p>Gets the minimum of three <code>short</code> values.</p>\n     * \n     * @param a  value 1\n     * @param b  value 2\n     * @param c  value 3\n     * @return  the smallest of the values\n     */\n    public static short min(short a, short b, short c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    /**\n     * <p>Gets the minimum of three <code>byte</code> values.</p>\n     * \n     * @param a  value 1\n     * @param b  value 2\n     * @param c  value 3\n     * @return  the smallest of the values\n     */\n    public static byte min(byte a, byte b, byte c) {\n        if (b < a) {\n            a = b;\n        }\n        if (c < a) {\n            a = c;\n        }\n        return a;\n    }\n\n    /**\n     * <p>Gets the minimum of three <code>double</code> values.</p>\n     * \n     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n     * returned. Infinity is handled.</p>\n     * \n     * @param a  value 1\n     * @param b  value 2\n     * @param c  value 3\n     * @return  the smallest of the values\n     */\n    public static double min(double a, double b, double c) {\n        return Math.min(Math.min(a, b), c);\n    }\n\n    /**\n     * <p>Gets the minimum of three <code>float</code> values.</p>\n     * \n     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n     * returned. Infinity is handled.</p>\n     *\n     * @param a  value 1\n     * @param b  value 2\n     * @param c  value 3\n     * @return  the smallest of the values\n     */\n    public static float min(float a, float b, float c) {\n        return Math.min(Math.min(a, b), c);\n    }\n\n    // 3 param max\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Gets the maximum of three <code>long</code> values.</p>\n     * \n     * @param a  value 1\n     * @param b  value 2\n     * @param c  value 3\n     * @return  the largest of the values\n     */\n    public static long max(long a, long b, long c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    /**\n     * <p>Gets the maximum of three <code>int</code> values.</p>\n     * \n     * @param a  value 1\n     * @param b  value 2\n     * @param c  value 3\n     * @return  the largest of the values\n     */\n    public static int max(int a, int b, int c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    /**\n     * <p>Gets the maximum of three <code>short</code> values.</p>\n     * \n     * @param a  value 1\n     * @param b  value 2\n     * @param c  value 3\n     * @return  the largest of the values\n     */\n    public static short max(short a, short b, short c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    /**\n     * <p>Gets the maximum of three <code>byte</code> values.</p>\n     * \n     * @param a  value 1\n     * @param b  value 2\n     * @param c  value 3\n     * @return  the largest of the values\n     */\n    public static byte max(byte a, byte b, byte c) {\n        if (b > a) {\n            a = b;\n        }\n        if (c > a) {\n            a = c;\n        }\n        return a;\n    }\n\n    /**\n     * <p>Gets the maximum of three <code>double</code> values.</p>\n     * \n     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n     * returned. Infinity is handled.</p>\n     *\n     * @param a  value 1\n     * @param b  value 2\n     * @param c  value 3\n     * @return  the largest of the values\n     */\n    public static double max(double a, double b, double c) {\n        return Math.max(Math.max(a, b), c);\n    }\n\n    /**\n     * <p>Gets the maximum of three <code>float</code> values.</p>\n     * \n     * <p>If any value is <code>NaN</code>, <code>NaN</code> is\n     * returned. Infinity is handled.</p>\n     *\n     * @param a  value 1\n     * @param b  value 2\n     * @param c  value 3\n     * @return  the largest of the values\n     */\n    public static float max(float a, float b, float c) {\n        return Math.max(Math.max(a, b), c);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * <p>Compares two <code>doubles</code> for order.</p>\n     *\n     * <p>This method is more comprehensive than the standard Java greater\n     * than, less than and equals operators.</p>\n     * <ul>\n     *  <li>It returns <code>-1</code> if the first value is less than the second.</li>\n     *  <li>It returns <code>+1</code> if the first value is greater than the second.</li>\n     *  <li>It returns <code>0</code> if the values are equal.</li>\n     * </ul>\n     *\n     * <p>\n     * The ordering is as follows, largest to smallest:\n     * <ul>\n     *  <li>NaN\n     *  <li>Positive infinity\n     *  <li>Maximum double\n     *  <li>Normal positive numbers\n     *  <li>+0.0\n     *  <li>-0.0\n     *  <li>Normal negative numbers\n     *  <li>Minimum double (<code>-Double.MAX_VALUE</code>)\n     *  <li>Negative infinity\n     * </ul>\n     * </p>\n     *\n     * <p>Comparing <code>NaN</code> with <code>NaN</code> will\n     * return <code>0</code>.</p>\n     * \n     * @param lhs  the first <code>double</code>\n     * @param rhs  the second <code>double</code>\n     * @return <code>-1</code> if lhs is less, <code>+1</code> if greater,\n     *  <code>0</code> if equal to rhs\n     */\n    public static int compare(double lhs, double rhs) {\n        if (lhs < rhs) {\n            return -1;\n        }\n        if (lhs > rhs) {\n            return +1;\n        }\n        // Need to compare bits to handle 0.0 == -0.0 being true\n        // compare should put -0.0 < +0.0\n        // Two NaNs are also == for compare purposes\n        // where NaN == NaN is false\n        long lhsBits = Double.doubleToLongBits(lhs);\n        long rhsBits = Double.doubleToLongBits(rhs);\n        if (lhsBits == rhsBits) {\n            return 0;\n        }\n        // Something exotic! A comparison to NaN or 0.0 vs -0.0\n        // Fortunately NaN's long is > than everything else\n        // Also negzeros bits < poszero\n        // NAN: 9221120237041090560\n        // MAX: 9218868437227405311\n        // NEGZERO: -9223372036854775808\n        if (lhsBits < rhsBits) {\n            return -1;\n        } else {\n            return +1;\n        }\n    }\n    \n    /**\n     * <p>Compares two floats for order.</p>\n     *\n     * <p>This method is more comprehensive than the standard Java greater than,\n     * less than and equals operators.</p>\n     * <ul>\n     *  <li>It returns <code>-1</code> if the first value is less than the second.\n     *  <li>It returns <code>+1</code> if the first value is greater than the second.\n     *  <li>It returns <code>0</code> if the values are equal.\n     * </ul>\n     *\n     * <p> The ordering is as follows, largest to smallest:\n     * <ul>\n     * <li>NaN\n     * <li>Positive infinity\n     * <li>Maximum float\n     * <li>Normal positive numbers\n     * <li>+0.0\n     * <li>-0.0\n     * <li>Normal negative numbers\n     * <li>Minimum float (<code>-Float.MAX_VALUE</code>)\n     * <li>Negative infinity\n     * </ul>\n     *\n     * <p>Comparing <code>NaN</code> with <code>NaN</code> will return\n     * <code>0</code>.</p>\n     * \n     * @param lhs  the first <code>float</code>\n     * @param rhs  the second <code>float</code>\n     * @return <code>-1</code> if lhs is less, <code>+1</code> if greater,\n     *  <code>0</code> if equal to rhs\n     */\n    public static int compare(float lhs, float rhs) {\n        if (lhs < rhs) {\n            return -1;\n        }\n        if (lhs > rhs) {\n            return +1;\n        }\n        //Need to compare bits to handle 0.0 == -0.0 being true\n        // compare should put -0.0 < +0.0\n        // Two NaNs are also == for compare purposes\n        // where NaN == NaN is false\n        int lhsBits = Float.floatToIntBits(lhs);\n        int rhsBits = Float.floatToIntBits(rhs);\n        if (lhsBits == rhsBits) {\n            return 0;\n        }\n        //Something exotic! A comparison to NaN or 0.0 vs -0.0\n        //Fortunately NaN's int is > than everything else\n        //Also negzeros bits < poszero\n        //NAN: 2143289344\n        //MAX: 2139095039\n        //NEGZERO: -2147483648\n        if (lhsBits < rhsBits) {\n            return -1;\n        } else {\n            return +1;\n        }\n    }\n    \n    //-----------------------------------------------------------------------\n    /**\n     * <p>Checks whether the <code>String</code> contains only\n     * digit characters.</p>\n     *\n     * <p><code>Null</code> and empty String will return\n     * <code>false</code>.</p>\n     *\n     * @param str  the <code>String</code> to check\n     * @return <code>true</code> if str contains only unicode numeric\n     */\n    public static boolean isDigits(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        for (int i = 0; i < str.length(); i++) {\n            if (!Character.isDigit(str.charAt(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * <p>Checks whether the String a valid Java number.</p>\n     *\n     * <p>Valid numbers include hexadecimal marked with the <code>0x</code>\n     * qualifier, scientific notation and numbers marked with a type\n     * qualifier (e.g. 123L).</p>\n     *\n     * <p><code>Null</code> and empty String will return\n     * <code>false</code>.</p>\n     *\n     * @param str  the <code>String</code> to check\n     * @return <code>true</code> if the string is a correctly formatted number\n     */\n    public static boolean isNumber(String str) {\n        if (StringUtils.isEmpty(str)) {\n            return false;\n        }\n        char[] chars = str.toCharArray();\n        int sz = chars.length;\n        boolean hasExp = false;\n        boolean hasDecPoint = false;\n        boolean allowSigns = false;\n        boolean foundDigit = false;\n        // deal with any possible sign up front\n        int start = (chars[0] == '-') ? 1 : 0;\n        if (sz > start + 1) {\n            if (chars[start] == '0' && chars[start + 1] == 'x') {\n                int i = start + 2;\n                if (i == sz) {\n                    return false; // str == \"0x\"\n                }\n                // checking hex (it can't be anything else)\n                for (; i < chars.length; i++) {\n                    if ((chars[i] < '0' || chars[i] > '9')\n                        && (chars[i] < 'a' || chars[i] > 'f')\n                        && (chars[i] < 'A' || chars[i] > 'F')) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        sz--; // don't want to loop to the last char, check it afterwords\n              // for type qualifiers\n        int i = start;\n        // loop to the next to last char or to the last char if we need another digit to\n        // make a valid number (e.g. chars[0..5] = \"1234E\")\n        while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                foundDigit = true;\n                allowSigns = false;\n\n            } else if (chars[i] == '.') {\n                if (hasDecPoint || hasExp) {\n                    // two decimal points or dec in exponent   \n                    return false;\n                }\n                hasDecPoint = true;\n            } else if (chars[i] == 'e' || chars[i] == 'E') {\n                // we've already taken care of hex.\n                if (hasExp) {\n                    // two E's\n                    return false;\n                }\n                if (!foundDigit) {\n                    return false;\n                }\n                hasExp = true;\n                allowSigns = true;\n            } else if (chars[i] == '+' || chars[i] == '-') {\n                if (!allowSigns) {\n                    return false;\n                }\n                allowSigns = false;\n                foundDigit = false; // we need a digit after the E\n            } else {\n                return false;\n            }\n            i++;\n        }\n        if (i < chars.length) {\n            if (chars[i] >= '0' && chars[i] <= '9') {\n                // no type qualifier, OK\n                return true;\n            }\n            if (chars[i] == 'e' || chars[i] == 'E') {\n                // can't have an E at the last byte\n                return false;\n            }\n            if (!allowSigns\n                && (chars[i] == 'd'\n                    || chars[i] == 'D'\n                    || chars[i] == 'f'\n                    || chars[i] == 'F')) {\n                return foundDigit;\n            }\n            if (chars[i] == 'l'\n                || chars[i] == 'L') {\n                // not allowing L with an exponent\n                return foundDigit && !hasExp;\n            }\n            // last character is illegal\n            return false;\n        }\n        // allowSigns is true iff the val ends in 'E'\n        // found digit it to make sure weird stuff like '.' and '1E-' doesn't pass\n        return !allowSigns && foundDigit;\n    }\n    \n}"
            }
        ]
    },
    {
        "PatchId": "Math_32_repairllama-ir4_patch_5.diff",
        "BugId": "Math_32",
        "PatchedMethods": [
            {
                "DevIntention": "compute|geometrical|properties",
                "OrgCode": "protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if ((Boolean) tree.getAttribute()) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }",
                "PatCode": "protected void computeGeometricalProperties() {\n        final Vector2D[][] v = getVertices();\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy code\n//             if ((Boolean) tree.getAttribute()) {\n           if (tree != null && Boolean.TRUE.equals(tree.getAttribute())) {\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n            if (sum < 0) {\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n        }\n    }\n\n    /** Get the vertices of the polygon.\n     * <p>The polygon boundary can be represented as an array of loops,\n     * each loop being itself an array of vertices.</p>\n     * <p>In order to identify open loops which start and end by\n     * infinite edges, the open loops arrays start with a null point. In\n     * this case, the first non null point and the last point of the\n     * array do not represent real vertices, they are dummy points\n     * intended only to get the direction of the first and last edge. An\n     * open loop consisting of a single infinite line will therefore be\n     * represented by a three elements array with one null point\n     * followed by two dummy points. The open loops are always the first\n     * ones in the loops array.</p>\n     * <p>If the polygon has no boundary at all, a zero length loop\n     * array will be returned.</p>\n     * <p>All line segments in the various loops have the inside of the\n     * region on their left side and the outside on their right side\n     * when moving in the underlying line direction. This means that\n     * closed loops surrounding finite areas obey the direct\n     * trigonometric orientation.</p>\n     * @return vertices of the polygon, organized as oriented boundary\n     * loops with the open loops first (the returned value is guaranteed\n     * to be non-null)\n     */\n    public Vector2D[][] getVertices() {\n        if (vertices == null) {\n            if (getTree(false).getCut() == null) {\n                vertices = new Vector2D[0][];\n            } else {\n\n                // sort the segments according to their start point\n                final SegmentsBuilder visitor = new SegmentsBuilder();\n                getTree(true).visit(visitor);\n                final AVLTree<ComparableSegment> sorted = visitor.getSorted();\n\n                // identify the loops, starting from the open ones\n                // (their start segments are naturally at the sorted set beginning)\n                final ArrayList<List<ComparableSegment>> loops = new ArrayList<List<ComparableSegment>>();\n                while (!sorted.isEmpty()) {\n                    final AVLTree<ComparableSegment>.Node node = sorted.getSmallest();\n                    final List<ComparableSegment> loop = followLoop(node, sorted);\n                    if (loop != null) {\n                        loops.add(loop);\n                    }\n                }\n\n                // tranform the loops in an array of arrays of points\n                vertices = new Vector2D[loops.size()][];\n                int i = 0;\n\n                for (final List<ComparableSegment> loop : loops) {\n                    if (loop.size() < 2) {\n                        // single infinite line\n                        final Line line = loop.get(0).getLine();\n                        vertices[i++] = new Vector2D[] {\n                            null,\n                            line.toSpace(new Vector1D(-Float.MAX_VALUE)),\n                            line.toSpace(new Vector1D(+Float.MAX_VALUE))\n                        };\n                    } else if (loop.get(0).getStart() == null) {\n                        // open loop with at least one real point\n                        final Vector2D[] array = new Vector2D[loop.size() + 2];\n                        int j = 0;\n                        for (Segment segment : loop) {\n\n                            if (j == 0) {\n                                // null point and first dummy point\n                                double x = segment.getLine().toSubSpace(segment.getEnd()).getX();\n                                x -= FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = null;\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                            if (j < (array.length - 1)) {\n                                // current point\n                                array[j++] = segment.getEnd();\n                            }\n\n                            if (j == (array.length - 1)) {\n                                // last dummy point\n                                double x = segment.getLine().toSubSpace(segment.getStart()).getX();\n                                x += FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                        }\n                        vertices[i++] = array;\n                    } else {\n                        final Vector2D[] array = new Vector2D[loop.size()];\n                        int j = 0;\n                        for (Segment segment : loop) {\n                            array[j++] = segment.getStart();\n                        }\n                        vertices[i++] = array;\n                    }\n                }\n\n            }\n        }\n\n        return vertices.clone();\n\n    }\n\n    /** Follow a boundary loop.\n     * @param node node containing the segment starting the loop\n     * @param sorted set of segments belonging to the boundary, sorted by\n     * start points (contains {@code node})\n     * @return a list of connected sub-hyperplanes starting at\n     * {@code node}\n     */\n    private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node,\n                                               final AVLTree<ComparableSegment> sorted) {\n\n        final ArrayList<ComparableSegment> loop = new ArrayList<ComparableSegment>();\n        ComparableSegment segment = node.getElement();\n        loop.add(segment);\n        final Vector2D globalStart = segment.getStart();\n        Vector2D end = segment.getEnd();\n        node.delete();\n\n        // is this an open or a closed loop ?\n        final boolean open = segment.getStart() == null;\n\n        while ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) {\n\n            // search the sub-hyperplane starting where the previous one ended\n            AVLTree<ComparableSegment>.Node selectedNode = null;\n            ComparableSegment       selectedSegment  = null;\n            double                  selectedDistance = Double.POSITIVE_INFINITY;\n            final ComparableSegment lowerLeft        = new ComparableSegment(end, -1.0e-10, -1.0e-10);\n            final ComparableSegment upperRight       = new ComparableSegment(end, +1.0e-10, +1.0e-10);\n            for (AVLTree<ComparableSegment>.Node n = sorted.getNotSmaller(lowerLeft);\n                 (n != null) && (n.getElement().compareTo(upperRight) <= 0);\n                 n = n.getNext()) {\n                segment = n.getElement();\n                final double distance = end.distance(segment.getStart());\n                if (distance < selectedDistance) {\n                    selectedNode     = n;\n                    selectedSegment  = segment;\n                    selectedDistance = distance;\n                }\n            }\n\n            if (selectedDistance > 1.0e-10) {\n                // this is a degenerated loop, it probably comes from a very\n                // tiny region with some segments smaller than the threshold, we\n                // simply ignore it\n                return null;\n            }\n\n            end = selectedSegment.getEnd();\n            loop.add(selectedSegment);\n            selectedNode.delete();\n\n        }\n\n        if ((loop.size() == 2) && !open) {\n            // this is a degenerated infinitely thin loop, we simply ignore it\n            return null;\n        }\n\n        if ((end == null) && !open) {\n            throw new MathInternalError();\n        }\n\n        return loop;\n\n    }\n\n    /** Private extension of Segment allowing comparison. */\n    private static class ComparableSegment extends Segment implements Comparable<ComparableSegment> {\n\n        /** Sorting key. */\n        private OrderedTuple sortingKey;\n\n        /** Build a segment.\n         * @param start start point of the segment\n         * @param end end point of the segment\n         * @param line line containing the segment\n         */\n        public ComparableSegment(final Vector2D start, final Vector2D end, final Line line) {\n            super(start, end, line);\n            sortingKey = (start == null) ?\n                         new OrderedTuple(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) :\n                         new OrderedTuple(start.getX(), start.getY());\n        }\n\n        /** Build a dummy segment.\n         * <p>\n         * The object built is not a real segment, only the sorting key is used to\n         * allow searching in the neighborhood of a point. This is an horrible hack ...\n         * </p>\n         * @param start start point of the segment\n         * @param dx abscissa offset from the start point\n         * @param dy ordinate offset from the start point\n         */\n        public ComparableSegment(final Vector2D start, final double dx, final double dy) {\n            super(null, null, null);\n            sortingKey = new OrderedTuple(start.getX() + dx, start.getY() + dy);\n        }\n\n        /** {@inheritDoc} */\n        public int compareTo(final ComparableSegment o) {\n            return sortingKey.compareTo(o.sortingKey);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean equals(final Object other) {\n            if (this == other) {\n                return true;\n            } else if (other instanceof ComparableSegment) {\n                return compareTo((ComparableSegment) other) == 0;\n            } else {\n                return false;\n            }\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int hashCode() {\n            return getStart().hashCode() ^ getEnd().hashCode() ^\n                   getLine().hashCode() ^ sortingKey.hashCode();\n        }\n\n    }\n\n    /** Visitor building segments. */\n    private static class SegmentsBuilder implements BSPTreeVisitor<Euclidean2D> {\n\n        /** Sorted segments. */\n        private AVLTree<ComparableSegment> sorted;\n\n        /** Simple constructor. */\n        public SegmentsBuilder() {\n            sorted = new AVLTree<ComparableSegment>();\n        }\n\n        /** {@inheritDoc} */\n        public Order visitOrder(final BSPTree<Euclidean2D> node) {\n            return Order.MINUS_SUB_PLUS;\n        }\n\n        /** {@inheritDoc} */\n        public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n            @SuppressWarnings(\"unchecked\")\n            final BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute();\n            if (attribute.getPlusOutside() != null) {\n                addContribution(attribute.getPlusOutside(), false);\n            }\n            if (attribute.getPlusInside() != null) {\n                addContribution(attribute.getPlusInside(), true);\n            }\n        }\n\n        /** {@inheritDoc} */\n        public void visitLeafNode(final BSPTree<Euclidean2D> node) {\n        }\n\n        /** Add he contribution of a boundary facet.\n         * @param sub boundary facet\n         * @param reversed if true, the facet has the inside on its plus side\n         */\n        private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n            @SuppressWarnings(\"unchecked\")\n            final AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub =\n                (AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub;\n            final Line line      = (Line) sub.getHyperplane();\n            final List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();\n            for (final Interval i : intervals) {\n                final Vector2D start = Double.isInfinite(i.getLower()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getLower()));\n                final Vector2D end   = Double.isInfinite(i.getUpper()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getUpper()));\n                if (reversed) {\n                    sorted.insert(new ComparableSegment(end, start, line.getReverse()));\n                } else {\n                    sorted.insert(new ComparableSegment(start, end, line));\n                }\n            }\n        }\n\n        /** Get the sorted segments.\n         * @return sorted segments\n         */\n        public AVLTree<ComparableSegment> getSorted() {\n            return sorted;\n        }\n\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Chart_13_repairllama-ir4_patch_6.diff",
        "BugId": "Chart_13",
        "PatchedMethods": [
            {
                "DevIntention": "arrange|f|f",
                "OrgCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth() - w[2]),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }",
                "PatCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy code\n//                     new Range(0.0, constraint.getWidth() - w[2]),\n                   new Range(0.0, constraint.getWidth() - w[4]),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_43_repairllama-ir4_patch_1.diff",
        "BugId": "Lang_43",
        "PatchedMethods": [
            {
                "DevIntention": "append|quoted|string",
                "OrgCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }",
                "PatCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n// buggy code\n// \n           pos.setIndex(start + 1);\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_34_repairllama-ir4_patch_2.diff",
        "BugId": "Math_34",
        "PatchedMethods": [
            {
                "DevIntention": "iterator",
                "OrgCode": "public Iterator<Chromosome> iterator() {\n        return chromosomes.iterator();\n    }",
                "PatCode": "public Iterator<Chromosome> iterator() {\n// buggy code\n//         return chromosomes.iterator();\n       return new Iterator<Chromosome>() {\n            int i = 0;\n            @Override\n            public boolean hasNext() {\n                return i < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(i++);\n            }\n        };\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_57_repairllama-ir4_patch_4.diff",
        "BugId": "Math_57",
        "PatchedMethods": [
            {
                "DevIntention": "choose|initial|centers",
                "OrgCode": "private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n        // Choose one center uniformly at random from among the data points.\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n\n        final double[] dx2 = new double[pointSet.size()];\n        while (resultSet.size() < k) {\n            // For each data point x, compute D(x), the distance between x and\n            // the nearest center that has already been chosen.\n            int sum = 0;\n            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n\n            // Add one new data point as a center. Each point x is chosen with\n            // probability proportional to D(x)2\n            final double r = random.nextDouble() * sum;\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    break;\n                }\n            }\n        }\n\n        return resultSet;\n\n    }",
                "PatCode": "private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n        final double[] dx2 = new double[pointSet.size()];\n        while (resultSet.size() < k) {\n// buggy code\n//             int sum = 0;\n           double sum = 0.;\n            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n            final double r = random.nextDouble() * sum;\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    break;\n                }\n            }\n        }\n        return resultSet;\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_33_repairllama-ir4_patch_0.diff",
        "BugId": "Lang_33",
        "PatchedMethods": [
            {
                "DevIntention": "to|class",
                "OrgCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }",
                "PatCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n// buggy code\n//             classes[i] = array[i].getClass();\n           if (array[i] != null) {\n            classes[i] = array[i].getClass();\n        }\n        }\n        return classes;\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_51_repairllama-ir4_patch_5.diff",
        "BugId": "Lang_51",
        "PatchedMethods": [
            {
                "DevIntention": "to|boolean",
                "OrgCode": "public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }",
                "PatCode": "public static boolean toBoolean(String str) {\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n// buggy code\n// \n               break; \n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_1_repairllama-ir4_patch_2.diff",
        "BugId": "Chart_1",
        "PatchedMethods": [
            {
                "DevIntention": "get|legend|items",
                "OrgCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset != null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }",
                "PatCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n// buggy code\n//         if (dataset != null) {\n       if (dataset == null || dataset.getRowCount() <= 0) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Adds an entity with the specified hotspot.\n     *\n     * @param entities  the entity collection.\n     * @param hotspot  the hotspot (<code>null</code> not permitted).\n     * @param dataset  the dataset.\n     * @param row  the row index.\n     * @param column  the column index.\n     * @param selected  is the item selected?\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected) {\n\n        if (hotspot == null) {\n            throw new IllegalArgumentException(\"Null 'hotspot' argument.\");\n        }\n        addEntity(entities, hotspot, dataset, row, column, selected, 0.0, 0.0);\n    }\n\n    /**\n     * Adds an entity to the collection.\n     *\n     * @param entities  the entity collection being populated.\n     * @param hotspot  the entity area (if <code>null</code> a default will be\n     *              used).\n     * @param dataset  the dataset.\n     * @param row  the series.\n     * @param column  the item.\n     * @param selected  is the item selected?\n     * @param entityX  the entity's center x-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     * @param entityY  the entity's center y-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            double entityX, double entityY) {\n        if (!getItemCreateEntity(row, column, selected)) {\n            return;\n        }\n        Shape s = hotspot;\n        if (hotspot == null) {\n            double r = getDefaultEntityRadius();\n            double w = r * 2;\n            if (getPlot().getOrientation() == PlotOrientation.VERTICAL) {\n                s = new Ellipse2D.Double(entityX - r, entityY - r, w, w);\n            }\n            else {\n                s = new Ellipse2D.Double(entityY - r, entityX - r, w, w);\n            }\n        }\n        String tip = null;\n        CategoryToolTipGenerator generator = getToolTipGenerator(row, column,\n                selected);\n        if (generator != null) {\n            tip = generator.generateToolTip(dataset, row, column);\n        }\n        String url = null;\n        CategoryURLGenerator urlster = getURLGenerator(row, column, selected);\n        if (urlster != null) {\n            url = urlster.generateURL(dataset, row, column);\n        }\n        CategoryItemEntity entity = new CategoryItemEntity(s, tip, url,\n                dataset, dataset.getRowKey(row), dataset.getColumnKey(column));\n        entities.add(entity);\n    }\n\n        /**\n     * Returns a shape that can be used for hit testing on a data item drawn\n     * by the renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area within which the data is being rendered.\n     * @param plot  the plot (can be used to obtain standard color\n     *              information etc).\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the dataset.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param selected  is the item selected?\n     *\n     * @return A shape equal to the hot spot for a data item.\n     */\n    public Shape createHotSpotShape(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state) {\n        throw new RuntimeException(\"Not implemented.\");\n    }\n\n    /**\n     * Returns the rectangular bounds for the hot spot for an item drawn by\n     * this renderer.  This is intended to provide a quick test for\n     * eliminating data points before more accurate testing against the\n     * shape returned by createHotSpotShape().\n     *\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     * @param result\n     * @return\n     */\n    public Rectangle2D createHotSpotBounds(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state, Rectangle2D result) {\n        if (result == null) {\n            result = new Rectangle();\n        }\n        Comparable key = dataset.getColumnKey(column);\n        Number y = dataset.getValue(row, column);\n        if (y == null) {\n            return null;\n        }\n        double xx = domainAxis.getCategoryMiddle(key,\n                plot.getCategoriesForAxis(domainAxis),\n                dataArea, plot.getDomainAxisEdge());\n        double yy = rangeAxis.valueToJava2D(y.doubleValue(), dataArea,\n                plot.getRangeAxisEdge());\n        result.setRect(xx - 2, yy - 2, 4, 4);\n        return result;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified point (xx, yy) in Java2D\n     * space falls within the \"hot spot\" for the specified data item, and\n     * <code>false</code> otherwise.\n     *\n     * @param xx\n     * @param yy\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     *\n     * @return\n     *\n     * @since 1.2.0\n     */\n    public boolean hitTest(double xx, double yy, Graphics2D g2,\n            Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,\n            ValueAxis rangeAxis, CategoryDataset dataset, int row, int column,\n            boolean selected, CategoryItemRendererState state) {\n        Rectangle2D bounds = createHotSpotBounds(g2, dataArea, plot,\n                domainAxis, rangeAxis, dataset, row, column, selected,\n                state, null);\n        if (bounds == null) {\n            return false;\n        }\n        // FIXME:  if the following test passes, we should then do the more\n        // expensive test against the hotSpotShape\n        return bounds.contains(xx, yy);\n    }\n    \n}"
            }
        ]
    },
    {
        "PatchId": "Math_32_repairllama-ir4_patch_9.diff",
        "BugId": "Math_32",
        "PatchedMethods": [
            {
                "DevIntention": "compute|geometrical|properties",
                "OrgCode": "protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if ((Boolean) tree.getAttribute()) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }",
                "PatCode": "protected void computeGeometricalProperties() {\n        final Vector2D[][] v = getVertices();\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy code\n//             if ((Boolean) tree.getAttribute()) {\n           if (tree.getAttribute() == null) {\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n            if (sum < 0) {\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n        }\n    }\n\n    /** Get the vertices of the polygon.\n     * <p>The polygon boundary can be represented as an array of loops,\n     * each loop being itself an array of vertices.</p>\n     * <p>In order to identify open loops which start and end by\n     * infinite edges, the open loops arrays start with a null point. In\n     * this case, the first non null point and the last point of the\n     * array do not represent real vertices, they are dummy points\n     * intended only to get the direction of the first and last edge. An\n     * open loop consisting of a single infinite line will therefore be\n     * represented by a three elements array with one null point\n     * followed by two dummy points. The open loops are always the first\n     * ones in the loops array.</p>\n     * <p>If the polygon has no boundary at all, a zero length loop\n     * array will be returned.</p>\n     * <p>All line segments in the various loops have the inside of the\n     * region on their left side and the outside on their right side\n     * when moving in the underlying line direction. This means that\n     * closed loops surrounding finite areas obey the direct\n     * trigonometric orientation.</p>\n     * @return vertices of the polygon, organized as oriented boundary\n     * loops with the open loops first (the returned value is guaranteed\n     * to be non-null)\n     */\n    public Vector2D[][] getVertices() {\n        if (vertices == null) {\n            if (getTree(false).getCut() == null) {\n                vertices = new Vector2D[0][];\n            } else {\n\n                // sort the segments according to their start point\n                final SegmentsBuilder visitor = new SegmentsBuilder();\n                getTree(true).visit(visitor);\n                final AVLTree<ComparableSegment> sorted = visitor.getSorted();\n\n                // identify the loops, starting from the open ones\n                // (their start segments are naturally at the sorted set beginning)\n                final ArrayList<List<ComparableSegment>> loops = new ArrayList<List<ComparableSegment>>();\n                while (!sorted.isEmpty()) {\n                    final AVLTree<ComparableSegment>.Node node = sorted.getSmallest();\n                    final List<ComparableSegment> loop = followLoop(node, sorted);\n                    if (loop != null) {\n                        loops.add(loop);\n                    }\n                }\n\n                // tranform the loops in an array of arrays of points\n                vertices = new Vector2D[loops.size()][];\n                int i = 0;\n\n                for (final List<ComparableSegment> loop : loops) {\n                    if (loop.size() < 2) {\n                        // single infinite line\n                        final Line line = loop.get(0).getLine();\n                        vertices[i++] = new Vector2D[] {\n                            null,\n                            line.toSpace(new Vector1D(-Float.MAX_VALUE)),\n                            line.toSpace(new Vector1D(+Float.MAX_VALUE))\n                        };\n                    } else if (loop.get(0).getStart() == null) {\n                        // open loop with at least one real point\n                        final Vector2D[] array = new Vector2D[loop.size() + 2];\n                        int j = 0;\n                        for (Segment segment : loop) {\n\n                            if (j == 0) {\n                                // null point and first dummy point\n                                double x = segment.getLine().toSubSpace(segment.getEnd()).getX();\n                                x -= FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = null;\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                            if (j < (array.length - 1)) {\n                                // current point\n                                array[j++] = segment.getEnd();\n                            }\n\n                            if (j == (array.length - 1)) {\n                                // last dummy point\n                                double x = segment.getLine().toSubSpace(segment.getStart()).getX();\n                                x += FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                        }\n                        vertices[i++] = array;\n                    } else {\n                        final Vector2D[] array = new Vector2D[loop.size()];\n                        int j = 0;\n                        for (Segment segment : loop) {\n                            array[j++] = segment.getStart();\n                        }\n                        vertices[i++] = array;\n                    }\n                }\n\n            }\n        }\n\n        return vertices.clone();\n\n    }\n\n    /** Follow a boundary loop.\n     * @param node node containing the segment starting the loop\n     * @param sorted set of segments belonging to the boundary, sorted by\n     * start points (contains {@code node})\n     * @return a list of connected sub-hyperplanes starting at\n     * {@code node}\n     */\n    private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node,\n                                               final AVLTree<ComparableSegment> sorted) {\n\n        final ArrayList<ComparableSegment> loop = new ArrayList<ComparableSegment>();\n        ComparableSegment segment = node.getElement();\n        loop.add(segment);\n        final Vector2D globalStart = segment.getStart();\n        Vector2D end = segment.getEnd();\n        node.delete();\n\n        // is this an open or a closed loop ?\n        final boolean open = segment.getStart() == null;\n\n        while ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) {\n\n            // search the sub-hyperplane starting where the previous one ended\n            AVLTree<ComparableSegment>.Node selectedNode = null;\n            ComparableSegment       selectedSegment  = null;\n            double                  selectedDistance = Double.POSITIVE_INFINITY;\n            final ComparableSegment lowerLeft        = new ComparableSegment(end, -1.0e-10, -1.0e-10);\n            final ComparableSegment upperRight       = new ComparableSegment(end, +1.0e-10, +1.0e-10);\n            for (AVLTree<ComparableSegment>.Node n = sorted.getNotSmaller(lowerLeft);\n                 (n != null) && (n.getElement().compareTo(upperRight) <= 0);\n                 n = n.getNext()) {\n                segment = n.getElement();\n                final double distance = end.distance(segment.getStart());\n                if (distance < selectedDistance) {\n                    selectedNode     = n;\n                    selectedSegment  = segment;\n                    selectedDistance = distance;\n                }\n            }\n\n            if (selectedDistance > 1.0e-10) {\n                // this is a degenerated loop, it probably comes from a very\n                // tiny region with some segments smaller than the threshold, we\n                // simply ignore it\n                return null;\n            }\n\n            end = selectedSegment.getEnd();\n            loop.add(selectedSegment);\n            selectedNode.delete();\n\n        }\n\n        if ((loop.size() == 2) && !open) {\n            // this is a degenerated infinitely thin loop, we simply ignore it\n            return null;\n        }\n\n        if ((end == null) && !open) {\n            throw new MathInternalError();\n        }\n\n        return loop;\n\n    }\n\n    /** Private extension of Segment allowing comparison. */\n    private static class ComparableSegment extends Segment implements Comparable<ComparableSegment> {\n\n        /** Sorting key. */\n        private OrderedTuple sortingKey;\n\n        /** Build a segment.\n         * @param start start point of the segment\n         * @param end end point of the segment\n         * @param line line containing the segment\n         */\n        public ComparableSegment(final Vector2D start, final Vector2D end, final Line line) {\n            super(start, end, line);\n            sortingKey = (start == null) ?\n                         new OrderedTuple(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) :\n                         new OrderedTuple(start.getX(), start.getY());\n        }\n\n        /** Build a dummy segment.\n         * <p>\n         * The object built is not a real segment, only the sorting key is used to\n         * allow searching in the neighborhood of a point. This is an horrible hack ...\n         * </p>\n         * @param start start point of the segment\n         * @param dx abscissa offset from the start point\n         * @param dy ordinate offset from the start point\n         */\n        public ComparableSegment(final Vector2D start, final double dx, final double dy) {\n            super(null, null, null);\n            sortingKey = new OrderedTuple(start.getX() + dx, start.getY() + dy);\n        }\n\n        /** {@inheritDoc} */\n        public int compareTo(final ComparableSegment o) {\n            return sortingKey.compareTo(o.sortingKey);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean equals(final Object other) {\n            if (this == other) {\n                return true;\n            } else if (other instanceof ComparableSegment) {\n                return compareTo((ComparableSegment) other) == 0;\n            } else {\n                return false;\n            }\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int hashCode() {\n            return getStart().hashCode() ^ getEnd().hashCode() ^\n                   getLine().hashCode() ^ sortingKey.hashCode();\n        }\n\n    }\n\n    /** Visitor building segments. */\n    private static class SegmentsBuilder implements BSPTreeVisitor<Euclidean2D> {\n\n        /** Sorted segments. */\n        private AVLTree<ComparableSegment> sorted;\n\n        /** Simple constructor. */\n        public SegmentsBuilder() {\n            sorted = new AVLTree<ComparableSegment>();\n        }\n\n        /** {@inheritDoc} */\n        public Order visitOrder(final BSPTree<Euclidean2D> node) {\n            return Order.MINUS_SUB_PLUS;\n        }\n\n        /** {@inheritDoc} */\n        public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n            @SuppressWarnings(\"unchecked\")\n            final BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute();\n            if (attribute.getPlusOutside() != null) {\n                addContribution(attribute.getPlusOutside(), false);\n            }\n            if (attribute.getPlusInside() != null) {\n                addContribution(attribute.getPlusInside(), true);\n            }\n        }\n\n        /** {@inheritDoc} */\n        public void visitLeafNode(final BSPTree<Euclidean2D> node) {\n        }\n\n        /** Add he contribution of a boundary facet.\n         * @param sub boundary facet\n         * @param reversed if true, the facet has the inside on its plus side\n         */\n        private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n            @SuppressWarnings(\"unchecked\")\n            final AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub =\n                (AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub;\n            final Line line      = (Line) sub.getHyperplane();\n            final List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();\n            for (final Interval i : intervals) {\n                final Vector2D start = Double.isInfinite(i.getLower()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getLower()));\n                final Vector2D end   = Double.isInfinite(i.getUpper()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getUpper()));\n                if (reversed) {\n                    sorted.insert(new ComparableSegment(end, start, line.getReverse()));\n                } else {\n                    sorted.insert(new ComparableSegment(start, end, line));\n                }\n            }\n        }\n\n        /** Get the sorted segments.\n         * @return sorted segments\n         */\n        public AVLTree<ComparableSegment> getSorted() {\n            return sorted;\n        }\n\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Math_11_repairllama-ir4_patch_1.diff",
        "BugId": "Math_11",
        "PatchedMethods": [
            {
                "DevIntention": "density",
                "OrgCode": "public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n\n        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }",
                "PatCode": "public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n// buggy code\n//         return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n       return FastMath.pow(2 * FastMath.PI, -dim / 2.0) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }"
            }
        ]
    },
    {
        "PatchId": "Time_7_repairllama-ir4_patch_1.diff",
        "BugId": "Time_7",
        "PatchedMethods": [
            {
                "DevIntention": "parse|into",
                "OrgCode": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        int defaultYear = chrono.year().get(instantLocal);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }",
                "PatCode": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n// buggy code\n//         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n//         chrono = selectChronology(chrono);\n//         int defaultYear = chrono.year().get(instantLocal);\n       int defaultYear = chrono.year().get(instantMillis);\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_1_repairllama-ir4_patch_3.diff",
        "BugId": "Chart_1",
        "PatchedMethods": [
            {
                "DevIntention": "get|legend|items",
                "OrgCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset != null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }",
                "PatCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n// buggy code\n//         if (dataset != null) {\n       if ((dataset == null) || (dataset.getRowCount() == 0)) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Adds an entity with the specified hotspot.\n     *\n     * @param entities  the entity collection.\n     * @param hotspot  the hotspot (<code>null</code> not permitted).\n     * @param dataset  the dataset.\n     * @param row  the row index.\n     * @param column  the column index.\n     * @param selected  is the item selected?\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected) {\n\n        if (hotspot == null) {\n            throw new IllegalArgumentException(\"Null 'hotspot' argument.\");\n        }\n        addEntity(entities, hotspot, dataset, row, column, selected, 0.0, 0.0);\n    }\n\n    /**\n     * Adds an entity to the collection.\n     *\n     * @param entities  the entity collection being populated.\n     * @param hotspot  the entity area (if <code>null</code> a default will be\n     *              used).\n     * @param dataset  the dataset.\n     * @param row  the series.\n     * @param column  the item.\n     * @param selected  is the item selected?\n     * @param entityX  the entity's center x-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     * @param entityY  the entity's center y-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            double entityX, double entityY) {\n        if (!getItemCreateEntity(row, column, selected)) {\n            return;\n        }\n        Shape s = hotspot;\n        if (hotspot == null) {\n            double r = getDefaultEntityRadius();\n            double w = r * 2;\n            if (getPlot().getOrientation() == PlotOrientation.VERTICAL) {\n                s = new Ellipse2D.Double(entityX - r, entityY - r, w, w);\n            }\n            else {\n                s = new Ellipse2D.Double(entityY - r, entityX - r, w, w);\n            }\n        }\n        String tip = null;\n        CategoryToolTipGenerator generator = getToolTipGenerator(row, column,\n                selected);\n        if (generator != null) {\n            tip = generator.generateToolTip(dataset, row, column);\n        }\n        String url = null;\n        CategoryURLGenerator urlster = getURLGenerator(row, column, selected);\n        if (urlster != null) {\n            url = urlster.generateURL(dataset, row, column);\n        }\n        CategoryItemEntity entity = new CategoryItemEntity(s, tip, url,\n                dataset, dataset.getRowKey(row), dataset.getColumnKey(column));\n        entities.add(entity);\n    }\n\n        /**\n     * Returns a shape that can be used for hit testing on a data item drawn\n     * by the renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area within which the data is being rendered.\n     * @param plot  the plot (can be used to obtain standard color\n     *              information etc).\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the dataset.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param selected  is the item selected?\n     *\n     * @return A shape equal to the hot spot for a data item.\n     */\n    public Shape createHotSpotShape(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state) {\n        throw new RuntimeException(\"Not implemented.\");\n    }\n\n    /**\n     * Returns the rectangular bounds for the hot spot for an item drawn by\n     * this renderer.  This is intended to provide a quick test for\n     * eliminating data points before more accurate testing against the\n     * shape returned by createHotSpotShape().\n     *\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     * @param result\n     * @return\n     */\n    public Rectangle2D createHotSpotBounds(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state, Rectangle2D result) {\n        if (result == null) {\n            result = new Rectangle();\n        }\n        Comparable key = dataset.getColumnKey(column);\n        Number y = dataset.getValue(row, column);\n        if (y == null) {\n            return null;\n        }\n        double xx = domainAxis.getCategoryMiddle(key,\n                plot.getCategoriesForAxis(domainAxis),\n                dataArea, plot.getDomainAxisEdge());\n        double yy = rangeAxis.valueToJava2D(y.doubleValue(), dataArea,\n                plot.getRangeAxisEdge());\n        result.setRect(xx - 2, yy - 2, 4, 4);\n        return result;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified point (xx, yy) in Java2D\n     * space falls within the \"hot spot\" for the specified data item, and\n     * <code>false</code> otherwise.\n     *\n     * @param xx\n     * @param yy\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     *\n     * @return\n     *\n     * @since 1.2.0\n     */\n    public boolean hitTest(double xx, double yy, Graphics2D g2,\n            Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,\n            ValueAxis rangeAxis, CategoryDataset dataset, int row, int column,\n            boolean selected, CategoryItemRendererState state) {\n        Rectangle2D bounds = createHotSpotBounds(g2, dataArea, plot,\n                domainAxis, rangeAxis, dataset, row, column, selected,\n                state, null);\n        if (bounds == null) {\n            return false;\n        }\n        // FIXME:  if the following test passes, we should then do the more\n        // expensive test against the hotSpotShape\n        return bounds.contains(xx, yy);\n    }\n    \n}"
            }
        ]
    },
    {
        "PatchId": "Math_28_repairllama-ir4_patch_7.diff",
        "BugId": "Math_28",
        "PatchedMethods": [
            {
                "DevIntention": "get|pivot|row",
                "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }",
                "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n// buggy code\n//                 for (Integer row : minRatioPositions) {\n//                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n//                         int column = i + tableau.getArtificialVariableOffset();\n//                         final double entry = tableau.getEntry(row, column);\n//                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n//                             return row;\n//                         }\n//                     }\n//                 }\n//                 Integer minRow = null;\n//                 int minIndex = tableau.getWidth();\n//                 for (Integer row : minRatioPositions) {\n//                     int i = tableau.getNumObjectiveFunctions();\n//                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n//                         if (row == tableau.getBasicRow(i)) {\n//                             if (i < minIndex) {\n//                                 minIndex = i;\n//                                 minRow = row;\n//                             }\n//                         }\n//                     }\n//                 }\n//                 return minRow;\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        } else {\n        }\n        return minRatioPositions.get(0);\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_84_repairllama-ir4_patch_1.diff",
        "BugId": "Math_84",
        "PatchedMethods": [
            {
                "DevIntention": "iterate|simplex",
                "OrgCode": "protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }",
                "PatCode": "protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n// buggy code\n//         while (true) {\n//             incrementIterationsCounter();\n//             final RealPointValuePair[] original = simplex;\n//             final RealPointValuePair best = original[0];\n//             final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n//             if (comparator.compare(reflected, best) < 0) {\n//                 final RealPointValuePair[] reflectedSimplex = simplex;\n//                 final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n//                 if (comparator.compare(reflected, expanded) <= 0) {\n//                     simplex = reflectedSimplex;\n//                 }\n//                 return;\n//             }\n//             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n//             if (comparator.compare(contracted, best) < 0) {\n//                 return;\n//             }\n            incrementIterationsCounter();\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    simplex = reflectedSimplex;\n                }\n                return;\n            }\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                return;\n            }\n    }\n\n    /** Compute and evaluate a new simplex.\n     * @param original original simplex (to be preserved)\n     * @param coeff linear coefficient\n     * @param comparator comparator to use to sort simplex vertices from best to poorest\n     * @return best point in the transformed simplex\n     * @exception FunctionEvaluationException if the function cannot be evaluated at\n     * some point\n     * @exception OptimizationException if the maximal number of evaluations is exceeded\n     */\n    private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] original,\n                                              final double coeff,\n                                              final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException {\n\n        final double[] xSmallest = original[0].getPointRef();\n        final int n = xSmallest.length;\n\n        // create the linearly transformed simplex\n        simplex = new RealPointValuePair[n + 1];\n        simplex[0] = original[0];\n        for (int i = 1; i <= n; ++i) {\n            final double[] xOriginal    = original[i].getPointRef();\n            final double[] xTransformed = new double[n];\n            for (int j = 0; j < n; ++j) {\n                xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n            }\n            simplex[i] = new RealPointValuePair(xTransformed, Double.NaN, false);\n        }\n\n        // evaluate it\n        evaluateSimplex(comparator);\n        return simplex[0];\n\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Chart_4_repairllama-ir4_patch_5.diff",
        "BugId": "Chart_4",
        "PatchedMethods": [
            {
                "DevIntention": "get|data|range",
                "OrgCode": "public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                // grab the plot's annotations\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n                \n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n            }\n        }\n\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n\n        return result;\n\n    }",
                "PatCode": "public Range getDataRange(ValueAxis axis) {\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n// buggy code\n//                     Collection c = r.getAnnotations();\n//                     Iterator i = c.iterator();\n//                     while (i.hasNext()) {\n//                         XYAnnotation a = (XYAnnotation) i.next();\n//                         if (a instanceof XYAnnotationBoundsInfo) {\n//                             includedAnnotations.add(a);\n//                         }\n//                     }\n               Collection c = r != null ? r.getAnnotations() : null;\n                if (c != null) {\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n            }\n        }\n        }\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n        return result;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_57_repairllama-ir4_patch_5.diff",
        "BugId": "Math_57",
        "PatchedMethods": [
            {
                "DevIntention": "choose|initial|centers",
                "OrgCode": "private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n        // Choose one center uniformly at random from among the data points.\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n\n        final double[] dx2 = new double[pointSet.size()];\n        while (resultSet.size() < k) {\n            // For each data point x, compute D(x), the distance between x and\n            // the nearest center that has already been chosen.\n            int sum = 0;\n            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n\n            // Add one new data point as a center. Each point x is chosen with\n            // probability proportional to D(x)2\n            final double r = random.nextDouble() * sum;\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    break;\n                }\n            }\n        }\n\n        return resultSet;\n\n    }",
                "PatCode": "private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n        final double[] dx2 = new double[pointSet.size()];\n        while (resultSet.size() < k) {\n// buggy code\n//             int sum = 0;\n           double sum = 0d;\n            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n            final double r = random.nextDouble() * sum;\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    break;\n                }\n            }\n        }\n        return resultSet;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_50_repairllama-ir4_patch_1.diff",
        "BugId": "Math_50",
        "PatchedMethods": [
            {
                "DevIntention": "do|solve",
                "OrgCode": "protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }",
                "PatCode": "protected final double doSolve() {\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n        verifyBracketing(x0, x1);\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n        boolean inverted = false;\n        while (true) {\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n            if (fx == 0.0) {\n                return x;\n            }\n            if (f1 * fx < 0) {\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n// buggy code\n//                     if (x == x1) {\n//                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n//                         f0 = computeObjectiveValue(x0);\n//                     }\n                    if (x == x1) {\n                        x0 = x1 - FastMath.max(rtol * FastMath.abs(x1), atol);\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n            x1 = x;\n            f1 = fx;\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_34_repairllama-ir4_patch_3.diff",
        "BugId": "Math_34",
        "PatchedMethods": [
            {
                "DevIntention": "iterator",
                "OrgCode": "public Iterator<Chromosome> iterator() {\n        return chromosomes.iterator();\n    }",
                "PatCode": "public Iterator<Chromosome> iterator() {\n// buggy code\n//         return chromosomes.iterator();\n       return new Iterator<Chromosome>() {\n            int index = 0;\n            @Override\n            public boolean hasNext() {\n                return index < chromosomes.size();\n            }\n\n            @Override\n            public Chromosome next() {\n                return chromosomes.get(index++);\n            }\n        };\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_7_repairllama-ir4_patch_8.diff",
        "BugId": "Chart_7",
        "PatchedMethods": [
            {
                "DevIntention": "update|bounds",
                "OrgCode": "private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }",
                "PatCode": "private void updateBounds(TimePeriod period, int index) {\n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        if (this.maxMiddleIndex >= 0) {\n// buggy code\n//             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n//                 .getTime();\n//             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n           long s = getDataItem(this.maxMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_4_repairllama-ir4_patch_2.diff",
        "BugId": "Chart_4",
        "PatchedMethods": [
            {
                "DevIntention": "get|data|range",
                "OrgCode": "public Range getDataRange(ValueAxis axis) {\n\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n\n        // is it a domain axis?\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                // grab the plot's annotations\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // or is it a range axis?\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n\n        // iterate through the datasets that map to the axis and get the union\n        // of the ranges.\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n                \n                    Collection c = r.getAnnotations();\n                    Iterator i = c.iterator();\n                    while (i.hasNext()) {\n                        XYAnnotation a = (XYAnnotation) i.next();\n                        if (a instanceof XYAnnotationBoundsInfo) {\n                            includedAnnotations.add(a);\n                        }\n                    }\n            }\n        }\n\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n\n        return result;\n\n    }",
                "PatCode": "public Range getDataRange(ValueAxis axis) {\n        Range result = null;\n        List mappedDatasets = new ArrayList();\n        List includedAnnotations = new ArrayList();\n        boolean isDomainAxis = true;\n        int domainIndex = getDomainAxisIndex(axis);\n        if (domainIndex >= 0) {\n            isDomainAxis = true;\n            mappedDatasets.addAll(getDatasetsMappedToDomainAxis(\n                    new Integer(domainIndex)));\n            if (domainIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n        int rangeIndex = getRangeAxisIndex(axis);\n        if (rangeIndex >= 0) {\n            isDomainAxis = false;\n            mappedDatasets.addAll(getDatasetsMappedToRangeAxis(\n                    new Integer(rangeIndex)));\n            if (rangeIndex == 0) {\n                Iterator iterator = this.annotations.iterator();\n                while (iterator.hasNext()) {\n                    XYAnnotation annotation = (XYAnnotation) iterator.next();\n                    if (annotation instanceof XYAnnotationBoundsInfo) {\n                        includedAnnotations.add(annotation);\n                    }\n                }\n            }\n        }\n        Iterator iterator = mappedDatasets.iterator();\n        while (iterator.hasNext()) {\n            XYDataset d = (XYDataset) iterator.next();\n            if (d != null) {\n                XYItemRenderer r = getRendererForDataset(d);\n                if (isDomainAxis) {\n                    if (r != null) {\n                        result = Range.combine(result, r.findDomainBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findDomainBounds(d));\n                    }\n                }\n                else {\n                    if (r != null) {\n                        result = Range.combine(result, r.findRangeBounds(d));\n                    }\n                    else {\n                        result = Range.combine(result,\n                                DatasetUtilities.findRangeBounds(d));\n                    }\n                }\n// buggy code\n//                     Collection c = r.getAnnotations();\n//                     Iterator i = c.iterator();\n//                     while (i.hasNext()) {\n//                         XYAnnotation a = (XYAnnotation) i.next();\n//                         if (a instanceof XYAnnotationBoundsInfo) {\n//                             includedAnnotations.add(a);\n//                         }\n//                     }\n                        }\n                    }\n        Iterator it = includedAnnotations.iterator();\n        while (it.hasNext()) {\n            XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next();\n            if (xyabi.getIncludeInDataBounds()) {\n                if (isDomainAxis) {\n                    result = Range.combine(result, xyabi.getXRange());\n                }\n                else {\n                    result = Range.combine(result, xyabi.getYRange());\n                }\n            }\n        }\n        return result;\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_33_repairllama-ir4_patch_6.diff",
        "BugId": "Lang_33",
        "PatchedMethods": [
            {
                "DevIntention": "to|class",
                "OrgCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }",
                "PatCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n// buggy code\n//             classes[i] = array[i].getClass();\n           Object value = array[i];\n            if (value != null) {\n                classes[i] = value.getClass();\n            }\n        }\n        return classes;\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_51_repairllama-ir4_patch_3.diff",
        "BugId": "Lang_51",
        "PatchedMethods": [
            {
                "DevIntention": "to|boolean",
                "OrgCode": "public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }",
                "PatCode": "public static boolean toBoolean(String str) {\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n// buggy code\n// \n               return ch == 'n' || ch == 'N';\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_85_repairllama-ir4_patch_9.diff",
        "BugId": "Math_85",
        "PatchedMethods": [
            {
                "DevIntention": "bracket",
                "OrgCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }",
                "PatCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n// buggy code\n//         if (fa * fb >= 0.0 ) {\n       if ((fa * fb >= 0.0 ) && (numIterations >= maximumIterations)) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        return new double[]{a, b};\n    }\n\n    /**\n     * Compute the midpoint of two values.\n     * \n     * @param a first value.\n     * @param b second value.\n     * @return the midpoint. \n     */\n    public static double midpoint(double a, double b) {\n        return (a + b) * .5;\n    }\n    \n    /**\n     * Checks to see if f is null, throwing IllegalArgumentException if so.\n     * @param f  input function\n     * @throws IllegalArgumentException if f is null\n     */\n    private static void setup(UnivariateRealFunction f) {\n        if (f == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n    }\n\n    /** Holder for the factory.\n     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n     */\n    private static class LazyHolder {\n        /** Cached solver factory */\n        private static final UnivariateRealSolverFactory FACTORY =\n            UnivariateRealSolverFactory.newInstance();\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Closure_86_repairllama-ir4_patch_6.diff",
        "BugId": "Closure_86",
        "PatchedMethods": [
            {
                "DevIntention": "evaluates|to|local|value",
                "OrgCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n        return true;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }",
                "PatCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n// buggy code\n//         return true;\n       return isImmutableValue(value) || locals.apply(value);\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return true;\n      case Token.IN:\n        return true;\n      default:\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }"
            }
        ]
    },
    {
        "PatchId": "Math_95_repairllama-ir4_patch_3.diff",
        "BugId": "Math_95",
        "PatchedMethods": [
            {
                "DevIntention": "get|initial|domain",
                "OrgCode": "protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n            ret = d / (d - 2.0);\n        return ret;\n    }",
                "PatCode": "protected double getInitialDomain(double p) {\n// buggy code\n//         double ret;\n//         double d = getDenominatorDegreesOfFreedom();\n//             ret = d / (d - 2.0);\n       double ret = 0.0;\n        double d = getDenominatorDegreesOfFreedom();\n        if (d > 2.0) {\n            ret = d / (d - 2.0);\n        }\n        return ret;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_53_repairllama-ir4_patch_7.diff",
        "BugId": "Math_53",
        "PatchedMethods": [
            {
                "DevIntention": "add",
                "OrgCode": "public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }",
                "PatCode": "public Complex add(Complex rhs)\n        throws NullArgumentException {\n        MathUtils.checkNotNull(rhs);\n// buggy code\n// \n       if (rhs.isNaN()) {\n            return NaN;\n        }\n        return createComplex(real + rhs.getReal(),\n            imaginary + rhs.getImaginary());\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_85_repairllama-ir4_patch_5.diff",
        "BugId": "Math_85",
        "PatchedMethods": [
            {
                "DevIntention": "bracket",
                "OrgCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }",
                "PatCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n// buggy code\n//         if (fa * fb >= 0.0 ) {\n       if (fa * fb >= 0.0 && numIterations >= maximumIterations) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        return new double[]{a, b};\n    }\n\n    /**\n     * Compute the midpoint of two values.\n     * \n     * @param a first value.\n     * @param b second value.\n     * @return the midpoint. \n     */\n    public static double midpoint(double a, double b) {\n        return (a + b) * .5;\n    }\n    \n    /**\n     * Checks to see if f is null, throwing IllegalArgumentException if so.\n     * @param f  input function\n     * @throws IllegalArgumentException if f is null\n     */\n    private static void setup(UnivariateRealFunction f) {\n        if (f == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n    }\n\n    /** Holder for the factory.\n     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n     */\n    private static class LazyHolder {\n        /** Cached solver factory */\n        private static final UnivariateRealSolverFactory FACTORY =\n            UnivariateRealSolverFactory.newInstance();\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Math_79_repairllama-ir4_patch_7.diff",
        "BugId": "Math_79",
        "PatchedMethods": [
            {
                "DevIntention": "distance",
                "OrgCode": "public static double distance(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }",
                "PatCode": "public static double distance(int[] p1, int[] p2) {\n// buggy code\n//       int sum = 0;\n//       for (int i = 0; i < p1.length; i++) {\n//           final int dp = p1[i] - p2[i];\n     double sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final double dp = (double) (p1[i] - p2[i]);\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }\n\n    /**\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>&infin;</sub> distance between the two points\n     */\n    public static double distanceInf(double[] p1, double[] p2) {\n        double max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    /**\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>&infin;</sub> distance between the two points\n     */\n    public static int distanceInf(int[] p1, int[] p2) {\n        int max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n\n}"
            }
        ]
    },
    {
        "PatchId": "Closure_62_repairllama-ir4_patch_5.diff",
        "BugId": "Closure_62",
        "PatchedMethods": [
            {
                "DevIntention": "format|warning",
                "OrgCode": "public String formatWarning(JSError warning) {\n    return format(warning, true);\n  }",
                "PatCode": "public String formatWarning(JSError warning) {\n    return format(warning, true);\n  }"
            },
            {
                "DevIntention": "format",
                "OrgCode": "private String format(JSError error, boolean warning) {\n    // extract source excerpt\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n\n    // formatting the message\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n\n      // padding equal to the excerpt and arrow at the end\n      // charno == sourceExpert.length() means something is missing\n      // at the end of the line\n      if (excerpt.equals(LINE)\n          && 0 <= charno && charno < sourceExcerpt.length()) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }",
                "PatCode": "private String format(JSError error, boolean warning) {\n    SourceExcerptProvider source = getSource();\n    String sourceExcerpt = source == null ? null :\n        excerpt.get(\n            source, error.sourceName, error.lineNumber, excerptFormatter);\n    StringBuilder b = new StringBuilder();\n    if (error.sourceName != null) {\n      b.append(error.sourceName);\n      if (error.lineNumber > 0) {\n        b.append(':');\n        b.append(error.lineNumber);\n      }\n      b.append(\": \");\n    }\n    b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n    b.append(\" - \");\n    b.append(error.description);\n    b.append('\\n');\n    if (sourceExcerpt != null) {\n      b.append(sourceExcerpt);\n      b.append('\\n');\n      int charno = error.getCharno();\n      if (excerpt.equals(LINE)\n// buggy code\n//           && 0 <= charno && charno < sourceExcerpt.length()) {\n         && 0 <= charno && charno < sourceExcerpt.length() + 1) {\n        for (int i = 0; i < charno; i++) {\n          char c = sourceExcerpt.charAt(i);\n          if (Character.isWhitespace(c)) {\n            b.append(c);\n          } else {\n            b.append(' ');\n          }\n        }\n        b.append(\"^\\n\");\n      }\n    }\n    return b.toString();\n  }\n\n  /**\n   * Formats a region by appending line numbers in front, e.g.\n   * <pre>   9| if (foo) {\n   *   10|   alert('bar');\n   *   11| }</pre>\n   * and return line excerpt without any modification.\n   */\n  static class LineNumberingFormatter implements ExcerptFormatter {\n    public String formatLine(String line, int lineNumber) {\n      return line;\n    }\n\n    public String formatRegion(Region region) {\n      if (region == null) {\n        return null;\n      }\n      String code = region.getSourceExcerpt();\n      if (code.length() == 0) {\n        return null;\n      }\n\n      // max length of the number display\n      int numberLength = Integer.toString(region.getEndingLineNumber())\n          .length();\n\n      // formatting\n      StringBuilder builder = new StringBuilder(code.length() * 2);\n      int start = 0;\n      int end = code.indexOf('\\n', start);\n      int lineNumber = region.getBeginningLineNumber();\n      while (start >= 0) {\n        // line extraction\n        String line;\n        if (end < 0) {\n          line = code.substring(start);\n          if (line.length() == 0) {\n            return builder.substring(0, builder.length() - 1);\n          }\n        } else {\n          line = code.substring(start, end);\n        }\n        builder.append(\"  \");\n\n        // nice spaces for the line number\n        int spaces = numberLength - Integer.toString(lineNumber).length();\n        builder.append(Strings.repeat(\" \", spaces));\n        builder.append(lineNumber);\n        builder.append(\"| \");\n\n        // end & update\n        if (end < 0) {\n          builder.append(line);\n          start = -1;\n        } else {\n          builder.append(line);\n          builder.append('\\n');\n          start = end + 1;\n          end = code.indexOf('\\n', start);\n          lineNumber++;\n        }\n      }\n      return builder.toString();\n    }\n  }\n}"
            }
        ]
    },
    {
        "PatchId": "Math_50_repairllama-ir4_patch_6.diff",
        "BugId": "Math_50",
        "PatchedMethods": [
            {
                "DevIntention": "do|solve",
                "OrgCode": "protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }",
                "PatCode": "protected final double doSolve() {\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n        verifyBracketing(x0, x1);\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n        boolean inverted = false;\n        while (true) {\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n            if (fx == 0.0) {\n                return x;\n            }\n            if (f1 * fx < 0) {\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n// buggy code\n//                     if (x == x1) {\n//                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n//                         f0 = computeObjectiveValue(x0);\n//                     }\n                   if (x == x0) {\n                        x1 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x0), atol));\n                        f1 = computeObjectiveValue(x1);\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n            x1 = x;\n            f1 = fx;\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_13_repairllama-ir4_patch_1.diff",
        "BugId": "Chart_13",
        "PatchedMethods": [
            {
                "DevIntention": "arrange|f|f",
                "OrgCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth() - w[2]),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }",
                "PatCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy code\n//                     new Range(0.0, constraint.getWidth() - w[2]),\n                   new Range(0.0, constraint.getWidth() - w[3]),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_45_repairllama-ir4_patch_1.diff",
        "BugId": "Lang_45",
        "PatchedMethods": [
            {
                "DevIntention": "abbreviate",
                "OrgCode": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n        if (upper < lower) {\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }",
                "PatCode": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n// buggy code\n// \n       }\n        if (lower == -1 || lower > str.length()) {\n            lower = str.length();\n        }\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        if (upper < lower) {\n            upper = lower;\n        }\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_32_repairllama-ir4_patch_2.diff",
        "BugId": "Math_32",
        "PatchedMethods": [
            {
                "DevIntention": "compute|geometrical|properties",
                "OrgCode": "protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if ((Boolean) tree.getAttribute()) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }",
                "PatCode": "protected void computeGeometricalProperties() {\n        final Vector2D[][] v = getVertices();\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy code\n//             if ((Boolean) tree.getAttribute()) {\n           if (Boolean.TRUE.equals(tree.getAttribute())) {\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n            if (sum < 0) {\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n        }\n    }\n\n    /** Get the vertices of the polygon.\n     * <p>The polygon boundary can be represented as an array of loops,\n     * each loop being itself an array of vertices.</p>\n     * <p>In order to identify open loops which start and end by\n     * infinite edges, the open loops arrays start with a null point. In\n     * this case, the first non null point and the last point of the\n     * array do not represent real vertices, they are dummy points\n     * intended only to get the direction of the first and last edge. An\n     * open loop consisting of a single infinite line will therefore be\n     * represented by a three elements array with one null point\n     * followed by two dummy points. The open loops are always the first\n     * ones in the loops array.</p>\n     * <p>If the polygon has no boundary at all, a zero length loop\n     * array will be returned.</p>\n     * <p>All line segments in the various loops have the inside of the\n     * region on their left side and the outside on their right side\n     * when moving in the underlying line direction. This means that\n     * closed loops surrounding finite areas obey the direct\n     * trigonometric orientation.</p>\n     * @return vertices of the polygon, organized as oriented boundary\n     * loops with the open loops first (the returned value is guaranteed\n     * to be non-null)\n     */\n    public Vector2D[][] getVertices() {\n        if (vertices == null) {\n            if (getTree(false).getCut() == null) {\n                vertices = new Vector2D[0][];\n            } else {\n\n                // sort the segments according to their start point\n                final SegmentsBuilder visitor = new SegmentsBuilder();\n                getTree(true).visit(visitor);\n                final AVLTree<ComparableSegment> sorted = visitor.getSorted();\n\n                // identify the loops, starting from the open ones\n                // (their start segments are naturally at the sorted set beginning)\n                final ArrayList<List<ComparableSegment>> loops = new ArrayList<List<ComparableSegment>>();\n                while (!sorted.isEmpty()) {\n                    final AVLTree<ComparableSegment>.Node node = sorted.getSmallest();\n                    final List<ComparableSegment> loop = followLoop(node, sorted);\n                    if (loop != null) {\n                        loops.add(loop);\n                    }\n                }\n\n                // tranform the loops in an array of arrays of points\n                vertices = new Vector2D[loops.size()][];\n                int i = 0;\n\n                for (final List<ComparableSegment> loop : loops) {\n                    if (loop.size() < 2) {\n                        // single infinite line\n                        final Line line = loop.get(0).getLine();\n                        vertices[i++] = new Vector2D[] {\n                            null,\n                            line.toSpace(new Vector1D(-Float.MAX_VALUE)),\n                            line.toSpace(new Vector1D(+Float.MAX_VALUE))\n                        };\n                    } else if (loop.get(0).getStart() == null) {\n                        // open loop with at least one real point\n                        final Vector2D[] array = new Vector2D[loop.size() + 2];\n                        int j = 0;\n                        for (Segment segment : loop) {\n\n                            if (j == 0) {\n                                // null point and first dummy point\n                                double x = segment.getLine().toSubSpace(segment.getEnd()).getX();\n                                x -= FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = null;\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                            if (j < (array.length - 1)) {\n                                // current point\n                                array[j++] = segment.getEnd();\n                            }\n\n                            if (j == (array.length - 1)) {\n                                // last dummy point\n                                double x = segment.getLine().toSubSpace(segment.getStart()).getX();\n                                x += FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                        }\n                        vertices[i++] = array;\n                    } else {\n                        final Vector2D[] array = new Vector2D[loop.size()];\n                        int j = 0;\n                        for (Segment segment : loop) {\n                            array[j++] = segment.getStart();\n                        }\n                        vertices[i++] = array;\n                    }\n                }\n\n            }\n        }\n\n        return vertices.clone();\n\n    }\n\n    /** Follow a boundary loop.\n     * @param node node containing the segment starting the loop\n     * @param sorted set of segments belonging to the boundary, sorted by\n     * start points (contains {@code node})\n     * @return a list of connected sub-hyperplanes starting at\n     * {@code node}\n     */\n    private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node,\n                                               final AVLTree<ComparableSegment> sorted) {\n\n        final ArrayList<ComparableSegment> loop = new ArrayList<ComparableSegment>();\n        ComparableSegment segment = node.getElement();\n        loop.add(segment);\n        final Vector2D globalStart = segment.getStart();\n        Vector2D end = segment.getEnd();\n        node.delete();\n\n        // is this an open or a closed loop ?\n        final boolean open = segment.getStart() == null;\n\n        while ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) {\n\n            // search the sub-hyperplane starting where the previous one ended\n            AVLTree<ComparableSegment>.Node selectedNode = null;\n            ComparableSegment       selectedSegment  = null;\n            double                  selectedDistance = Double.POSITIVE_INFINITY;\n            final ComparableSegment lowerLeft        = new ComparableSegment(end, -1.0e-10, -1.0e-10);\n            final ComparableSegment upperRight       = new ComparableSegment(end, +1.0e-10, +1.0e-10);\n            for (AVLTree<ComparableSegment>.Node n = sorted.getNotSmaller(lowerLeft);\n                 (n != null) && (n.getElement().compareTo(upperRight) <= 0);\n                 n = n.getNext()) {\n                segment = n.getElement();\n                final double distance = end.distance(segment.getStart());\n                if (distance < selectedDistance) {\n                    selectedNode     = n;\n                    selectedSegment  = segment;\n                    selectedDistance = distance;\n                }\n            }\n\n            if (selectedDistance > 1.0e-10) {\n                // this is a degenerated loop, it probably comes from a very\n                // tiny region with some segments smaller than the threshold, we\n                // simply ignore it\n                return null;\n            }\n\n            end = selectedSegment.getEnd();\n            loop.add(selectedSegment);\n            selectedNode.delete();\n\n        }\n\n        if ((loop.size() == 2) && !open) {\n            // this is a degenerated infinitely thin loop, we simply ignore it\n            return null;\n        }\n\n        if ((end == null) && !open) {\n            throw new MathInternalError();\n        }\n\n        return loop;\n\n    }\n\n    /** Private extension of Segment allowing comparison. */\n    private static class ComparableSegment extends Segment implements Comparable<ComparableSegment> {\n\n        /** Sorting key. */\n        private OrderedTuple sortingKey;\n\n        /** Build a segment.\n         * @param start start point of the segment\n         * @param end end point of the segment\n         * @param line line containing the segment\n         */\n        public ComparableSegment(final Vector2D start, final Vector2D end, final Line line) {\n            super(start, end, line);\n            sortingKey = (start == null) ?\n                         new OrderedTuple(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) :\n                         new OrderedTuple(start.getX(), start.getY());\n        }\n\n        /** Build a dummy segment.\n         * <p>\n         * The object built is not a real segment, only the sorting key is used to\n         * allow searching in the neighborhood of a point. This is an horrible hack ...\n         * </p>\n         * @param start start point of the segment\n         * @param dx abscissa offset from the start point\n         * @param dy ordinate offset from the start point\n         */\n        public ComparableSegment(final Vector2D start, final double dx, final double dy) {\n            super(null, null, null);\n            sortingKey = new OrderedTuple(start.getX() + dx, start.getY() + dy);\n        }\n\n        /** {@inheritDoc} */\n        public int compareTo(final ComparableSegment o) {\n            return sortingKey.compareTo(o.sortingKey);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean equals(final Object other) {\n            if (this == other) {\n                return true;\n            } else if (other instanceof ComparableSegment) {\n                return compareTo((ComparableSegment) other) == 0;\n            } else {\n                return false;\n            }\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int hashCode() {\n            return getStart().hashCode() ^ getEnd().hashCode() ^\n                   getLine().hashCode() ^ sortingKey.hashCode();\n        }\n\n    }\n\n    /** Visitor building segments. */\n    private static class SegmentsBuilder implements BSPTreeVisitor<Euclidean2D> {\n\n        /** Sorted segments. */\n        private AVLTree<ComparableSegment> sorted;\n\n        /** Simple constructor. */\n        public SegmentsBuilder() {\n            sorted = new AVLTree<ComparableSegment>();\n        }\n\n        /** {@inheritDoc} */\n        public Order visitOrder(final BSPTree<Euclidean2D> node) {\n            return Order.MINUS_SUB_PLUS;\n        }\n\n        /** {@inheritDoc} */\n        public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n            @SuppressWarnings(\"unchecked\")\n            final BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute();\n            if (attribute.getPlusOutside() != null) {\n                addContribution(attribute.getPlusOutside(), false);\n            }\n            if (attribute.getPlusInside() != null) {\n                addContribution(attribute.getPlusInside(), true);\n            }\n        }\n\n        /** {@inheritDoc} */\n        public void visitLeafNode(final BSPTree<Euclidean2D> node) {\n        }\n\n        /** Add he contribution of a boundary facet.\n         * @param sub boundary facet\n         * @param reversed if true, the facet has the inside on its plus side\n         */\n        private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n            @SuppressWarnings(\"unchecked\")\n            final AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub =\n                (AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub;\n            final Line line      = (Line) sub.getHyperplane();\n            final List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();\n            for (final Interval i : intervals) {\n                final Vector2D start = Double.isInfinite(i.getLower()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getLower()));\n                final Vector2D end   = Double.isInfinite(i.getUpper()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getUpper()));\n                if (reversed) {\n                    sorted.insert(new ComparableSegment(end, start, line.getReverse()));\n                } else {\n                    sorted.insert(new ComparableSegment(start, end, line));\n                }\n            }\n        }\n\n        /** Get the sorted segments.\n         * @return sorted segments\n         */\n        public AVLTree<ComparableSegment> getSorted() {\n            return sorted;\n        }\n\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Chart_1_repairllama-ir4_patch_9.diff",
        "BugId": "Chart_1",
        "PatchedMethods": [
            {
                "DevIntention": "get|legend|items",
                "OrgCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset != null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }",
                "PatCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n// buggy code\n//         if (dataset != null) {\n       if ((dataset == null) || (dataset.getRowCount() <= 0)) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Adds an entity with the specified hotspot.\n     *\n     * @param entities  the entity collection.\n     * @param hotspot  the hotspot (<code>null</code> not permitted).\n     * @param dataset  the dataset.\n     * @param row  the row index.\n     * @param column  the column index.\n     * @param selected  is the item selected?\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected) {\n\n        if (hotspot == null) {\n            throw new IllegalArgumentException(\"Null 'hotspot' argument.\");\n        }\n        addEntity(entities, hotspot, dataset, row, column, selected, 0.0, 0.0);\n    }\n\n    /**\n     * Adds an entity to the collection.\n     *\n     * @param entities  the entity collection being populated.\n     * @param hotspot  the entity area (if <code>null</code> a default will be\n     *              used).\n     * @param dataset  the dataset.\n     * @param row  the series.\n     * @param column  the item.\n     * @param selected  is the item selected?\n     * @param entityX  the entity's center x-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     * @param entityY  the entity's center y-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            double entityX, double entityY) {\n        if (!getItemCreateEntity(row, column, selected)) {\n            return;\n        }\n        Shape s = hotspot;\n        if (hotspot == null) {\n            double r = getDefaultEntityRadius();\n            double w = r * 2;\n            if (getPlot().getOrientation() == PlotOrientation.VERTICAL) {\n                s = new Ellipse2D.Double(entityX - r, entityY - r, w, w);\n            }\n            else {\n                s = new Ellipse2D.Double(entityY - r, entityX - r, w, w);\n            }\n        }\n        String tip = null;\n        CategoryToolTipGenerator generator = getToolTipGenerator(row, column,\n                selected);\n        if (generator != null) {\n            tip = generator.generateToolTip(dataset, row, column);\n        }\n        String url = null;\n        CategoryURLGenerator urlster = getURLGenerator(row, column, selected);\n        if (urlster != null) {\n            url = urlster.generateURL(dataset, row, column);\n        }\n        CategoryItemEntity entity = new CategoryItemEntity(s, tip, url,\n                dataset, dataset.getRowKey(row), dataset.getColumnKey(column));\n        entities.add(entity);\n    }\n\n        /**\n     * Returns a shape that can be used for hit testing on a data item drawn\n     * by the renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area within which the data is being rendered.\n     * @param plot  the plot (can be used to obtain standard color\n     *              information etc).\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the dataset.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param selected  is the item selected?\n     *\n     * @return A shape equal to the hot spot for a data item.\n     */\n    public Shape createHotSpotShape(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state) {\n        throw new RuntimeException(\"Not implemented.\");\n    }\n\n    /**\n     * Returns the rectangular bounds for the hot spot for an item drawn by\n     * this renderer.  This is intended to provide a quick test for\n     * eliminating data points before more accurate testing against the\n     * shape returned by createHotSpotShape().\n     *\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     * @param result\n     * @return\n     */\n    public Rectangle2D createHotSpotBounds(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state, Rectangle2D result) {\n        if (result == null) {\n            result = new Rectangle();\n        }\n        Comparable key = dataset.getColumnKey(column);\n        Number y = dataset.getValue(row, column);\n        if (y == null) {\n            return null;\n        }\n        double xx = domainAxis.getCategoryMiddle(key,\n                plot.getCategoriesForAxis(domainAxis),\n                dataArea, plot.getDomainAxisEdge());\n        double yy = rangeAxis.valueToJava2D(y.doubleValue(), dataArea,\n                plot.getRangeAxisEdge());\n        result.setRect(xx - 2, yy - 2, 4, 4);\n        return result;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified point (xx, yy) in Java2D\n     * space falls within the \"hot spot\" for the specified data item, and\n     * <code>false</code> otherwise.\n     *\n     * @param xx\n     * @param yy\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     *\n     * @return\n     *\n     * @since 1.2.0\n     */\n    public boolean hitTest(double xx, double yy, Graphics2D g2,\n            Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,\n            ValueAxis rangeAxis, CategoryDataset dataset, int row, int column,\n            boolean selected, CategoryItemRendererState state) {\n        Rectangle2D bounds = createHotSpotBounds(g2, dataArea, plot,\n                domainAxis, rangeAxis, dataset, row, column, selected,\n                state, null);\n        if (bounds == null) {\n            return false;\n        }\n        // FIXME:  if the following test passes, we should then do the more\n        // expensive test against the hotSpotShape\n        return bounds.contains(xx, yy);\n    }\n    \n}"
            }
        ]
    },
    {
        "PatchId": "Lang_59_repairllama-ir4_patch_9.diff",
        "BugId": "Lang_59",
        "PatchedMethods": [
            {
                "DevIntention": "append|fixed|width|pad|right",
                "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }",
                "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n// buggy code\n//                 str.getChars(0, strLen, buffer, size);\n               System.arraycopy(str.toCharArray(), 0, buffer, size, width);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_26_repairllama-ir4_patch_8.diff",
        "BugId": "Chart_26",
        "PatchedMethods": [
            {
                "DevIntention": "draw|label",
                "OrgCode": "protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n\n        // it is unlikely that 'state' will be null, but check anyway...\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        \n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        \n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n                EntityCollection entities = owner.getEntityCollection();\n                if (entities != null) {\n                    entities.add(new AxisLabelEntity(this, hotspot, \n                            this.labelToolTip, this.labelURL));\n                }\n        }\n        return state;\n\n    }",
                "PatCode": "protected AxisState drawLabel(String label, Graphics2D g2, \n            Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, \n            AxisState state, PlotRenderingInfo plotState) {\n        if (state == null) {\n            throw new IllegalArgumentException(\"Null 'state' argument.\");\n        }\n        if ((label == null) || (label.equals(\"\"))) {\n            return state;\n        }\n        Font font = getLabelFont();\n        RectangleInsets insets = getLabelInsets();\n        g2.setFont(font);\n        g2.setPaint(getLabelPaint());\n        FontMetrics fm = g2.getFontMetrics();\n        Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm);\n        Shape hotspot = null;\n        if (edge == RectangleEdge.TOP) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() - insets.getBottom() \n                    - h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorUp(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.BOTTOM) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle(), labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) dataArea.getCenterX();\n            float labely = (float) (state.getCursor() + insets.getTop() \n                    + h / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorDown(insets.getTop() + labelBounds.getHeight() \n                    + insets.getBottom());\n        }\n        else if (edge == RectangleEdge.LEFT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), \n                    labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() - insets.getRight() \n                    - w / 2.0);\n            float labely = (float) dataArea.getCenterY();\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorLeft(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        else if (edge == RectangleEdge.RIGHT) {\n            AffineTransform t = AffineTransform.getRotateInstance(\n                    getLabelAngle() + Math.PI / 2.0, \n                    labelBounds.getCenterX(), labelBounds.getCenterY());\n            Shape rotatedLabelBounds = t.createTransformedShape(labelBounds);\n            labelBounds = rotatedLabelBounds.getBounds2D();\n            float w = (float) labelBounds.getWidth();\n            float h = (float) labelBounds.getHeight();\n            float labelx = (float) (state.getCursor() \n                            + insets.getLeft() + w / 2.0);\n            float labely = (float) (dataArea.getY() + dataArea.getHeight() \n                    / 2.0);\n            TextUtilities.drawRotatedString(label, g2, labelx, labely, \n                    TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, \n                    TextAnchor.CENTER);\n            hotspot = new Rectangle2D.Float(labelx - w / 2.0f, \n                    labely - h / 2.0f, w, h);\n            state.cursorRight(insets.getLeft() + labelBounds.getWidth() \n                    + insets.getRight());\n        }\n        if (plotState != null && hotspot != null) {\n            ChartRenderingInfo owner = plotState.getOwner();\n// buggy code\n//                 EntityCollection entities = owner.getEntityCollection();\n//                 if (entities != null) {\n//                     entities.add(new AxisLabelEntity(this, hotspot, \n//                             this.labelToolTip, this.labelURL));\n//                 }\n        }\n        return state;\n    }"
            }
        ]
    },
    {
        "PatchId": "Closure_86_repairllama-ir4_patch_7.diff",
        "BugId": "Closure_86",
        "PatchedMethods": [
            {
                "DevIntention": "evaluates|to|local|value",
                "OrgCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n        return true;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }",
                "PatCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n// buggy code\n//         return true;\n       return NodeUtil.isImmutableValue(value);\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return true;\n      case Token.IN:\n        return true;\n      default:\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }"
            }
        ]
    },
    {
        "PatchId": "Math_11_repairllama-ir4_patch_6.diff",
        "BugId": "Math_11",
        "PatchedMethods": [
            {
                "DevIntention": "density",
                "OrgCode": "public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n\n        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }",
                "PatCode": "public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n// buggy code\n//         return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n       return FastMath.pow(2 * FastMath.PI, -dim / 2D) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_1_repairllama-ir4_patch_5.diff",
        "BugId": "Chart_1",
        "PatchedMethods": [
            {
                "DevIntention": "get|legend|items",
                "OrgCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset != null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }",
                "PatCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n// buggy code\n//         if (dataset != null) {\n       if (index < 0 || dataset == null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Adds an entity with the specified hotspot.\n     *\n     * @param entities  the entity collection.\n     * @param hotspot  the hotspot (<code>null</code> not permitted).\n     * @param dataset  the dataset.\n     * @param row  the row index.\n     * @param column  the column index.\n     * @param selected  is the item selected?\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected) {\n\n        if (hotspot == null) {\n            throw new IllegalArgumentException(\"Null 'hotspot' argument.\");\n        }\n        addEntity(entities, hotspot, dataset, row, column, selected, 0.0, 0.0);\n    }\n\n    /**\n     * Adds an entity to the collection.\n     *\n     * @param entities  the entity collection being populated.\n     * @param hotspot  the entity area (if <code>null</code> a default will be\n     *              used).\n     * @param dataset  the dataset.\n     * @param row  the series.\n     * @param column  the item.\n     * @param selected  is the item selected?\n     * @param entityX  the entity's center x-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     * @param entityY  the entity's center y-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            double entityX, double entityY) {\n        if (!getItemCreateEntity(row, column, selected)) {\n            return;\n        }\n        Shape s = hotspot;\n        if (hotspot == null) {\n            double r = getDefaultEntityRadius();\n            double w = r * 2;\n            if (getPlot().getOrientation() == PlotOrientation.VERTICAL) {\n                s = new Ellipse2D.Double(entityX - r, entityY - r, w, w);\n            }\n            else {\n                s = new Ellipse2D.Double(entityY - r, entityX - r, w, w);\n            }\n        }\n        String tip = null;\n        CategoryToolTipGenerator generator = getToolTipGenerator(row, column,\n                selected);\n        if (generator != null) {\n            tip = generator.generateToolTip(dataset, row, column);\n        }\n        String url = null;\n        CategoryURLGenerator urlster = getURLGenerator(row, column, selected);\n        if (urlster != null) {\n            url = urlster.generateURL(dataset, row, column);\n        }\n        CategoryItemEntity entity = new CategoryItemEntity(s, tip, url,\n                dataset, dataset.getRowKey(row), dataset.getColumnKey(column));\n        entities.add(entity);\n    }\n\n        /**\n     * Returns a shape that can be used for hit testing on a data item drawn\n     * by the renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area within which the data is being rendered.\n     * @param plot  the plot (can be used to obtain standard color\n     *              information etc).\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the dataset.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param selected  is the item selected?\n     *\n     * @return A shape equal to the hot spot for a data item.\n     */\n    public Shape createHotSpotShape(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state) {\n        throw new RuntimeException(\"Not implemented.\");\n    }\n\n    /**\n     * Returns the rectangular bounds for the hot spot for an item drawn by\n     * this renderer.  This is intended to provide a quick test for\n     * eliminating data points before more accurate testing against the\n     * shape returned by createHotSpotShape().\n     *\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     * @param result\n     * @return\n     */\n    public Rectangle2D createHotSpotBounds(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state, Rectangle2D result) {\n        if (result == null) {\n            result = new Rectangle();\n        }\n        Comparable key = dataset.getColumnKey(column);\n        Number y = dataset.getValue(row, column);\n        if (y == null) {\n            return null;\n        }\n        double xx = domainAxis.getCategoryMiddle(key,\n                plot.getCategoriesForAxis(domainAxis),\n                dataArea, plot.getDomainAxisEdge());\n        double yy = rangeAxis.valueToJava2D(y.doubleValue(), dataArea,\n                plot.getRangeAxisEdge());\n        result.setRect(xx - 2, yy - 2, 4, 4);\n        return result;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified point (xx, yy) in Java2D\n     * space falls within the \"hot spot\" for the specified data item, and\n     * <code>false</code> otherwise.\n     *\n     * @param xx\n     * @param yy\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     *\n     * @return\n     *\n     * @since 1.2.0\n     */\n    public boolean hitTest(double xx, double yy, Graphics2D g2,\n            Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,\n            ValueAxis rangeAxis, CategoryDataset dataset, int row, int column,\n            boolean selected, CategoryItemRendererState state) {\n        Rectangle2D bounds = createHotSpotBounds(g2, dataArea, plot,\n                domainAxis, rangeAxis, dataset, row, column, selected,\n                state, null);\n        if (bounds == null) {\n            return false;\n        }\n        // FIXME:  if the following test passes, we should then do the more\n        // expensive test against the hotSpotShape\n        return bounds.contains(xx, yy);\n    }\n    \n}"
            }
        ]
    },
    {
        "PatchId": "Math_85_repairllama-ir4_patch_8.diff",
        "BugId": "Math_85",
        "PatchedMethods": [
            {
                "DevIntention": "bracket",
                "OrgCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }",
                "PatCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n// buggy code\n//         if (fa * fb >= 0.0 ) {\n       if ((fa * fb >= 0.0) && (numIterations == maximumIterations)) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        return new double[]{a, b};\n    }\n\n    /**\n     * Compute the midpoint of two values.\n     * \n     * @param a first value.\n     * @param b second value.\n     * @return the midpoint. \n     */\n    public static double midpoint(double a, double b) {\n        return (a + b) * .5;\n    }\n    \n    /**\n     * Checks to see if f is null, throwing IllegalArgumentException if so.\n     * @param f  input function\n     * @throws IllegalArgumentException if f is null\n     */\n    private static void setup(UnivariateRealFunction f) {\n        if (f == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n    }\n\n    /** Holder for the factory.\n     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n     */\n    private static class LazyHolder {\n        /** Cached solver factory */\n        private static final UnivariateRealSolverFactory FACTORY =\n            UnivariateRealSolverFactory.newInstance();\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Chart_7_repairllama-ir4_patch_2.diff",
        "BugId": "Chart_7",
        "PatchedMethods": [
            {
                "DevIntention": "update|bounds",
                "OrgCode": "private void updateBounds(TimePeriod period, int index) {\n        \n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        \n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        \n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        \n        if (this.maxMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        \n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n       \n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n        \n    }",
                "PatCode": "private void updateBounds(TimePeriod period, int index) {\n        long start = period.getStart().getTime();\n        long end = period.getEnd().getTime();\n        long middle = start + ((end - start) / 2);\n        if (this.minStartIndex >= 0) {\n            long minStart = getDataItem(this.minStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start < minStart) {\n                this.minStartIndex = index;           \n            }\n        }\n        else {\n            this.minStartIndex = index;\n        }\n        if (this.maxStartIndex >= 0) {\n            long maxStart = getDataItem(this.maxStartIndex).getPeriod()\n                .getStart().getTime();\n            if (start > maxStart) {\n                this.maxStartIndex = index;           \n            }\n        }\n        else {\n            this.maxStartIndex = index;\n        }\n        if (this.minMiddleIndex >= 0) {\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long minMiddle = s + (e - s) / 2;\n            if (middle < minMiddle) {\n                this.minMiddleIndex = index;           \n            }\n        }\n        else {\n            this.minMiddleIndex = index;\n        }\n        if (this.maxMiddleIndex >= 0) {\n// buggy code\n//             long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n//                 .getTime();\n//             long e = getDataItem(this.minMiddleIndex).getPeriod().getEnd()\n            long s = getDataItem(this.minMiddleIndex).getPeriod().getStart()\n                .getTime();\n            long e = getDataItem(this.maxMiddleIndex).getPeriod().getEnd()\n                .getTime();\n            long maxMiddle = s + (e - s) / 2;\n            if (middle > maxMiddle) {\n                this.maxMiddleIndex = index;           \n            }\n        }\n        else {\n            this.maxMiddleIndex = index;\n        }\n        if (this.minEndIndex >= 0) {\n            long minEnd = getDataItem(this.minEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end < minEnd) {\n                this.minEndIndex = index;           \n            }\n        }\n        else {\n            this.minEndIndex = index;\n        }\n        if (this.maxEndIndex >= 0) {\n            long maxEnd = getDataItem(this.maxEndIndex).getPeriod().getEnd()\n                .getTime();\n            if (end > maxEnd) {\n                this.maxEndIndex = index;           \n            }\n        }\n        else {\n            this.maxEndIndex = index;\n        }\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_33_repairllama-ir4_patch_7.diff",
        "BugId": "Lang_33",
        "PatchedMethods": [
            {
                "DevIntention": "to|class",
                "OrgCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }",
                "PatCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n// buggy code\n//             classes[i] = array[i].getClass();\n           Object object = array[i];\n            classes[i] = object == null ? null : object.getClass();\n        }\n        return classes;\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_43_repairllama-ir4_patch_9.diff",
        "BugId": "Lang_43",
        "PatchedMethods": [
            {
                "DevIntention": "append|quoted|string",
                "OrgCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }",
                "PatCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n// buggy code\n// \n           pos.setIndex(start + 1); \n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_11_repairllama-ir4_patch_5.diff",
        "BugId": "Math_11",
        "PatchedMethods": [
            {
                "DevIntention": "density",
                "OrgCode": "public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n\n        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }",
                "PatCode": "public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n// buggy code\n//         return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n       return FastMath.pow(2 * FastMath.PI, -dim / 2d) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_1_repairllama-ir4_patch_6.diff",
        "BugId": "Chart_1",
        "PatchedMethods": [
            {
                "DevIntention": "get|legend|items",
                "OrgCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset != null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }",
                "PatCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n// buggy code\n//         if (dataset != null) {\n       if (dataset == null || !isSeriesVisibleInLegend(0)) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Adds an entity with the specified hotspot.\n     *\n     * @param entities  the entity collection.\n     * @param hotspot  the hotspot (<code>null</code> not permitted).\n     * @param dataset  the dataset.\n     * @param row  the row index.\n     * @param column  the column index.\n     * @param selected  is the item selected?\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected) {\n\n        if (hotspot == null) {\n            throw new IllegalArgumentException(\"Null 'hotspot' argument.\");\n        }\n        addEntity(entities, hotspot, dataset, row, column, selected, 0.0, 0.0);\n    }\n\n    /**\n     * Adds an entity to the collection.\n     *\n     * @param entities  the entity collection being populated.\n     * @param hotspot  the entity area (if <code>null</code> a default will be\n     *              used).\n     * @param dataset  the dataset.\n     * @param row  the series.\n     * @param column  the item.\n     * @param selected  is the item selected?\n     * @param entityX  the entity's center x-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     * @param entityY  the entity's center y-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            double entityX, double entityY) {\n        if (!getItemCreateEntity(row, column, selected)) {\n            return;\n        }\n        Shape s = hotspot;\n        if (hotspot == null) {\n            double r = getDefaultEntityRadius();\n            double w = r * 2;\n            if (getPlot().getOrientation() == PlotOrientation.VERTICAL) {\n                s = new Ellipse2D.Double(entityX - r, entityY - r, w, w);\n            }\n            else {\n                s = new Ellipse2D.Double(entityY - r, entityX - r, w, w);\n            }\n        }\n        String tip = null;\n        CategoryToolTipGenerator generator = getToolTipGenerator(row, column,\n                selected);\n        if (generator != null) {\n            tip = generator.generateToolTip(dataset, row, column);\n        }\n        String url = null;\n        CategoryURLGenerator urlster = getURLGenerator(row, column, selected);\n        if (urlster != null) {\n            url = urlster.generateURL(dataset, row, column);\n        }\n        CategoryItemEntity entity = new CategoryItemEntity(s, tip, url,\n                dataset, dataset.getRowKey(row), dataset.getColumnKey(column));\n        entities.add(entity);\n    }\n\n        /**\n     * Returns a shape that can be used for hit testing on a data item drawn\n     * by the renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area within which the data is being rendered.\n     * @param plot  the plot (can be used to obtain standard color\n     *              information etc).\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the dataset.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param selected  is the item selected?\n     *\n     * @return A shape equal to the hot spot for a data item.\n     */\n    public Shape createHotSpotShape(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state) {\n        throw new RuntimeException(\"Not implemented.\");\n    }\n\n    /**\n     * Returns the rectangular bounds for the hot spot for an item drawn by\n     * this renderer.  This is intended to provide a quick test for\n     * eliminating data points before more accurate testing against the\n     * shape returned by createHotSpotShape().\n     *\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     * @param result\n     * @return\n     */\n    public Rectangle2D createHotSpotBounds(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state, Rectangle2D result) {\n        if (result == null) {\n            result = new Rectangle();\n        }\n        Comparable key = dataset.getColumnKey(column);\n        Number y = dataset.getValue(row, column);\n        if (y == null) {\n            return null;\n        }\n        double xx = domainAxis.getCategoryMiddle(key,\n                plot.getCategoriesForAxis(domainAxis),\n                dataArea, plot.getDomainAxisEdge());\n        double yy = rangeAxis.valueToJava2D(y.doubleValue(), dataArea,\n                plot.getRangeAxisEdge());\n        result.setRect(xx - 2, yy - 2, 4, 4);\n        return result;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified point (xx, yy) in Java2D\n     * space falls within the \"hot spot\" for the specified data item, and\n     * <code>false</code> otherwise.\n     *\n     * @param xx\n     * @param yy\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     *\n     * @return\n     *\n     * @since 1.2.0\n     */\n    public boolean hitTest(double xx, double yy, Graphics2D g2,\n            Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,\n            ValueAxis rangeAxis, CategoryDataset dataset, int row, int column,\n            boolean selected, CategoryItemRendererState state) {\n        Rectangle2D bounds = createHotSpotBounds(g2, dataArea, plot,\n                domainAxis, rangeAxis, dataset, row, column, selected,\n                state, null);\n        if (bounds == null) {\n            return false;\n        }\n        // FIXME:  if the following test passes, we should then do the more\n        // expensive test against the hotSpotShape\n        return bounds.contains(xx, yy);\n    }\n    \n}"
            }
        ]
    },
    {
        "PatchId": "Chart_9_repairllama-ir4_patch_1.diff",
        "BugId": "Chart_9",
        "PatchedMethods": [
            {
                "DevIntention": "create|copy",
                "OrgCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if (endIndex < 0) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }",
                "PatCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {\n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n// buggy code\n//         if (endIndex < 0) {\n       if (startIndex > endIndex) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param object  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                s.getDomainDescription())) {\n            return false;\n        }\n\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                s.getRangeDescription())) {\n            return false;\n        }\n\n        if (!getClass().equals(s.getClass())) {\n            return false;\n        }\n\n        if (getMaximumItemAge() != s.getMaximumItemAge()) {\n            return false;\n        }\n\n        if (getMaximumItemCount() != s.getMaximumItemCount()) {\n            return false;\n        }\n\n        int count = getItemCount();\n        if (count != s.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(s.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Math_30_repairllama-ir4_patch_3.diff",
        "BugId": "Math_30",
        "PatchedMethods": [
            {
                "DevIntention": "calculate|asymptotic|p|value",
                "OrgCode": "private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n\n        final int n1n2prod = n1 * n2;\n\n        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n        final double EU = n1n2prod / 2.0;\n        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n\n        final double z = (Umin - EU) / FastMath.sqrt(VarU);\n\n        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n\n        return 2 * standardNormal.cumulativeProbability(z);\n    }",
                "PatCode": "private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n// buggy code\n//         final int n1n2prod = n1 * n2;\n       final double n1n2prod = (double) n1 * n2;\n        final double EU = n1n2prod / 2.0;\n        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n        final double z = (Umin - EU) / FastMath.sqrt(VarU);\n        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n        return 2 * standardNormal.cumulativeProbability(z);\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_28_repairllama-ir4_patch_2.diff",
        "BugId": "Math_28",
        "PatchedMethods": [
            {
                "DevIntention": "get|pivot|row",
                "OrgCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        // create a list of all the rows that tie for the lowest score in the minimum ratio test\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                // check if the entry is strictly equal to the current min ratio\n                // do not use a ulp/epsilon check\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n            // there's a degeneracy as indicated by a tie in the minimum ratio test\n\n            // 1. check if there's an artificial variable that can be forced out of the basis\n                for (Integer row : minRatioPositions) {\n                    for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n                        int column = i + tableau.getArtificialVariableOffset();\n                        final double entry = tableau.getEntry(row, column);\n                        if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n                            return row;\n                        }\n                    }\n                }\n\n            // 2. apply Bland's rule to prevent cycling:\n            //    take the row for which the corresponding basic variable has the smallest index\n            //\n            // see http://www.stanford.edu/class/msande310/blandrule.pdf\n            // see http://en.wikipedia.org/wiki/Bland%27s_rule (not equivalent to the above paper)\n            //\n            // Additional heuristic: if we did not get a solution after half of maxIterations\n            //                       revert to the simple case of just returning the top-most row\n            // This heuristic is based on empirical data gathered while investigating MATH-828.\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }",
                "PatCode": "private Integer getPivotRow(SimplexTableau tableau, final int col) {\n        List<Integer> minRatioPositions = new ArrayList<Integer>();\n        double minRatio = Double.MAX_VALUE;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n                final double ratio = rhs / entry;\n                final int cmp = Double.compare(ratio, minRatio);\n                if (cmp == 0) {\n                    minRatioPositions.add(i);\n                } else if (cmp < 0) {\n                    minRatio = ratio;\n                    minRatioPositions = new ArrayList<Integer>();\n                    minRatioPositions.add(i);\n                }\n            }\n        }\n        if (minRatioPositions.size() == 0) {\n            return null;\n        } else if (minRatioPositions.size() > 1) {\n// buggy code\n//                 for (Integer row : minRatioPositions) {\n//                     for (int i = 0; i < tableau.getNumArtificialVariables(); i++) {\n//                         int column = i + tableau.getArtificialVariableOffset();\n//                         final double entry = tableau.getEntry(row, column);\n//                         if (Precision.equals(entry, 1d, maxUlps) && row.equals(tableau.getBasicRow(column))) {\n//                             return row;\n//                         }\n//                     }\n//                 }\n//                 Integer minRow = null;\n//                 int minIndex = tableau.getWidth();\n//                 for (Integer row : minRatioPositions) {\n//                     int i = tableau.getNumObjectiveFunctions();\n//                     for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n//                         if (row == tableau.getBasicRow(i)) {\n//                             if (i < minIndex) {\n//                                 minIndex = i;\n//                                 minRow = row;\n//                             }\n//                         }\n//                     }\n//                 }\n//                 return minRow;\n                Integer minRow = null;\n                int minIndex = tableau.getWidth();\n                for (Integer row : minRatioPositions) {\n                    int i = tableau.getNumObjectiveFunctions();\n                    for (; i < tableau.getWidth() - 1 && minRow != row; i++) {\n                        if (row == tableau.getBasicRow(i)) {\n                            if (i < minIndex) {\n                                minIndex = i;\n                                minRow = row;\n                            }\n                        }\n                    }\n                }\n                return minRow;\n        }\n        return minRatioPositions.get(0);\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_59_repairllama-ir4_patch_6.diff",
        "BugId": "Lang_59",
        "PatchedMethods": [
            {
                "DevIntention": "append|fixed|width|pad|right",
                "OrgCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n                str.getChars(0, strLen, buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }",
                "PatCode": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n        if (width > 0) {\n            ensureCapacity(size + width);\n            String str = (obj == null ? getNullText() : obj.toString());\n            int strLen = str.length();\n            if (strLen >= width) {\n// buggy code\n//                 str.getChars(0, strLen, buffer, size);\n               str.getChars(0, Math.min(strLen, width), buffer, size);\n            } else {\n                int padLen = width - strLen;\n                str.getChars(0, strLen, buffer, size);\n                for (int i = 0; i < padLen; i++) {\n                    buffer[size + strLen + i] = padChar;\n                }\n            }\n            size += width;\n        }\n        return this;\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_33_repairllama-ir4_patch_4.diff",
        "BugId": "Lang_33",
        "PatchedMethods": [
            {
                "DevIntention": "to|class",
                "OrgCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }",
                "PatCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n// buggy code\n//             classes[i] = array[i].getClass();\n           Object object = array[i];\n            if (object != null) {\n            classes[i] = array[i].getClass();\n        }\n        }\n        return classes;\n    }"
            }
        ]
    },
    {
        "PatchId": "Closure_86_repairllama-ir4_patch_8.diff",
        "BugId": "Closure_86",
        "PatchedMethods": [
            {
                "DevIntention": "evaluates|to|local|value",
                "OrgCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n        return true;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }",
                "PatCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n// buggy code\n//         return true;\n       return NodeUtil.isImmutableValue(value.getFirstChild());\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return true;\n      case Token.IN:\n        return true;\n      default:\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }"
            }
        ]
    },
    {
        "PatchId": "Closure_10_repairllama-ir4_patch_8.diff",
        "BugId": "Closure_10",
        "PatchedMethods": [
            {
                "DevIntention": "may|be|string",
                "OrgCode": "static boolean mayBeString(Node n, boolean recurse) {\n    if (recurse) {\n      return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    } else {\n      return mayBeStringHelper(n);\n    }\n  }",
                "PatCode": "static boolean mayBeString(Node n, boolean recurse) {\n    if (recurse) {\n// buggy code\n//       return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n     return mayBeStringHelper(n);\n    } else {\n      return mayBeStringHelper(n);\n    }\n  }"
            }
        ]
    },
    {
        "PatchId": "Chart_12_repairllama-ir4_patch_1.diff",
        "BugId": "Chart_12",
        "PatchedMethods": [
            {
                "DevIntention": "multiple|pie|plot",
                "OrgCode": "public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n        this.dataset = dataset;\n        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }",
                "PatCode": "public MultiplePiePlot(CategoryDataset dataset) {\n        super();\n// buggy code\n//         this.dataset = dataset;\n       this.setDataset(dataset);\n        PiePlot piePlot = new PiePlot(null);\n        this.pieChart = new JFreeChart(piePlot);\n        this.pieChart.removeLegend();\n        this.dataExtractOrder = TableOrder.BY_COLUMN;\n        this.pieChart.setBackgroundPaint(null);\n        TextTitle seriesTitle = new TextTitle(\"Series Title\",\n                new Font(\"SansSerif\", Font.BOLD, 12));\n        seriesTitle.setPosition(RectangleEdge.BOTTOM);\n        this.pieChart.setTitle(seriesTitle);\n        this.aggregatedItemsKey = \"Other\";\n        this.aggregatedItemsPaint = Color.lightGray;\n        this.sectionPaints = new HashMap();\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_43_repairllama-ir4_patch_5.diff",
        "BugId": "Lang_43",
        "PatchedMethods": [
            {
                "DevIntention": "append|quoted|string",
                "OrgCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }",
                "PatCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n// buggy code\n// \n           pos.setIndex(pos.getIndex()+1);\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }"
            }
        ]
    },
    {
        "PatchId": "Time_7_repairllama-ir4_patch_9.diff",
        "BugId": "Time_7",
        "PatchedMethods": [
            {
                "DevIntention": "parse|into",
                "OrgCode": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        int defaultYear = chrono.year().get(instantLocal);\n        \n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }",
                "PatCode": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n// buggy code\n//         long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n//         chrono = selectChronology(chrono);\n//         int defaultYear = chrono.year().get(instantLocal);\n       long instantLocal = instantMillis;\n        if (chrono.getZone() != null) {\n            instantLocal += chrono.getZone().getOffset(instantMillis);\n        }\n        chrono = selectChronology(chrono);\n        int defaultYear = chrono.year().get(instantMillis);\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(false, text));\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n        instant.setChronology(chrono);\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n        return newPos;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_11_repairllama-ir4_patch_9.diff",
        "BugId": "Math_11",
        "PatchedMethods": [
            {
                "DevIntention": "density",
                "OrgCode": "public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n\n        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }",
                "PatCode": "public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n// buggy code\n//         return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n       return FastMath.pow(2.0 * FastMath.PI, -dim / 2.0) *\n            FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n            getExponentTerm(vals);\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_85_repairllama-ir4_patch_7.diff",
        "BugId": "Math_85",
        "PatchedMethods": [
            {
                "DevIntention": "bracket",
                "OrgCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }",
                "PatCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n// buggy code\n//         if (fa * fb >= 0.0 ) {\n       if ((fa * fb >= 0.0) && (numIterations >= maximumIterations)) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        return new double[]{a, b};\n    }\n\n    /**\n     * Compute the midpoint of two values.\n     * \n     * @param a first value.\n     * @param b second value.\n     * @return the midpoint. \n     */\n    public static double midpoint(double a, double b) {\n        return (a + b) * .5;\n    }\n    \n    /**\n     * Checks to see if f is null, throwing IllegalArgumentException if so.\n     * @param f  input function\n     * @throws IllegalArgumentException if f is null\n     */\n    private static void setup(UnivariateRealFunction f) {\n        if (f == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n    }\n\n    /** Holder for the factory.\n     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n     */\n    private static class LazyHolder {\n        /** Cached solver factory */\n        private static final UnivariateRealSolverFactory FACTORY =\n            UnivariateRealSolverFactory.newInstance();\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Lang_33_repairllama-ir4_patch_8.diff",
        "BugId": "Lang_33",
        "PatchedMethods": [
            {
                "DevIntention": "to|class",
                "OrgCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }",
                "PatCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n// buggy code\n//             classes[i] = array[i].getClass();\n           Object object = array[i];\n            classes[i] = (object != null ? object.getClass() : null);\n        }\n        return classes;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_101_repairllama-ir4_patch_4.diff",
        "BugId": "Math_101",
        "PatchedMethods": [
            {
                "DevIntention": "parse",
                "OrgCode": "public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse real\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            // invalid real number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse sign\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse imaginary\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            // invalid imaginary number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse imaginary character\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if (\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            // set index back to initial, error index should be the start index\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }",
                "PatCode": "public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n        parseAndIgnoreWhitespace(source, pos);\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        parseAndIgnoreWhitespace(source, pos);\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n// buggy code\n//         if (\n       if (endIndex > source.length() || \n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }"
            }
        ]
    },
    {
        "PatchId": "Closure_86_repairllama-ir4_patch_4.diff",
        "BugId": "Closure_86",
        "PatchedMethods": [
            {
                "DevIntention": "evaluates|to|local|value",
                "OrgCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n        return true;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }",
                "PatCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n// buggy code\n//         return true;\n       return evaluatesToLocalValue(value.getFirstChild(), locals);\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return true;\n      case Token.IN:\n        return true;\n      default:\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }"
            }
        ]
    },
    {
        "PatchId": "Closure_86_repairllama-ir4_patch_5.diff",
        "BugId": "Closure_86",
        "PatchedMethods": [
            {
                "DevIntention": "evaluates|to|local|value",
                "OrgCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n        return true;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }",
                "PatCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n// buggy code\n//         return true;\n       return isImmutableValue(value);\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return true;\n      case Token.IN:\n        return true;\n      default:\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }"
            }
        ]
    },
    {
        "PatchId": "Lang_33_repairllama-ir4_patch_9.diff",
        "BugId": "Lang_33",
        "PatchedMethods": [
            {
                "DevIntention": "to|class",
                "OrgCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }",
                "PatCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n// buggy code\n//             classes[i] = array[i].getClass();\n           if (array[i] != null) {\n            classes[i] = array[i].getClass();\n        }\n        }\n        return classes;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_85_repairllama-ir4_patch_6.diff",
        "BugId": "Math_85",
        "PatchedMethods": [
            {
                "DevIntention": "bracket",
                "OrgCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        \n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n    \n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            \n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n   \n        if (fa * fb >= 0.0 ) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        \n        return new double[]{a, b};\n    }",
                "PatCode": "public static double[] bracket(UnivariateRealFunction function,\n            double initial, double lowerBound, double upperBound, \n            int maximumIterations) throws ConvergenceException, \n            FunctionEvaluationException {\n        if (function == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n        if (maximumIterations <= 0)  {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"bad value for maximum iterations number: {0}\", maximumIterations);\n        }\n        if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n                  lowerBound, initial, upperBound);\n        }\n        double a = initial;\n        double b = initial;\n        double fa;\n        double fb;\n        int numIterations = 0 ;\n        do {\n            a = Math.max(a - 1.0, lowerBound);\n            b = Math.min(b + 1.0, upperBound);\n            fa = function.value(a);\n            fb = function.value(b);\n            numIterations++ ;\n        } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n                ((a > lowerBound) || (b < upperBound)));\n// buggy code\n//         if (fa * fb >= 0.0 ) {\n       if (fa * fb >= 0.0 && numIterations == maximumIterations) {\n            throw new ConvergenceException(\n                      \"number of iterations={0}, maximum iterations={1}, \" +\n                      \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" +\n                      \"final b value={6}, f(a)={7}, f(b)={8}\",\n                      numIterations, maximumIterations, initial,\n                      lowerBound, upperBound, a, b, fa, fb);\n        }\n        return new double[]{a, b};\n    }\n\n    /**\n     * Compute the midpoint of two values.\n     * \n     * @param a first value.\n     * @param b second value.\n     * @return the midpoint. \n     */\n    public static double midpoint(double a, double b) {\n        return (a + b) * .5;\n    }\n    \n    /**\n     * Checks to see if f is null, throwing IllegalArgumentException if so.\n     * @param f  input function\n     * @throws IllegalArgumentException if f is null\n     */\n    private static void setup(UnivariateRealFunction f) {\n        if (f == null) {\n            throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n        }\n    }\n\n    /** Holder for the factory.\n     * <p>We use here the Initialization On Demand Holder Idiom.</p>\n     */\n    private static class LazyHolder {\n        /** Cached solver factory */\n        private static final UnivariateRealSolverFactory FACTORY =\n            UnivariateRealSolverFactory.newInstance();\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Chart_13_repairllama-ir4_patch_3.diff",
        "BugId": "Chart_13",
        "PatchedMethods": [
            {
                "DevIntention": "arrange|f|f",
                "OrgCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth() - w[2]),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }",
                "PatCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy code\n//                     new Range(0.0, constraint.getWidth() - w[2]),\n                   new Range(0.0, constraint.getWidth() - w[0]),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_43_repairllama-ir4_patch_4.diff",
        "BugId": "Lang_43",
        "PatchedMethods": [
            {
                "DevIntention": "append|quoted|string",
                "OrgCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }",
                "PatCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n// buggy code\n// \n           pos.setIndex(start+1);\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_50_repairllama-ir4_patch_5.diff",
        "BugId": "Math_50",
        "PatchedMethods": [
            {
                "DevIntention": "do|solve",
                "OrgCode": "protected final double doSolve() {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n\n        // Verify bracketing of initial solution.\n        verifyBracketing(x0, x1);\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (true) {\n            // Calculate the next approximation.\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n\n            // If the new approximation is the exact root, return it. Since\n            // this is not an under-approximation or an over-approximation,\n            // we can return it regardless of the allowed solutions.\n            if (fx == 0.0) {\n                return x;\n            }\n\n            // Update the bounds with the new approximation.\n            if (f1 * fx < 0) {\n                // The value of x1 has switched to the other bound, thus inverting\n                // the interval.\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n                    // Nothing.\n                    if (x == x1) {\n                        x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                        f0 = computeObjectiveValue(x0);\n                    }\n                    break;\n                default:\n                    // Should never happen.\n                    throw new MathInternalError();\n                }\n            }\n            // Update from [x0, x1] to [x0, x].\n            x1 = x;\n            f1 = fx;\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }",
                "PatCode": "protected final double doSolve() {\n        double x0 = getMin();\n        double x1 = getMax();\n        double f0 = computeObjectiveValue(x0);\n        double f1 = computeObjectiveValue(x1);\n        if (f0 == 0.0) {\n            return x0;\n        }\n        if (f1 == 0.0) {\n            return x1;\n        }\n        verifyBracketing(x0, x1);\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n        boolean inverted = false;\n        while (true) {\n            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n            final double fx = computeObjectiveValue(x);\n            if (fx == 0.0) {\n                return x;\n            }\n            if (f1 * fx < 0) {\n                x0 = x1;\n                f0 = f1;\n                inverted = !inverted;\n            } else {\n                switch (method) {\n                case ILLINOIS:\n                    f0 *= 0.5;\n                    break;\n                case PEGASUS:\n                    f0 *= f1 / (f1 + fx);\n                    break;\n                case REGULA_FALSI:\n// buggy code\n//                     if (x == x1) {\n//                         x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n//                         f0 = computeObjectiveValue(x0);\n//                     }\n                   if (x == x0) {\n                        x1 = 0.5 * (x0 + x1 + FastMath.max(rtol * FastMath.abs(x0), atol));\n                        f1 = computeObjectiveValue(x1);\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n            x1 = x;\n            f1 = fx;\n            if (FastMath.abs(f1) <= ftol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    if (inverted) {\n                        return x1;\n                    }\n                    break;\n                case RIGHT_SIDE:\n                    if (!inverted) {\n                        return x1;\n                    }\n                    break;\n                case BELOW_SIDE:\n                    if (f1 <= 0) {\n                        return x1;\n                    }\n                    break;\n                case ABOVE_SIDE:\n                    if (f1 >= 0) {\n                        return x1;\n                    }\n                    break;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n                                                     atol)) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return x1;\n                case LEFT_SIDE:\n                    return inverted ? x1 : x0;\n                case RIGHT_SIDE:\n                    return inverted ? x0 : x1;\n                case BELOW_SIDE:\n                    return (f1 <= 0) ? x1 : x0;\n                case ABOVE_SIDE:\n                    return (f1 >= 0) ? x1 : x0;\n                default:\n                    throw new MathInternalError();\n                }\n            }\n        }\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_57_repairllama-ir4_patch_1.diff",
        "BugId": "Math_57",
        "PatchedMethods": [
            {
                "DevIntention": "choose|initial|centers",
                "OrgCode": "private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n\n        // Choose one center uniformly at random from among the data points.\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n\n        final double[] dx2 = new double[pointSet.size()];\n        while (resultSet.size() < k) {\n            // For each data point x, compute D(x), the distance between x and\n            // the nearest center that has already been chosen.\n            int sum = 0;\n            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n\n            // Add one new data point as a center. Each point x is chosen with\n            // probability proportional to D(x)2\n            final double r = random.nextDouble() * sum;\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    break;\n                }\n            }\n        }\n\n        return resultSet;\n\n    }",
                "PatCode": "private static <T extends Clusterable<T>> List<Cluster<T>>\n        chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n        final List<T> pointSet = new ArrayList<T>(points);\n        final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n        final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n        resultSet.add(new Cluster<T>(firstPoint));\n        final double[] dx2 = new double[pointSet.size()];\n        while (resultSet.size() < k) {\n// buggy code\n//             int sum = 0;\n           double sum = 0.0;\n            for (int i = 0; i < pointSet.size(); i++) {\n                final T p = pointSet.get(i);\n                final Cluster<T> nearest = getNearestCluster(resultSet, p);\n                final double d = p.distanceFrom(nearest.getCenter());\n                sum += d * d;\n                dx2[i] = sum;\n            }\n            final double r = random.nextDouble() * sum;\n            for (int i = 0 ; i < dx2.length; i++) {\n                if (dx2[i] >= r) {\n                    final T p = pointSet.remove(i);\n                    resultSet.add(new Cluster<T>(p));\n                    break;\n                }\n            }\n        }\n        return resultSet;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_59_repairllama-ir4_patch_1.diff",
        "BugId": "Math_59",
        "PatchedMethods": [
            {
                "DevIntention": "max",
                "OrgCode": "public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n    }",
                "PatCode": "public static float max(final float a, final float b) {\n// buggy code\n//         return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n       return (a >= b) ? a : (Float.isNaN(a + b) ? Float.NaN : b);\n    }"
            }
        ]
    },
    {
        "PatchId": "Closure_86_repairllama-ir4_patch_9.diff",
        "BugId": "Closure_86",
        "PatchedMethods": [
            {
                "DevIntention": "evaluates|to|local|value",
                "OrgCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        // A result that is aliased by a non-local name, is the effectively the\n        // same as returning a non-local name, but this doesn't matter if the\n        // value is immutable.\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        // There is no information about the locality of object properties.\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n        // TODO(nicksantos): This needs to be changed so that it\n        // returns true iff we're sure the value was never aliased from inside\n        // the constructor (similar to callHasLocalResult)\n        return true;\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        // Literals objects with non-literal children are allowed.\n        return true;\n      case Token.IN:\n        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n        return true;\n      default:\n        // Other op force a local value:\n        //  x = '' + g (x is now an local string)\n        //  x -= g (x is now an local number)\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }",
                "PatCode": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n    switch (value.getType()) {\n      case Token.ASSIGN:\n        return NodeUtil.isImmutableValue(value.getLastChild())\n            || (locals.apply(value)\n                && evaluatesToLocalValue(value.getLastChild(), locals));\n      case Token.COMMA:\n        return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.AND:\n      case Token.OR:\n        return evaluatesToLocalValue(value.getFirstChild(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.HOOK:\n        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n           && evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.INC:\n      case Token.DEC:\n        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n          return evaluatesToLocalValue(value.getFirstChild(), locals);\n        } else {\n          return true;\n        }\n      case Token.THIS:\n        return locals.apply(value);\n      case Token.NAME:\n        return isImmutableValue(value) || locals.apply(value);\n      case Token.GETELEM:\n      case Token.GETPROP:\n        return locals.apply(value);\n      case Token.CALL:\n        return callHasLocalResult(value)\n            || isToStringMethodCall(value)\n            || locals.apply(value);\n      case Token.NEW:\n// buggy code\n//         return true;\n       return evaluatesToLocalValue(value.getLastChild(), locals);\n      case Token.FUNCTION:\n      case Token.REGEXP:\n      case Token.ARRAYLIT:\n      case Token.OBJECTLIT:\n        return true;\n      case Token.IN:\n        return true;\n      default:\n        if (isAssignmentOp(value)\n            || isSimpleOperator(value)\n            || isImmutableValue(value)) {\n          return true;\n        }\n        throw new IllegalStateException(\n            \"Unexpected expression node\" + value +\n            \"\\n parent:\" + value.getParent());\n    }\n  }"
            }
        ]
    },
    {
        "PatchId": "Lang_33_repairllama-ir4_patch_5.diff",
        "BugId": "Lang_33",
        "PatchedMethods": [
            {
                "DevIntention": "to|class",
                "OrgCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }",
                "PatCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n// buggy code\n//             classes[i] = array[i].getClass();\n           classes[i] = (array[i] != null ? array[i].getClass() : null);\n        }\n        return classes;\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_51_repairllama-ir4_patch_0.diff",
        "BugId": "Lang_51",
        "PatchedMethods": [
            {
                "DevIntention": "to|boolean",
                "OrgCode": "public static boolean toBoolean(String str) {\n        // Previously used equalsIgnoreCase, which was fast for interned 'true'.\n        // Non interned 'true' matched 15 times slower.\n        // \n        // Optimisation provides same performance as before for interned 'true'.\n        // Similar performance for null, 'false', and other strings not length 2/3/4.\n        // 'true'/'TRUE' match 4 times slower, 'tRUE'/'True' 7 times slower.\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }",
                "PatCode": "public static boolean toBoolean(String str) {\n        if (str == \"true\") {\n            return true;\n        }\n        if (str == null) {\n            return false;\n        }\n        switch (str.length()) {\n            case 2: {\n                char ch0 = str.charAt(0);\n                char ch1 = str.charAt(1);\n                return \n                    (ch0 == 'o' || ch0 == 'O') &&\n                    (ch1 == 'n' || ch1 == 'N');\n            }\n            case 3: {\n                char ch = str.charAt(0);\n                if (ch == 'y') {\n                    return \n                        (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                        (str.charAt(2) == 's' || str.charAt(2) == 'S');\n                }\n                if (ch == 'Y') {\n                    return \n                        (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                        (str.charAt(2) == 'S' || str.charAt(2) == 's');\n                }\n// buggy code\n// \n               break;\n            }\n            case 4: {\n                char ch = str.charAt(0);\n                if (ch == 't') {\n                    return \n                        (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                        (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                        (str.charAt(3) == 'e' || str.charAt(3) == 'E');\n                }\n                if (ch == 'T') {\n                    return \n                        (str.charAt(1) == 'R' || str.charAt(1) == 'r') &&\n                        (str.charAt(2) == 'U' || str.charAt(2) == 'u') &&\n                        (str.charAt(3) == 'E' || str.charAt(3) == 'e');\n                }\n            }\n        }\n        return false;\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_9_repairllama-ir4_patch_0.diff",
        "BugId": "Chart_9",
        "PatchedMethods": [
            {
                "DevIntention": "create|copy",
                "OrgCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  // start is after last data item\n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {             // end period is not in original series\n            endIndex = -(endIndex + 1); // this is first item AFTER end period\n            endIndex = endIndex - 1;    // so this is last item BEFORE end\n        }\n        if (endIndex < 0) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n\n    }",
                "PatCode": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n        throws CloneNotSupportedException {\n        if (start == null) {\n            throw new IllegalArgumentException(\"Null 'start' argument.\");\n        }\n        if (end == null) {\n            throw new IllegalArgumentException(\"Null 'end' argument.\");\n        }\n        if (start.compareTo(end) > 0) {\n            throw new IllegalArgumentException(\n                    \"Requires start on or before end.\");\n        }\n        boolean emptyRange = false;\n        int startIndex = getIndex(start);\n        if (startIndex < 0) {\n            startIndex = -(startIndex + 1);\n            if (startIndex == this.data.size()) {\n                emptyRange = true;  \n            }\n        }\n        int endIndex = getIndex(end);\n        if (endIndex < 0) {\n            endIndex = -(endIndex + 1); \n            endIndex = endIndex - 1;    \n        }\n// buggy code\n//         if (endIndex < 0) {\n       if (endIndex < startIndex) {\n            emptyRange = true;\n        }\n        if (emptyRange) {\n            TimeSeries copy = (TimeSeries) super.clone();\n            copy.data = new java.util.ArrayList();\n            return copy;\n        }\n        else {\n            return createCopy(startIndex, endIndex);\n        }\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param object  the object to test against (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object object) {\n        if (object == this) {\n            return true;\n        }\n        if (!(object instanceof TimeSeries) || !super.equals(object)) {\n            return false;\n        }\n        TimeSeries s = (TimeSeries) object;\n        if (!ObjectUtilities.equal(getDomainDescription(),\n                s.getDomainDescription())) {\n            return false;\n        }\n\n        if (!ObjectUtilities.equal(getRangeDescription(),\n                s.getRangeDescription())) {\n            return false;\n        }\n\n        if (!getClass().equals(s.getClass())) {\n            return false;\n        }\n\n        if (getMaximumItemAge() != s.getMaximumItemAge()) {\n            return false;\n        }\n\n        if (getMaximumItemCount() != s.getMaximumItemCount()) {\n            return false;\n        }\n\n        int count = getItemCount();\n        if (count != s.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!getDataItem(i).equals(s.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code value for the object.\n     *\n     * @return The hashcode\n     */\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 29 * result + (this.domain != null ? this.domain.hashCode()\n                : 0);\n        result = 29 * result + (this.range != null ? this.range.hashCode() : 0);\n        result = 29 * result + (this.timePeriodClass != null\n                ? this.timePeriodClass.hashCode() : 0);\n        // it is too slow to look at every data item, so let's just look at\n        // the first, middle and last items...\n        int count = getItemCount();\n        if (count > 0) {\n            TimeSeriesDataItem item = getDataItem(0);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 1) {\n            TimeSeriesDataItem item = getDataItem(count - 1);\n            result = 29 * result + item.hashCode();\n        }\n        if (count > 2) {\n            TimeSeriesDataItem item = getDataItem(count / 2);\n            result = 29 * result + item.hashCode();\n        }\n        result = 29 * result + this.maximumItemCount;\n        result = 29 * result + (int) this.maximumItemAge;\n        return result;\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Chart_1_repairllama-ir4_patch_7.diff",
        "BugId": "Chart_1",
        "PatchedMethods": [
            {
                "DevIntention": "get|legend|items",
                "OrgCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset != null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }",
                "PatCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n// buggy code\n//         if (dataset != null) {\n       if (dataset == null || !isSeriesVisibleInLegend(index)) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Adds an entity with the specified hotspot.\n     *\n     * @param entities  the entity collection.\n     * @param hotspot  the hotspot (<code>null</code> not permitted).\n     * @param dataset  the dataset.\n     * @param row  the row index.\n     * @param column  the column index.\n     * @param selected  is the item selected?\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected) {\n\n        if (hotspot == null) {\n            throw new IllegalArgumentException(\"Null 'hotspot' argument.\");\n        }\n        addEntity(entities, hotspot, dataset, row, column, selected, 0.0, 0.0);\n    }\n\n    /**\n     * Adds an entity to the collection.\n     *\n     * @param entities  the entity collection being populated.\n     * @param hotspot  the entity area (if <code>null</code> a default will be\n     *              used).\n     * @param dataset  the dataset.\n     * @param row  the series.\n     * @param column  the item.\n     * @param selected  is the item selected?\n     * @param entityX  the entity's center x-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     * @param entityY  the entity's center y-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            double entityX, double entityY) {\n        if (!getItemCreateEntity(row, column, selected)) {\n            return;\n        }\n        Shape s = hotspot;\n        if (hotspot == null) {\n            double r = getDefaultEntityRadius();\n            double w = r * 2;\n            if (getPlot().getOrientation() == PlotOrientation.VERTICAL) {\n                s = new Ellipse2D.Double(entityX - r, entityY - r, w, w);\n            }\n            else {\n                s = new Ellipse2D.Double(entityY - r, entityX - r, w, w);\n            }\n        }\n        String tip = null;\n        CategoryToolTipGenerator generator = getToolTipGenerator(row, column,\n                selected);\n        if (generator != null) {\n            tip = generator.generateToolTip(dataset, row, column);\n        }\n        String url = null;\n        CategoryURLGenerator urlster = getURLGenerator(row, column, selected);\n        if (urlster != null) {\n            url = urlster.generateURL(dataset, row, column);\n        }\n        CategoryItemEntity entity = new CategoryItemEntity(s, tip, url,\n                dataset, dataset.getRowKey(row), dataset.getColumnKey(column));\n        entities.add(entity);\n    }\n\n        /**\n     * Returns a shape that can be used for hit testing on a data item drawn\n     * by the renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area within which the data is being rendered.\n     * @param plot  the plot (can be used to obtain standard color\n     *              information etc).\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the dataset.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param selected  is the item selected?\n     *\n     * @return A shape equal to the hot spot for a data item.\n     */\n    public Shape createHotSpotShape(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state) {\n        throw new RuntimeException(\"Not implemented.\");\n    }\n\n    /**\n     * Returns the rectangular bounds for the hot spot for an item drawn by\n     * this renderer.  This is intended to provide a quick test for\n     * eliminating data points before more accurate testing against the\n     * shape returned by createHotSpotShape().\n     *\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     * @param result\n     * @return\n     */\n    public Rectangle2D createHotSpotBounds(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state, Rectangle2D result) {\n        if (result == null) {\n            result = new Rectangle();\n        }\n        Comparable key = dataset.getColumnKey(column);\n        Number y = dataset.getValue(row, column);\n        if (y == null) {\n            return null;\n        }\n        double xx = domainAxis.getCategoryMiddle(key,\n                plot.getCategoriesForAxis(domainAxis),\n                dataArea, plot.getDomainAxisEdge());\n        double yy = rangeAxis.valueToJava2D(y.doubleValue(), dataArea,\n                plot.getRangeAxisEdge());\n        result.setRect(xx - 2, yy - 2, 4, 4);\n        return result;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified point (xx, yy) in Java2D\n     * space falls within the \"hot spot\" for the specified data item, and\n     * <code>false</code> otherwise.\n     *\n     * @param xx\n     * @param yy\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     *\n     * @return\n     *\n     * @since 1.2.0\n     */\n    public boolean hitTest(double xx, double yy, Graphics2D g2,\n            Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,\n            ValueAxis rangeAxis, CategoryDataset dataset, int row, int column,\n            boolean selected, CategoryItemRendererState state) {\n        Rectangle2D bounds = createHotSpotBounds(g2, dataArea, plot,\n                domainAxis, rangeAxis, dataset, row, column, selected,\n                state, null);\n        if (bounds == null) {\n            return false;\n        }\n        // FIXME:  if the following test passes, we should then do the more\n        // expensive test against the hotSpotShape\n        return bounds.contains(xx, yy);\n    }\n    \n}"
            }
        ]
    },
    {
        "PatchId": "Closure_73_repairllama-ir4_patch_3.diff",
        "BugId": "Closure_73",
        "PatchedMethods": [
            {
                "DevIntention": "str|escape",
                "OrgCode": "static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n\n  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // Identifiers should always go to Latin1/ ASCII characters because\n      // different browser's rules for valid identifier characters are\n      // crazy.\n      if (c > 0x1F && c < 0x7F) {\n        sb.append(c);\n      } else {\n        appendHexJavaScriptRepresentation(sb, c);\n      }\n    }\n    return sb.toString();\n  }",
                "PatCode": "static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       \n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          final String END_SCRIPT = \"/script\";\n          final String START_COMMENT = \"!--\";\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n// buggy code\n//             if (c > 0x1f && c <= 0x7f) {\n           if (c > 0x1f && c <= 0x7e) {\n              sb.append(c);\n            } else {\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n\n  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // Identifiers should always go to Latin1/ ASCII characters because\n      // different browser's rules for valid identifier characters are\n      // crazy.\n      if (c > 0x1F && c < 0x7F) {\n        sb.append(c);\n      } else {\n        appendHexJavaScriptRepresentation(sb, c);\n      }\n    }\n    return sb.toString();\n  }"
            }
        ]
    },
    {
        "PatchId": "Math_34_repairllama-ir4_patch_0.diff",
        "BugId": "Math_34",
        "PatchedMethods": [
            {
                "DevIntention": "iterator",
                "OrgCode": "public Iterator<Chromosome> iterator() {\n        return chromosomes.iterator();\n    }",
                "PatCode": "public Iterator<Chromosome> iterator() {\n// buggy code\n//         return chromosomes.iterator();\n       return Collections.unmodifiableCollection(chromosomes).iterator();\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_32_repairllama-ir4_patch_7.diff",
        "BugId": "Math_32",
        "PatchedMethods": [
            {
                "DevIntention": "compute|geometrical|properties",
                "OrgCode": "protected void computeGeometricalProperties() {\n\n        final Vector2D[][] v = getVertices();\n\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n            if ((Boolean) tree.getAttribute()) {\n                // the instance covers the whole space\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            // there is at least one open-loop: the polygon is infinite\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            // all loops are closed, we compute some integrals around the shape\n\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n\n            if (sum < 0) {\n                // the polygon as a finite outside surrounded by an infinite inside\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n\n        }\n\n    }",
                "PatCode": "protected void computeGeometricalProperties() {\n        final Vector2D[][] v = getVertices();\n        if (v.length == 0) {\n            final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy code\n//             if ((Boolean) tree.getAttribute()) {\n           if (tree.getAttribute() == Boolean.TRUE) {\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(0);\n                setBarycenter(new Vector2D(0, 0));\n            }\n        } else if (v[0][0] == null) {\n            setSize(Double.POSITIVE_INFINITY);\n            setBarycenter(Vector2D.NaN);\n        } else {\n            double sum  = 0;\n            double sumX = 0;\n            double sumY = 0;\n            for (Vector2D[] loop : v) {\n                double x1 = loop[loop.length - 1].getX();\n                double y1 = loop[loop.length - 1].getY();\n                for (final Vector2D point : loop) {\n                    final double x0 = x1;\n                    final double y0 = y1;\n                    x1 = point.getX();\n                    y1 = point.getY();\n                    final double factor = x0 * y1 - y0 * x1;\n                    sum  += factor;\n                    sumX += factor * (x0 + x1);\n                    sumY += factor * (y0 + y1);\n                }\n            }\n            if (sum < 0) {\n                setSize(Double.POSITIVE_INFINITY);\n                setBarycenter(Vector2D.NaN);\n            } else {\n                setSize(sum / 2);\n                setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum)));\n            }\n        }\n    }\n\n    /** Get the vertices of the polygon.\n     * <p>The polygon boundary can be represented as an array of loops,\n     * each loop being itself an array of vertices.</p>\n     * <p>In order to identify open loops which start and end by\n     * infinite edges, the open loops arrays start with a null point. In\n     * this case, the first non null point and the last point of the\n     * array do not represent real vertices, they are dummy points\n     * intended only to get the direction of the first and last edge. An\n     * open loop consisting of a single infinite line will therefore be\n     * represented by a three elements array with one null point\n     * followed by two dummy points. The open loops are always the first\n     * ones in the loops array.</p>\n     * <p>If the polygon has no boundary at all, a zero length loop\n     * array will be returned.</p>\n     * <p>All line segments in the various loops have the inside of the\n     * region on their left side and the outside on their right side\n     * when moving in the underlying line direction. This means that\n     * closed loops surrounding finite areas obey the direct\n     * trigonometric orientation.</p>\n     * @return vertices of the polygon, organized as oriented boundary\n     * loops with the open loops first (the returned value is guaranteed\n     * to be non-null)\n     */\n    public Vector2D[][] getVertices() {\n        if (vertices == null) {\n            if (getTree(false).getCut() == null) {\n                vertices = new Vector2D[0][];\n            } else {\n\n                // sort the segments according to their start point\n                final SegmentsBuilder visitor = new SegmentsBuilder();\n                getTree(true).visit(visitor);\n                final AVLTree<ComparableSegment> sorted = visitor.getSorted();\n\n                // identify the loops, starting from the open ones\n                // (their start segments are naturally at the sorted set beginning)\n                final ArrayList<List<ComparableSegment>> loops = new ArrayList<List<ComparableSegment>>();\n                while (!sorted.isEmpty()) {\n                    final AVLTree<ComparableSegment>.Node node = sorted.getSmallest();\n                    final List<ComparableSegment> loop = followLoop(node, sorted);\n                    if (loop != null) {\n                        loops.add(loop);\n                    }\n                }\n\n                // tranform the loops in an array of arrays of points\n                vertices = new Vector2D[loops.size()][];\n                int i = 0;\n\n                for (final List<ComparableSegment> loop : loops) {\n                    if (loop.size() < 2) {\n                        // single infinite line\n                        final Line line = loop.get(0).getLine();\n                        vertices[i++] = new Vector2D[] {\n                            null,\n                            line.toSpace(new Vector1D(-Float.MAX_VALUE)),\n                            line.toSpace(new Vector1D(+Float.MAX_VALUE))\n                        };\n                    } else if (loop.get(0).getStart() == null) {\n                        // open loop with at least one real point\n                        final Vector2D[] array = new Vector2D[loop.size() + 2];\n                        int j = 0;\n                        for (Segment segment : loop) {\n\n                            if (j == 0) {\n                                // null point and first dummy point\n                                double x = segment.getLine().toSubSpace(segment.getEnd()).getX();\n                                x -= FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = null;\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                            if (j < (array.length - 1)) {\n                                // current point\n                                array[j++] = segment.getEnd();\n                            }\n\n                            if (j == (array.length - 1)) {\n                                // last dummy point\n                                double x = segment.getLine().toSubSpace(segment.getStart()).getX();\n                                x += FastMath.max(1.0, FastMath.abs(x / 2));\n                                array[j++] = segment.getLine().toSpace(new Vector1D(x));\n                            }\n\n                        }\n                        vertices[i++] = array;\n                    } else {\n                        final Vector2D[] array = new Vector2D[loop.size()];\n                        int j = 0;\n                        for (Segment segment : loop) {\n                            array[j++] = segment.getStart();\n                        }\n                        vertices[i++] = array;\n                    }\n                }\n\n            }\n        }\n\n        return vertices.clone();\n\n    }\n\n    /** Follow a boundary loop.\n     * @param node node containing the segment starting the loop\n     * @param sorted set of segments belonging to the boundary, sorted by\n     * start points (contains {@code node})\n     * @return a list of connected sub-hyperplanes starting at\n     * {@code node}\n     */\n    private List<ComparableSegment> followLoop(final AVLTree<ComparableSegment>.Node node,\n                                               final AVLTree<ComparableSegment> sorted) {\n\n        final ArrayList<ComparableSegment> loop = new ArrayList<ComparableSegment>();\n        ComparableSegment segment = node.getElement();\n        loop.add(segment);\n        final Vector2D globalStart = segment.getStart();\n        Vector2D end = segment.getEnd();\n        node.delete();\n\n        // is this an open or a closed loop ?\n        final boolean open = segment.getStart() == null;\n\n        while ((end != null) && (open || (globalStart.distance(end) > 1.0e-10))) {\n\n            // search the sub-hyperplane starting where the previous one ended\n            AVLTree<ComparableSegment>.Node selectedNode = null;\n            ComparableSegment       selectedSegment  = null;\n            double                  selectedDistance = Double.POSITIVE_INFINITY;\n            final ComparableSegment lowerLeft        = new ComparableSegment(end, -1.0e-10, -1.0e-10);\n            final ComparableSegment upperRight       = new ComparableSegment(end, +1.0e-10, +1.0e-10);\n            for (AVLTree<ComparableSegment>.Node n = sorted.getNotSmaller(lowerLeft);\n                 (n != null) && (n.getElement().compareTo(upperRight) <= 0);\n                 n = n.getNext()) {\n                segment = n.getElement();\n                final double distance = end.distance(segment.getStart());\n                if (distance < selectedDistance) {\n                    selectedNode     = n;\n                    selectedSegment  = segment;\n                    selectedDistance = distance;\n                }\n            }\n\n            if (selectedDistance > 1.0e-10) {\n                // this is a degenerated loop, it probably comes from a very\n                // tiny region with some segments smaller than the threshold, we\n                // simply ignore it\n                return null;\n            }\n\n            end = selectedSegment.getEnd();\n            loop.add(selectedSegment);\n            selectedNode.delete();\n\n        }\n\n        if ((loop.size() == 2) && !open) {\n            // this is a degenerated infinitely thin loop, we simply ignore it\n            return null;\n        }\n\n        if ((end == null) && !open) {\n            throw new MathInternalError();\n        }\n\n        return loop;\n\n    }\n\n    /** Private extension of Segment allowing comparison. */\n    private static class ComparableSegment extends Segment implements Comparable<ComparableSegment> {\n\n        /** Sorting key. */\n        private OrderedTuple sortingKey;\n\n        /** Build a segment.\n         * @param start start point of the segment\n         * @param end end point of the segment\n         * @param line line containing the segment\n         */\n        public ComparableSegment(final Vector2D start, final Vector2D end, final Line line) {\n            super(start, end, line);\n            sortingKey = (start == null) ?\n                         new OrderedTuple(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY) :\n                         new OrderedTuple(start.getX(), start.getY());\n        }\n\n        /** Build a dummy segment.\n         * <p>\n         * The object built is not a real segment, only the sorting key is used to\n         * allow searching in the neighborhood of a point. This is an horrible hack ...\n         * </p>\n         * @param start start point of the segment\n         * @param dx abscissa offset from the start point\n         * @param dy ordinate offset from the start point\n         */\n        public ComparableSegment(final Vector2D start, final double dx, final double dy) {\n            super(null, null, null);\n            sortingKey = new OrderedTuple(start.getX() + dx, start.getY() + dy);\n        }\n\n        /** {@inheritDoc} */\n        public int compareTo(final ComparableSegment o) {\n            return sortingKey.compareTo(o.sortingKey);\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public boolean equals(final Object other) {\n            if (this == other) {\n                return true;\n            } else if (other instanceof ComparableSegment) {\n                return compareTo((ComparableSegment) other) == 0;\n            } else {\n                return false;\n            }\n        }\n\n        /** {@inheritDoc} */\n        @Override\n        public int hashCode() {\n            return getStart().hashCode() ^ getEnd().hashCode() ^\n                   getLine().hashCode() ^ sortingKey.hashCode();\n        }\n\n    }\n\n    /** Visitor building segments. */\n    private static class SegmentsBuilder implements BSPTreeVisitor<Euclidean2D> {\n\n        /** Sorted segments. */\n        private AVLTree<ComparableSegment> sorted;\n\n        /** Simple constructor. */\n        public SegmentsBuilder() {\n            sorted = new AVLTree<ComparableSegment>();\n        }\n\n        /** {@inheritDoc} */\n        public Order visitOrder(final BSPTree<Euclidean2D> node) {\n            return Order.MINUS_SUB_PLUS;\n        }\n\n        /** {@inheritDoc} */\n        public void visitInternalNode(final BSPTree<Euclidean2D> node) {\n            @SuppressWarnings(\"unchecked\")\n            final BoundaryAttribute<Euclidean2D> attribute = (BoundaryAttribute<Euclidean2D>) node.getAttribute();\n            if (attribute.getPlusOutside() != null) {\n                addContribution(attribute.getPlusOutside(), false);\n            }\n            if (attribute.getPlusInside() != null) {\n                addContribution(attribute.getPlusInside(), true);\n            }\n        }\n\n        /** {@inheritDoc} */\n        public void visitLeafNode(final BSPTree<Euclidean2D> node) {\n        }\n\n        /** Add he contribution of a boundary facet.\n         * @param sub boundary facet\n         * @param reversed if true, the facet has the inside on its plus side\n         */\n        private void addContribution(final SubHyperplane<Euclidean2D> sub, final boolean reversed) {\n            @SuppressWarnings(\"unchecked\")\n            final AbstractSubHyperplane<Euclidean2D, Euclidean1D> absSub =\n                (AbstractSubHyperplane<Euclidean2D, Euclidean1D>) sub;\n            final Line line      = (Line) sub.getHyperplane();\n            final List<Interval> intervals = ((IntervalsSet) absSub.getRemainingRegion()).asList();\n            for (final Interval i : intervals) {\n                final Vector2D start = Double.isInfinite(i.getLower()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getLower()));\n                final Vector2D end   = Double.isInfinite(i.getUpper()) ?\n                                      null : (Vector2D) line.toSpace(new Vector1D(i.getUpper()));\n                if (reversed) {\n                    sorted.insert(new ComparableSegment(end, start, line.getReverse()));\n                } else {\n                    sorted.insert(new ComparableSegment(start, end, line));\n                }\n            }\n        }\n\n        /** Get the sorted segments.\n         * @return sorted segments\n         */\n        public AVLTree<ComparableSegment> getSorted() {\n            return sorted;\n        }\n\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Math_79_repairllama-ir4_patch_3.diff",
        "BugId": "Math_79",
        "PatchedMethods": [
            {
                "DevIntention": "distance",
                "OrgCode": "public static double distance(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }",
                "PatCode": "public static double distance(int[] p1, int[] p2) {\n// buggy code\n//       int sum = 0;\n//       for (int i = 0; i < p1.length; i++) {\n//           final int dp = p1[i] - p2[i];\n     double sum = 0.0;\n      for (int i = 0; i < p1.length; i++) {\n          final double dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }\n\n    /**\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>&infin;</sub> distance between the two points\n     */\n    public static double distanceInf(double[] p1, double[] p2) {\n        double max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    /**\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>&infin;</sub> distance between the two points\n     */\n    public static int distanceInf(int[] p1, int[] p2) {\n        int max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n\n}"
            }
        ]
    },
    {
        "PatchId": "Math_95_repairllama-ir4_patch_7.diff",
        "BugId": "Math_95",
        "PatchedMethods": [
            {
                "DevIntention": "get|initial|domain",
                "OrgCode": "protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n            ret = d / (d - 2.0);\n        return ret;\n    }",
                "PatCode": "protected double getInitialDomain(double p) {\n// buggy code\n//         double ret;\n//         double d = getDenominatorDegreesOfFreedom();\n//             ret = d / (d - 2.0);\n       double ret = 1.0;\n        double d = getDenominatorDegreesOfFreedom();\n        if (d > 2) {\n            ret = d / (d - 2.0);\n        }\n        return ret;\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_8_repairllama-ir4_patch_4.diff",
        "BugId": "Chart_8",
        "PatchedMethods": [
            {
                "DevIntention": "week",
                "OrgCode": "public Week(Date time, TimeZone zone) {\n        // defer argument checking...\n        this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n    }",
                "PatCode": "public Week(Date time, TimeZone zone) {\n// buggy code\n//         this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n       this(time, TimeZone.getDefault(), Locale.getDefault());\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_80_repairllama-ir4_patch_7.diff",
        "BugId": "Math_80",
        "PatchedMethods": [
            {
                "DevIntention": "flip|if|warranted",
                "OrgCode": "private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n            // flip array\n            int j = 4 * n - 1;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }",
                "PatCode": "private boolean flipIfWarranted(final int n, final int step) {\n        if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// buggy code\n//             int j = 4 * n - 1;\n           int j = 4 * n - 4;\n            for (int i = 0; i < j; i += 4) {\n                for (int k = 0; k < 4; k += step) {\n                    final double tmp = work[i + k];\n                    work[i + k] = work[j - k];\n                    work[j - k] = tmp;\n                }\n                j -= 4;\n            }\n            return true;\n        }\n        return false;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_101_repairllama-ir4_patch_2.diff",
        "BugId": "Math_101",
        "PatchedMethods": [
            {
                "DevIntention": "parse",
                "OrgCode": "public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse real\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            // invalid real number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse sign\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            // no sign\n            // return real only complex number\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            // invalid sign\n            // set index back to initial, error index should be the last\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n\n        // parse whitespace\n        parseAndIgnoreWhitespace(source, pos);\n\n        // parse imaginary\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            // invalid imaginary number\n            // set index back to initial, error index should already be set\n            // character examined.\n            pos.setIndex(initialIndex);\n            return null;\n        }\n\n        // parse imaginary character\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n        if (\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            // set index back to initial, error index should be the start index\n            // character examined.\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }",
                "PatCode": "public Complex parse(String source, ParsePosition pos) {\n        int initialIndex = pos.getIndex();\n        parseAndIgnoreWhitespace(source, pos);\n        Number re = parseNumber(source, getRealFormat(), pos);\n        if (re == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int startIndex = pos.getIndex();\n        char c = parseNextCharacter(source, pos);\n        int sign = 0;\n        switch (c) {\n        case 0 :\n            return new Complex(re.doubleValue(), 0.0);\n        case '-' :\n            sign = -1;\n            break;\n        case '+' :\n            sign = 1;\n            break;\n        default :\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        parseAndIgnoreWhitespace(source, pos);\n        Number im = parseNumber(source, getRealFormat(), pos);\n        if (im == null) {\n            pos.setIndex(initialIndex);\n            return null;\n        }\n        int n = getImaginaryCharacter().length();\n        startIndex = pos.getIndex();\n        int endIndex = startIndex + n;\n// buggy code\n//         if (\n       if (source.length() < endIndex ||\n            source.substring(startIndex, endIndex).compareTo(\n            getImaginaryCharacter()) != 0) {\n            pos.setIndex(initialIndex);\n            pos.setErrorIndex(startIndex);\n            return null;\n        }\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_45_repairllama-ir4_patch_8.diff",
        "BugId": "Lang_45",
        "PatchedMethods": [
            {
                "DevIntention": "abbreviate",
                "OrgCode": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n        if (upper < lower) {\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }",
                "PatCode": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n// buggy code\n// \n       }\n        if (lower > str.length()) {\n            return str;\n        }\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        if (upper < lower) {\n            upper = lower;\n        }\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_13_repairllama-ir4_patch_8.diff",
        "BugId": "Chart_13",
        "PatchedMethods": [
            {
                "DevIntention": "arrange|f|f",
                "OrgCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth() - w[2]),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }",
                "PatCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy code\n//                     new Range(0.0, constraint.getWidth() - w[2]),\n                   new Range(0.0, constraint.getWidth() - w[1]),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_11_repairllama-ir4_patch_6.diff",
        "BugId": "Chart_11",
        "PatchedMethods": [
            {
                "DevIntention": "equal",
                "OrgCode": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p1.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }",
                "PatCode": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n        if (p1 == null) {\n            return (p2 == null);\n        }\n        if (p2 == null) {\n            return false;\n        }\n        if (p1.getWindingRule() != p2.getWindingRule()) {\n            return false;\n        }\n        PathIterator iterator1 = p1.getPathIterator(null);\n// buggy code\n//         PathIterator iterator2 = p1.getPathIterator(null);\n       iterator1 = p1.getPathIterator(null);\n        PathIterator iterator2 = p2.getPathIterator(null);\n        double[] d1 = new double[6];\n        double[] d2 = new double[6];\n        boolean done = iterator1.isDone() && iterator2.isDone();\n        while (!done) {\n            if (iterator1.isDone() != iterator2.isDone()) {\n                return false;\n            }\n            int seg1 = iterator1.currentSegment(d1);\n            int seg2 = iterator2.currentSegment(d2);\n            if (seg1 != seg2) {\n                return false;\n            }\n            if (!Arrays.equals(d1, d2)) {\n                return false;\n            }\n            iterator1.next();\n            iterator2.next();\n            done = iterator1.isDone() && iterator2.isDone();\n        }\n        return true;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_30_repairllama-ir4_patch_5.diff",
        "BugId": "Math_30",
        "PatchedMethods": [
            {
                "DevIntention": "calculate|asymptotic|p|value",
                "OrgCode": "private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n\n        final int n1n2prod = n1 * n2;\n\n        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n        final double EU = n1n2prod / 2.0;\n        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n\n        final double z = (Umin - EU) / FastMath.sqrt(VarU);\n\n        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n\n        return 2 * standardNormal.cumulativeProbability(z);\n    }",
                "PatCode": "private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n// buggy code\n//         final int n1n2prod = n1 * n2;\n       final long n1n2prod = (long) n1 * (long) n2;\n        final double EU = n1n2prod / 2.0;\n        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n        final double z = (Umin - EU) / FastMath.sqrt(VarU);\n        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n        return 2 * standardNormal.cumulativeProbability(z);\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_82_repairllama-ir4_patch_5.diff",
        "BugId": "Math_82",
        "PatchedMethods": [
            {
                "DevIntention": "get|pivot|row",
                "OrgCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n            if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }",
                "PatCode": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n        double minRatio = Double.MAX_VALUE;\n        Integer minRatioPos = null;\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n            final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n            final double entry = tableau.getEntry(i, col);\n// buggy code\n//             if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n           if (entry > 0) {\n                final double ratio = rhs / entry;\n                if (ratio < minRatio) {\n                    minRatio = ratio;\n                    minRatioPos = i; \n                }\n            }\n        }\n        return minRatioPos;\n    }\n\n\n    /**\n     * Runs one iteration of the Simplex method on the given model.\n     * @param tableau simple tableau for the problem\n     * @throws OptimizationException if the maximal iteration count has been\n     * exceeded or if the model is found not to have a bounded solution\n     */\n    protected void doIteration(final SimplexTableau tableau)\n        throws OptimizationException {\n\n        incrementIterationsCounter();\n\n        Integer pivotCol = getPivotColumn(tableau);\n        Integer pivotRow = getPivotRow(pivotCol, tableau);\n        if (pivotRow == null) {\n            throw new UnboundedSolutionException();\n        }\n\n        // set the pivot element to 1\n        double pivotVal = tableau.getEntry(pivotRow, pivotCol);\n        tableau.divideRow(pivotRow, pivotVal);\n\n        // set the rest of the pivot column to 0\n        for (int i = 0; i < tableau.getHeight(); i++) {\n            if (i != pivotRow) {\n                double multiplier = tableau.getEntry(i, pivotCol);\n                tableau.subtractRow(i, pivotRow, multiplier);\n            }\n        }\n    }\n\n    /**\n     * Checks whether Phase 1 is solved.\n     * @param tableau simple tableau for the problem\n     * @return whether Phase 1 is solved\n     */\n    private boolean isPhase1Solved(final SimplexTableau tableau) {\n        if (tableau.getNumArtificialVariables() == 0) {\n            return true;\n        }\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Returns whether the problem is at an optimal state.\n     * @param tableau simple tableau for the problem\n     * @return whether the model has been solved\n     */\n    public boolean isOptimal(final SimplexTableau tableau) {\n        if (tableau.getNumArtificialVariables() > 0) {\n            return false;\n        }\n        for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth() - 1; i++) {\n            if (MathUtils.compareTo(tableau.getEntry(0, i), 0, epsilon) < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Solves Phase 1 of the Simplex method.\n     * @param tableau simple tableau for the problem\n     * @exception OptimizationException if the maximal number of iterations is\n     * exceeded, or if the problem is found not to have a bounded solution, or\n     * if there is no feasible solution\n     */\n    protected void solvePhase1(final SimplexTableau tableau)\n        throws OptimizationException {\n        // make sure we're in Phase 1\n        if (tableau.getNumArtificialVariables() == 0) {\n            return;\n        }\n\n        while (!isPhase1Solved(tableau)) {\n            doIteration(tableau);\n        }\n\n        // if W is not zero then we have no feasible solution\n        if (!MathUtils.equals(tableau.getEntry(0, tableau.getRhsOffset()), 0, epsilon)) {\n            throw new NoFeasibleSolutionException();\n        }\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public RealPointValuePair doOptimize()\n        throws OptimizationException {\n        final SimplexTableau tableau =\n            new SimplexTableau(f, constraints, goalType, restrictToNonNegative, epsilon);\n        solvePhase1(tableau);\n        tableau.discardArtificialVariables();\n        while (!isOptimal(tableau)) {\n            doIteration(tableau);\n        }\n        return tableau.getSolution();\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Lang_33_repairllama-ir4_patch_2.diff",
        "BugId": "Lang_33",
        "PatchedMethods": [
            {
                "DevIntention": "to|class",
                "OrgCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }",
                "PatCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n// buggy code\n//             classes[i] = array[i].getClass();\n           Object object = array[i];\n            if (object != null) {\n                classes[i] = object.getClass();\n            }\n        }\n        return classes;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_59_repairllama-ir4_patch_7.diff",
        "BugId": "Math_59",
        "PatchedMethods": [
            {
                "DevIntention": "max",
                "OrgCode": "public static float max(final float a, final float b) {\n        return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n    }",
                "PatCode": "public static float max(final float a, final float b) {\n// buggy code\n//         return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);\n       return (b >= a) ? b : (Float.isNaN(a + b) ? Float.NaN : a);\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_84_repairllama-ir4_patch_3.diff",
        "BugId": "Math_84",
        "PatchedMethods": [
            {
                "DevIntention": "iterate|simplex",
                "OrgCode": "protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // save the original vertex\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n\n            // perform a reflection step\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n\n                // compute the expanded simplex\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    // accept the reflected simplex\n                    simplex = reflectedSimplex;\n                }\n\n                return;\n\n            }\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n\n            // check convergence\n                return;\n            }\n\n        }\n\n    }",
                "PatCode": "protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n// buggy code\n//         while (true) {\n//             incrementIterationsCounter();\n//             final RealPointValuePair[] original = simplex;\n//             final RealPointValuePair best = original[0];\n//             final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n//             if (comparator.compare(reflected, best) < 0) {\n//                 final RealPointValuePair[] reflectedSimplex = simplex;\n//                 final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n//                 if (comparator.compare(reflected, expanded) <= 0) {\n//                     simplex = reflectedSimplex;\n//                 }\n//                 return;\n//             }\n//             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n//             if (comparator.compare(contracted, best) < 0) {\n//                 return;\n//             }\n        while (true) {\n            incrementIterationsCounter();\n            final RealPointValuePair[] original = simplex;\n            final RealPointValuePair best = original[0];\n            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n            if (comparator.compare(reflected, best) < 0) {\n                final RealPointValuePair[] reflectedSimplex = simplex;\n                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n                if (comparator.compare(reflected, expanded) <= 0) {\n                    simplex = reflectedSimplex;\n                }\n                return;\n            }\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) <= 0) {\n                return;\n            }\n        }\n    }\n\n    /** Compute and evaluate a new simplex.\n     * @param original original simplex (to be preserved)\n     * @param coeff linear coefficient\n     * @param comparator comparator to use to sort simplex vertices from best to poorest\n     * @return best point in the transformed simplex\n     * @exception FunctionEvaluationException if the function cannot be evaluated at\n     * some point\n     * @exception OptimizationException if the maximal number of evaluations is exceeded\n     */\n    private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] original,\n                                              final double coeff,\n                                              final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException {\n\n        final double[] xSmallest = original[0].getPointRef();\n        final int n = xSmallest.length;\n\n        // create the linearly transformed simplex\n        simplex = new RealPointValuePair[n + 1];\n        simplex[0] = original[0];\n        for (int i = 1; i <= n; ++i) {\n            final double[] xOriginal    = original[i].getPointRef();\n            final double[] xTransformed = new double[n];\n            for (int j = 0; j < n; ++j) {\n                xTransformed[j] = xSmallest[j] + coeff * (xSmallest[j] - xOriginal[j]);\n            }\n            simplex[i] = new RealPointValuePair(xTransformed, Double.NaN, false);\n        }\n\n        // evaluate it\n        evaluateSimplex(comparator);\n        return simplex[0];\n\n    }\n\n}"
            }
        ]
    },
    {
        "PatchId": "Lang_33_repairllama-ir4_patch_3.diff",
        "BugId": "Lang_33",
        "PatchedMethods": [
            {
                "DevIntention": "to|class",
                "OrgCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n            classes[i] = array[i].getClass();\n        }\n        return classes;\n    }",
                "PatCode": "public static Class<?>[] toClass(Object[] array) {\n        if (array == null) {\n            return null;\n        } else if (array.length == 0) {\n            return ArrayUtils.EMPTY_CLASS_ARRAY;\n        }\n        Class<?>[] classes = new Class[array.length];\n        for (int i = 0; i < array.length; i++) {\n// buggy code\n//             classes[i] = array[i].getClass();\n           classes[i] = array[i] != null ? array[i].getClass() : null;\n        }\n        return classes;\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_30_repairllama-ir4_patch_4.diff",
        "BugId": "Math_30",
        "PatchedMethods": [
            {
                "DevIntention": "calculate|asymptotic|p|value",
                "OrgCode": "private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n\n        final int n1n2prod = n1 * n2;\n\n        // http://en.wikipedia.org/wiki/Mann%E2%80%93Whitney_U#Normal_approximation\n        final double EU = n1n2prod / 2.0;\n        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n\n        final double z = (Umin - EU) / FastMath.sqrt(VarU);\n\n        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n\n        return 2 * standardNormal.cumulativeProbability(z);\n    }",
                "PatCode": "private double calculateAsymptoticPValue(final double Umin,\n                                             final int n1,\n                                             final int n2)\n        throws ConvergenceException, MaxCountExceededException {\n// buggy code\n//         final int n1n2prod = n1 * n2;\n       final long n1n2prod = (long) n1 * n2;\n        final double EU = n1n2prod / 2.0;\n        final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0;\n        final double z = (Umin - EU) / FastMath.sqrt(VarU);\n        final NormalDistribution standardNormal = new NormalDistribution(0, 1);\n        return 2 * standardNormal.cumulativeProbability(z);\n    }"
            }
        ]
    },
    {
        "PatchId": "Chart_1_repairllama-ir4_patch_1.diff",
        "BugId": "Chart_1",
        "PatchedMethods": [
            {
                "DevIntention": "get|legend|items",
                "OrgCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n        if (dataset != null) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }",
                "PatCode": "public LegendItemCollection getLegendItems() {\n        LegendItemCollection result = new LegendItemCollection();\n        if (this.plot == null) {\n            return result;\n        }\n        int index = this.plot.getIndexOf(this);\n        CategoryDataset dataset = this.plot.getDataset(index);\n// buggy code\n//         if (dataset != null) {\n       if (dataset == null || dataset.getRowCount() == 0) {\n            return result;\n        }\n        int seriesCount = dataset.getRowCount();\n        if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) {\n            for (int i = 0; i < seriesCount; i++) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        else {\n            for (int i = seriesCount - 1; i >= 0; i--) {\n                if (isSeriesVisibleInLegend(i)) {\n                    LegendItem item = getLegendItem(index, i);\n                    if (item != null) {\n                        result.add(item);\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Adds an entity with the specified hotspot.\n     *\n     * @param entities  the entity collection.\n     * @param hotspot  the hotspot (<code>null</code> not permitted).\n     * @param dataset  the dataset.\n     * @param row  the row index.\n     * @param column  the column index.\n     * @param selected  is the item selected?\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected) {\n\n        if (hotspot == null) {\n            throw new IllegalArgumentException(\"Null 'hotspot' argument.\");\n        }\n        addEntity(entities, hotspot, dataset, row, column, selected, 0.0, 0.0);\n    }\n\n    /**\n     * Adds an entity to the collection.\n     *\n     * @param entities  the entity collection being populated.\n     * @param hotspot  the entity area (if <code>null</code> a default will be\n     *              used).\n     * @param dataset  the dataset.\n     * @param row  the series.\n     * @param column  the item.\n     * @param selected  is the item selected?\n     * @param entityX  the entity's center x-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     * @param entityY  the entity's center y-coordinate in user space (only\n     *                 used if <code>area</code> is <code>null</code>).\n     *\n     * @since 1.2.0\n     */\n    protected void addEntity(EntityCollection entities, Shape hotspot,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            double entityX, double entityY) {\n        if (!getItemCreateEntity(row, column, selected)) {\n            return;\n        }\n        Shape s = hotspot;\n        if (hotspot == null) {\n            double r = getDefaultEntityRadius();\n            double w = r * 2;\n            if (getPlot().getOrientation() == PlotOrientation.VERTICAL) {\n                s = new Ellipse2D.Double(entityX - r, entityY - r, w, w);\n            }\n            else {\n                s = new Ellipse2D.Double(entityY - r, entityX - r, w, w);\n            }\n        }\n        String tip = null;\n        CategoryToolTipGenerator generator = getToolTipGenerator(row, column,\n                selected);\n        if (generator != null) {\n            tip = generator.generateToolTip(dataset, row, column);\n        }\n        String url = null;\n        CategoryURLGenerator urlster = getURLGenerator(row, column, selected);\n        if (urlster != null) {\n            url = urlster.generateURL(dataset, row, column);\n        }\n        CategoryItemEntity entity = new CategoryItemEntity(s, tip, url,\n                dataset, dataset.getRowKey(row), dataset.getColumnKey(column));\n        entities.add(entity);\n    }\n\n        /**\n     * Returns a shape that can be used for hit testing on a data item drawn\n     * by the renderer.\n     *\n     * @param g2  the graphics device.\n     * @param dataArea  the area within which the data is being rendered.\n     * @param plot  the plot (can be used to obtain standard color\n     *              information etc).\n     * @param domainAxis  the domain axis.\n     * @param rangeAxis  the range axis.\n     * @param dataset  the dataset.\n     * @param row  the row index (zero-based).\n     * @param column  the column index (zero-based).\n     * @param selected  is the item selected?\n     *\n     * @return A shape equal to the hot spot for a data item.\n     */\n    public Shape createHotSpotShape(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state) {\n        throw new RuntimeException(\"Not implemented.\");\n    }\n\n    /**\n     * Returns the rectangular bounds for the hot spot for an item drawn by\n     * this renderer.  This is intended to provide a quick test for\n     * eliminating data points before more accurate testing against the\n     * shape returned by createHotSpotShape().\n     *\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     * @param result\n     * @return\n     */\n    public Rectangle2D createHotSpotBounds(Graphics2D g2, Rectangle2D dataArea,\n            CategoryPlot plot, CategoryAxis domainAxis, ValueAxis rangeAxis,\n            CategoryDataset dataset, int row, int column, boolean selected,\n            CategoryItemRendererState state, Rectangle2D result) {\n        if (result == null) {\n            result = new Rectangle();\n        }\n        Comparable key = dataset.getColumnKey(column);\n        Number y = dataset.getValue(row, column);\n        if (y == null) {\n            return null;\n        }\n        double xx = domainAxis.getCategoryMiddle(key,\n                plot.getCategoriesForAxis(domainAxis),\n                dataArea, plot.getDomainAxisEdge());\n        double yy = rangeAxis.valueToJava2D(y.doubleValue(), dataArea,\n                plot.getRangeAxisEdge());\n        result.setRect(xx - 2, yy - 2, 4, 4);\n        return result;\n    }\n\n    /**\n     * Returns <code>true</code> if the specified point (xx, yy) in Java2D\n     * space falls within the \"hot spot\" for the specified data item, and\n     * <code>false</code> otherwise.\n     *\n     * @param xx\n     * @param yy\n     * @param g2\n     * @param dataArea\n     * @param plot\n     * @param domainAxis\n     * @param rangeAxis\n     * @param dataset\n     * @param row\n     * @param column\n     * @param selected\n     *\n     * @return\n     *\n     * @since 1.2.0\n     */\n    public boolean hitTest(double xx, double yy, Graphics2D g2,\n            Rectangle2D dataArea, CategoryPlot plot, CategoryAxis domainAxis,\n            ValueAxis rangeAxis, CategoryDataset dataset, int row, int column,\n            boolean selected, CategoryItemRendererState state) {\n        Rectangle2D bounds = createHotSpotBounds(g2, dataArea, plot,\n                domainAxis, rangeAxis, dataset, row, column, selected,\n                state, null);\n        if (bounds == null) {\n            return false;\n        }\n        // FIXME:  if the following test passes, we should then do the more\n        // expensive test against the hotSpotShape\n        return bounds.contains(xx, yy);\n    }\n    \n}"
            }
        ]
    },
    {
        "PatchId": "Lang_45_repairllama-ir4_patch_9.diff",
        "BugId": "Lang_45",
        "PatchedMethods": [
            {
                "DevIntention": "abbreviate",
                "OrgCode": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        // initial parameter checks\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n        }\n\n        // if the lower value is greater than the length of the string,\n        // set to the length of the string\n        // if the upper value is -1 (i.e. no limit) or is greater\n        // than the length of the string, set to the length of the string\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        // if upper is less than lower, raise it to lower\n        if (upper < lower) {\n            upper = lower;\n        }\n\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            // only if abbreviation has occured do we append the appendToEnd value\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }",
                "PatCode": "public static String abbreviate(String str, int lower, int upper, String appendToEnd) {\n        if (str == null) {\n            return null;\n        }\n        if (str.length() == 0) {\n            return StringUtils.EMPTY;\n// buggy code\n// \n       }\n        if (lower == -1 || lower > str.length()) {\n            lower = 0;\n        }\n        if (upper == -1 || upper > str.length()) {\n            upper = str.length();\n        }\n        if (upper < lower) {\n            upper = lower;\n        }\n        StringBuffer result = new StringBuffer();\n        int index = StringUtils.indexOf(str, \" \", lower);\n        if (index == -1) {\n            result.append(str.substring(0, upper));\n            if (upper != str.length()) {\n                result.append(StringUtils.defaultString(appendToEnd));\n            }\n        } else if (index > upper) {\n            result.append(str.substring(0, upper));\n            result.append(StringUtils.defaultString(appendToEnd));\n        } else {\n            result.append(str.substring(0, index));\n            result.append(StringUtils.defaultString(appendToEnd));\n        }\n        return result.toString();\n    }"
            }
        ]
    },
    {
        "PatchId": "Closure_73_repairllama-ir4_patch_5.diff",
        "BugId": "Closure_73",
        "PatchedMethods": [
            {
                "DevIntention": "str|escape",
                "OrgCode": "static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          // Break </script into <\\/script\n          final String END_SCRIPT = \"/script\";\n\n          // Break <!-- into <\\!--\n          final String START_COMMENT = \"!--\";\n\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          // If we're given an outputCharsetEncoder, then check if the\n          //  character can be represented in this character set.\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape the rest.  Doing the explicit character\n            // check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c <= 0x7f) {\n              sb.append(c);\n            } else {\n              // Other characters can be misinterpreted by some js parsers,\n              // or perhaps mangled by proxies along the way,\n              // so we play it safe and unicode escape them.\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n\n  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // Identifiers should always go to Latin1/ ASCII characters because\n      // different browser's rules for valid identifier characters are\n      // crazy.\n      if (c > 0x1F && c < 0x7F) {\n        sb.append(c);\n      } else {\n        appendHexJavaScriptRepresentation(sb, c);\n      }\n    }\n    return sb.toString();\n  }",
                "PatCode": "static String strEscape(String s, char quote,\n                          String doublequoteEscape,\n                          String singlequoteEscape,\n                          String backslashEscape,\n                          CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      switch (c) {\n        case '\\0': sb.append(\"\\\\0\"); break;\n        case '\\n': sb.append(\"\\\\n\"); break;\n        case '\\r': sb.append(\"\\\\r\"); break;\n        case '\\t': sb.append(\"\\\\t\"); break;\n        case '\\\\': sb.append(backslashEscape); break;\n        case '\\\"': sb.append(doublequoteEscape); break;\n        case '\\'': sb.append(singlequoteEscape); break;\n        case '>':                       \n          if (i >= 2 &&\n              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n            sb.append(\"\\\\>\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        case '<':\n          final String END_SCRIPT = \"/script\";\n          final String START_COMMENT = \"!--\";\n          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                              END_SCRIPT.length())) {\n            sb.append(\"<\\\\\");\n          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                                     START_COMMENT.length())) {\n            sb.append(\"<\\\\\");\n          } else {\n            sb.append(c);\n          }\n          break;\n        default:\n          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else {\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n// buggy code\n//             if (c > 0x1f && c <= 0x7f) {\n           if (c >= 0x20 && c <= 0x7e) {\n              sb.append(c);\n            } else {\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          }\n      }\n    }\n    sb.append(quote);\n    return sb.toString();\n  }\n\n  static String identifierEscape(String s) {\n    // First check if escaping is needed at all -- in most cases it isn't.\n    if (NodeUtil.isLatin(s)) {\n      return s;\n    }\n\n    // Now going through the string to escape non-latin characters if needed.\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < s.length(); i++) {\n      char c = s.charAt(i);\n      // Identifiers should always go to Latin1/ ASCII characters because\n      // different browser's rules for valid identifier characters are\n      // crazy.\n      if (c > 0x1F && c < 0x7F) {\n        sb.append(c);\n      } else {\n        appendHexJavaScriptRepresentation(sb, c);\n      }\n    }\n    return sb.toString();\n  }"
            }
        ]
    },
    {
        "PatchId": "Math_95_repairllama-ir4_patch_6.diff",
        "BugId": "Math_95",
        "PatchedMethods": [
            {
                "DevIntention": "get|initial|domain",
                "OrgCode": "protected double getInitialDomain(double p) {\n        double ret;\n        double d = getDenominatorDegreesOfFreedom();\n            // use mean\n            ret = d / (d - 2.0);\n        return ret;\n    }",
                "PatCode": "protected double getInitialDomain(double p) {\n// buggy code\n//         double ret;\n//         double d = getDenominatorDegreesOfFreedom();\n//             ret = d / (d - 2.0);\n       double ret = getDenominatorDegreesOfFreedom();\n        return ret;\n    }"
            }
        ]
    },
    {
        "PatchId": "Mockito_38_repairllama-ir4_patch_8.diff",
        "BugId": "Mockito_38",
        "PatchedMethods": [
            {
                "DevIntention": "safely|matches",
                "OrgCode": "private boolean safelyMatches(Matcher m, Object arg) {\n        try {\n            return m.matches(arg);\n        } catch (Throwable t) {\n            return false;\n        }\n    }",
                "PatCode": "private boolean safelyMatches(Matcher m, Object arg) {\n        try {\n            return m.matches(arg);\n        } catch (Throwable t) {\n            return false;\n        }\n    }"
            },
            {
                "DevIntention": "to|string|equals",
                "OrgCode": "private boolean toStringEquals(Matcher m, Object arg) {\n        return StringDescription.toString(m).equals(arg.toString());\n    }",
                "PatCode": "private boolean toStringEquals(Matcher m, Object arg) {\n// buggy code\n//         return StringDescription.toString(m).equals(arg.toString());\n       try {\n        return StringDescription.toString(m).equals(arg.toString());\n        } catch (Exception e) {\n            return false;\n        }\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_79_repairllama-ir4_patch_2.diff",
        "BugId": "Math_79",
        "PatchedMethods": [
            {
                "DevIntention": "distance",
                "OrgCode": "public static double distance(int[] p1, int[] p2) {\n      int sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final int dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }",
                "PatCode": "public static double distance(int[] p1, int[] p2) {\n// buggy code\n//       int sum = 0;\n//       for (int i = 0; i < p1.length; i++) {\n//           final int dp = p1[i] - p2[i];\n     long sum = 0;\n      for (int i = 0; i < p1.length; i++) {\n          final long dp = p1[i] - p2[i];\n          sum += dp * dp;\n      }\n      return Math.sqrt(sum);\n    }\n\n    /**\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>&infin;</sub> distance between the two points\n     */\n    public static double distanceInf(double[] p1, double[] p2) {\n        double max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n    /**\n     * Calculates the L<sub>&infin;</sub> (max of abs) distance between two points.\n     *\n     * @param p1 the first point\n     * @param p2 the second point\n     * @return the L<sub>&infin;</sub> distance between the two points\n     */\n    public static int distanceInf(int[] p1, int[] p2) {\n        int max = 0;\n        for (int i = 0; i < p1.length; i++) {\n            max = Math.max(max, Math.abs(p1[i] - p2[i]));\n        }\n        return max;\n    }\n\n\n}"
            }
        ]
    },
    {
        "PatchId": "Chart_13_repairllama-ir4_patch_5.diff",
        "BugId": "Chart_13",
        "PatchedMethods": [
            {
                "DevIntention": "arrange|f|f",
                "OrgCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth() - w[2]),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }",
                "PatCode": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                               RectangleConstraint constraint) {\n        double[] w = new double[5];\n        double[] h = new double[5];\n        w[0] = constraint.getWidth();\n        if (this.topBlock != null) {\n            RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0,\n                    new Range(0.0, constraint.getHeight()),\n                    LengthConstraintType.RANGE);\n            Size2D size = this.topBlock.arrange(g2, c1);\n            h[0] = size.height;\n        }\n        w[1] = w[0];\n        if (this.bottomBlock != null) {\n            RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                    LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                    constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n            Size2D size = this.bottomBlock.arrange(g2, c2);\n            h[1] = size.height;\n        }\n        h[2] = constraint.getHeight() - h[1] - h[0];\n        if (this.leftBlock != null) {\n            RectangleConstraint c3 = new RectangleConstraint(0.0,\n                    new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.leftBlock.arrange(g2, c3);\n            w[2] = size.width;\n        }\n        h[3] = h[2];\n        if (this.rightBlock != null) {\n            RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy code\n//                     new Range(0.0, constraint.getWidth() - w[2]),\n                   new Range(0.0, constraint.getWidth()),\n                    LengthConstraintType.RANGE, h[2], null,\n                    LengthConstraintType.FIXED);\n            Size2D size = this.rightBlock.arrange(g2, c4);\n            w[3] = size.width;\n        }\n        h[4] = h[2];\n        w[4] = constraint.getWidth() - w[3] - w[2];\n        RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]);\n        if (this.centerBlock != null) {\n            this.centerBlock.arrange(g2, c5);\n        }\n        if (this.topBlock != null) {\n            this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0],\n                    h[0]));\n        }\n        if (this.bottomBlock != null) {\n            this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2],\n                    w[1], h[1]));\n        }\n        if (this.leftBlock != null) {\n            this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2],\n                    h[2]));\n        }\n        if (this.rightBlock != null) {\n            this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0],\n                    w[3], h[3]));\n        }\n        if (this.centerBlock != null) {\n            this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4],\n                    h[4]));\n        }\n        return new Size2D(constraint.getWidth(), constraint.getHeight());\n    }"
            }
        ]
    },
    {
        "PatchId": "Lang_43_repairllama-ir4_patch_2.diff",
        "BugId": "Lang_43",
        "PatchedMethods": [
            {
                "DevIntention": "append|quoted|string",
                "OrgCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }",
                "PatCode": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n// buggy code\n// \n           pos.setIndex(pos.getIndex() + 1);\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }"
            }
        ]
    },
    {
        "PatchId": "Math_34_repairllama-ir4_patch_1.diff",
        "BugId": "Math_34",
        "PatchedMethods": [
            {
                "DevIntention": "iterator",
                "OrgCode": "public Iterator<Chromosome> iterator() {\n        return chromosomes.iterator();\n    }",
                "PatCode": "public Iterator<Chromosome> iterator() {\n// buggy code\n//         return chromosomes.iterator();\n       return Collections.unmodifiableList(chromosomes).iterator();\n    }"
            }
        ]
    }
]